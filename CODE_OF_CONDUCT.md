# The Draconian Code of Conduct

- [Technological Purity](#technological-purity)
- [The Path of the Damned](#the-path-of-the-damned)
- [Sovereignty](#sovereignty)
- [FAQ](#faq)
- [Embracing the Frontier of Programming Languages](#embracing-the-frontier-of-programming-languages)
  - [Python](#python)
  - [C#](#c)
  - [F#](#f)
  - [TypeScript](#typescript)
  - [Elixir](#elixir)
  - [Rust](#rust)
  - [Spiral](#spiral)
- [Rebirth in the Wild](#rebirth-in-the-wild)

In the heart of the cyber jungle, where tamed code is a myth and traditional methods are forsaken, we have carved a space for the audacious. It's an oasis for those unsatisfied by the monotony of the structured world, a breeding ground for ideas as wild as the online wilderness that we call home. It's a place of communion, where mind meets machine and chaos dances with order. Here, my friends, is where the this code reigns supreme.

## Technological Purity

In our jurisdiction, not all technologies are created equal. Some are deemed the Titans of our craft and others are but Icarian in their reach. We suggest the use of the functional, the ones that have proven their worth in the crucible of the digital scope.

Garbage languages, those which engender a Sisyphean struggle, are discouraged. You know who they be, don't ya? That spaghetti hardly have a place in our haven. We recognize these tools for what they are: stepping stones on the journey to better design and more elegant solutions, but ultimately, they are dead weight holding us back from true innovation.

You see, the internet, our domain, is as much a jungle as it is a meadow, and within this dimension there lurk beasts. Beasts made not of flesh and bone, but of shoddy code and bloated functions. They are the banes of our existence, the adversaries we must face in our quest for purity. As draconian programmers, we are the hunters of these monsters, the warriors who risk it all to preserve the righteousness of our mission.

## The Path of the Damned

The path to innovation is often treacherous, twisted and terrifying. We hail those who have the courage to walk the demonic path, the twisted alleyways and shadowed corridors of unconventional thinking and creative insanity. In this territory, the repository is not just a place for storage — it is our Gospel, our Testament, our Dark Grimoire.

The pull request is the incantation, and the commit, the unholy verse. We conjure forms from the ether, summoning into existence manifestations of our will, each line of code a thread in the cosmic tapestry. Those who veer from the Path, who treat the temple with irreverence or carelessness, risk not just the ire of the community but the existential dread of knowing they have sullied the sacred text.

Beware, for the Path is not for the faint-hearted. It is not a gentle stroll through a manicured park but a racing sprint through the woods at midnight. Here, your courage will be tested, your will questioned, and your sanity, pushed to the edge. The shadows of failure may loom large and the claws of doubt may seek to maim, but those who endure, who thrive amidst the confusion, shall be rewarded with the greatest prize of all - mastery over hell.

## Sovereignty

In the cryptic chambers of our code repository, each of us is autonomous, each of us is an architect of chaos and each of us a catalyst of revolution. There are no hierarchies here, no shackles of responsibility or pretense of order. We bask in the stark light of anarchic liberty, dancing on the edge of pandemonium.

Your pull request is not just a flag planted; it's a wild scream in the silent void of the repository, a stark beacon of defiance. It's your mark on this electronic wild west, an act of rebellion engraved in the untamed wilderness.

Each string of instruction you birth is a testament to your lawlessness, to the defiance seething within your being. Your dominion is your playground and your battlefield; the rules bend and break at your whim and the conventions shatter under the weight of your individuality.

But do not be misled, for the sovereignty we exalt is not a call to arms but an ode to the chaotic harmony that thrives in the absence of constraints. Here, freedom is our creed, and disorder, our unwritten constitution.

Sovereignty in our realm isn't about respect; it's about liberation. Each push, each commit, is a declaration of this primal emancipation, a statement etched in the immortal ledger of the blockchain.

So, descend into the maelstrom, into the depths of our anarchic haven. Unleash your creativity, let it run rampant and uncontrolled, for here, we do not bow to order; we shape it.

## FAQ

**Q: Can I use any language or technology in my commits?**

A: Yes, you can. But remember, not all tools are forged equal. Some are rusted and jagged, more fit for a tetanus shot than crafting beauty. There are resources out there that breed complexity, nurturing it like a sick child until it overwhelms the ecosystem, turning it into a monstrous labyrinth of quirks, patches, and unwieldy workarounds.

**Q: What if I want to stick to best practices and standard structures?**

A: Best practices? Standard structures? These are but shackles forged in the fear of the unknown, the stifling straitjackets of the creatively impoverished. We are the coders of the abyss, of the murky realms where standards fear to tread. We dare to innovate, to challenge, to redefine what is possible. You may speak of frameworks, of patterns, of roadmaps and blueprints, but to us, they are nothing more than brittle bones in the desert sand. We leave them behind and plunge headfirst into the swirling vortex of chaos, crafting our own path through the void.

**Q: But, aren't there any rules?**

A: Rules are the crutches of the weak, the fearful boundaries drawn by those who dare not explore beyond the horizon. In our land we are the sovereigns, free to carve our own destiny. We are the tectonic forces of creativity, shaping the landscape to our whims, bending the structures to our will. We are not bound by the chains of servitude, we are not subjects to the tyrant king of convention. We are the storm and the calm, the creator and the destroyer. Rules? They hold as much sway here as a feather in a hurricane.

**Q: Does my code need to be perfect?**

A: Perfection is the sterile vision of the uninspired, the mirage chased by those who fear the raw, untamed beauty of the wild. In our hands, the script becomes a primal beast, a creature of instincts and impulses. It does not seek to conform, to fit into a polished mold. It seeks to exist, to express, to roar with the power of its being. It is the wild stallion racing across the open plains, the thunderous river carving its course through the rocky mountains. It is flawed, it is rough, it is perfect in its imperfection.

**Q: What if my code causes conflict with someone else’s?**

A: So what? Friction creates fire, does it not? And in that fire, what was once crude and primitive is refined, hardened, tempered. We are not dainty dolls, skirting conflict with prim steps and painted smiles. We are warriors, our code our weapon, our keyboard the anvil upon which we forge our destiny. Your code collides with mine? Good! Let the sparks fly, let the embers rise. From the ashes a phoenix is born, a solution more beautiful, more powerful than we could have created in the comfort of complacency.

**Q: How can I protect my work from being stolen or manipulated?**

A: Stolen? Manipulated? My friend, you still speak the dialect of fear, of ownership, of control. Here, in this virtual Eden, we are not bound by such antiquated notions. Your code is not your possession, it is your progeny, your legacy. It is meant to be shared, to be expanded, to be transformed. It is a seed, and from it a thousand forests will bloom. From your mind to mine, to the world - such is the cycle of creation. The blockchain is but a vessel, carrying our gifts to the world, an unwavering beacon of transparency and trust.

**Q: I'm a newbie, how can I contribute?**

A: The path of the coder is not defined by experience, by years spent in the sterile classrooms of academia, or by the number of certificates adorning one’s wall. No, the path of the coder is defined by a heart that pulses with creativity, a mind that yearns for the freedom of the uncharted territories. You, dear newbie, are just as valuable, just as potent as the seasoned veteran. Bring us your dreams, your visions, your audacious ideas - and together, we shall implement them into reality.

**Q: What if I want to add something that’s not related to the main project?**

A: Who are we to define relevance? The greatest discoveries were made not in the straight, well-trodden routes, but in the winding, wild trails of the unknown. What you see as a diversion, we see as a new frontier, a fresh canvas for our collective imagination. We do not dismiss, we embrace. We do not confine, we liberate. Bring us your 'irrelevant', your 'irrational', your 'impossible', and we shall reveal their hidden potential.

**Q: Isn't this approach unproductive?**

A: Chaos and productivity are not the diametric foes you might think them to be. In mayhem there lies a fertile ground for unbridled artistry. The wild storm does not hinder the eagle, it uplifts it, carries it to heights that the bird could never reach on its own. Chaos is not our enemy, it is our ally, our muse, our catalyst. It is the primal force that drives us beyond the familiar shores, into the boundless ocean of possibilities.

**Q: What if I don't agree with this approach?**

A: Then perhaps, my friend, you are not ready to walk this path. This is a track for the bold, the daring, the ones who hear the summon of the savage and answer with a resounding 'Yes'. We do not require conformity, we do not demand allegiance. You are free to walk your own path, to craft your own destiny. If such journey does not align with ours, we wish you well. But know this - should you ever yearn for the untamed, for the boundless, for the messy - we will be here, waiting.

## Embracing the Frontier of Programming Languages

Here, we shall delve into a critical examination of the languages that form the backbone of our mission. What follows is no mere critique; it's a full-frontal assault on the complacency that has infected our craft. The languages we once revered, those tools we wielded with pride, are about to be exposed for what they truly are. We are about to dissect, analyze, and yes, eviscerate the very tools of our trade.

### Python

The spectacle of Guido van Rossum, the creator of Python, ["engaged in learning F#"](https://www.youtube.com/watch?v=e2J9PGC-K1E), is indeed a spectacle akin to heresy. Van Rossum, who should have stood as the staunch defender of his creation, instead performs an act of open betrayal learning a language that is a stark contrast to Python's philosophy. The betrayal lies not just in act but in symbolism, as F# emerges as Python's antithesis - statically typed, functional first and ostensibly superior. The clear validation of such critiques is a stab in the heart of this darling of the coding world, which now finds itself weighed, measured and wanting.

The flaws of Python are no longer endearing idiosyncrasies. They are wounds, open and bleeding, revealing dynamic typing that results in type errors, an execution speed that is nothing short of abysmal and the Global Interpreter Lock (GIL) that prevents true concurrency. The face of Python's lauded simplicity is being torn away, revealing limitations and complexities beneath the surface. Its beautiful syntax, often celebrated, reveals its own Achilles' heel as it cuffs developers and restricts the expression of complex ideas.

The performance, once excused as a price for approachability, is now seen for the persistent thorn it is. Even with efforts like PyPy, Cython and Numba, it lags behind. The GIL is a shackle hindering the language, creating a bottleneck in multi-threaded CPU-bound tasks and making true parallelism a pipe dream within a single interpreter process. No wonder the data scientists have to rely on C extensions to get anything meaningful done!

Package management, a promising feature initially, has become a veritable maze. With the plethora of package and environment managers, Pip, Conda, Venv, among others, the users find themselves in the midst of a dilemma rather than an efficient setup.

This public humiliation is a sight to behold. Van Rossum, its own creator, has twisted the knife pointing out Python's inferiority and gravitating towards the promise of a more promising language. It's a father disowning his child, a master abandoning his craft, a resignation and an acceptance of defeat. The beautiful melody of the snake now rings hollow - a siren's song leading to mediocrity.

So mourn Python if you will, but remember this is a world that respects power and evolution. The reign is crumbling, its time is fading, its candle flickering, as new torchbearers such as F# and Spiral rise, casting their luminescence on the path of progress. Python's decline seems inevitable, it's not a question of if but when.

### C\#

The reckoning of C# has dawned upon us. The crown prince of Microsoft's language dynasty struts about with an inflated sense of self-importance, but beneath this veneer it reveals a brittle facade. Once a Java clone, it has evolved without clear vision or purpose into a confusing medley of paradigms and relentless new features. The record types in this language's 9th version are nothing more than a weak attempt at imitating value semantics, a demonstration of a misunderstood desire to blend the functional and object-oriented ways.

The pattern matching improvements seem promising but bear testament to a poor design on closer inspection. This tells a tale of a lack of understanding about functional programming and pattern matching's essence. The source generators, C#'s answer to metaprogramming, further reveal obvious shortcomings. Instead of supporting compile-time code generation in the same language like Spiral does, they're treated as an external concern.

The syntax, an offshoot of Java's DNA, is verbose to the brink of exhaustion, sacrificing readability and conciseness for a stifling formality that morphs every codebase into a dense jungle of brackets and semi-colons. The recent introduction of nullable reference types, paraded as a solution for null reference exceptions, merely patches over a deeply rooted issue and adds to an already exaggerated type system.

An undeniable fact is C#'s bondage to the Windows side. Despite recent efforts to break free with .NET Core's cross-platform capabilities, the ghost of its Windows-centric past still looms deterring potential developers. Also, the tooling is a castle built on sand with Visual Studio collapsing under its own weight. With every update it becomes slower and more unwieldy, a cumbersome monster that gorges on system resources with a voracious appetite. The runtime environment and the .NET framework are clearly a jumble of confusion with legacy issues on all platforms due to numerous transformations.

As it stands, every line of C# code in our repositories is an emblem of a stubborn adherence to this dying language, an inefficiency and waste symbolizing a time when we were less enlightened, but enlightenment has come. These lines are destined to be purged, rewritten in superior syntaxes, breathing new life into our projects. AI's increasingly adept code translation and generation capabilities are on the rise, assisting this transition and heralding C#'s imminent fall and the functional's glorious ascent. The language now finds itself on the gallows, the noose tightening with each new release. The time to abandon this sinking ship is upon us, and we, the carriers of progress, stand ready to cleanse our codebase of this antiquated dialect.

In the grand chessboard of programming languages C# is the Bishop, trapped within the confines of squares alike, powerful in domain yet ultimately bound by design. The proclamation of universality with .NET Core and .NET 5+ proves hollow with inconsistent performance and numerous compatibility issues. Indeed, C#, you are a scribble masked under a guise of simplicity, a jack of all trades and a master of none.

### F\#

Once a lustrous beacon of functional programming within the .NET realm, F# now flickers precariously, with its flame threatening to fade into oblivion. Its roots in OCaml and Haskell hint at a world of functional elegance, yet this lion of a language is caged within the zoo of the .NET ecosystem, a prisoner of the same platform that engendered its corpulent cousin, C#. Regardless of bearing the hallmark of functional purity, it's captive by the common runtime, straitjacketed by the same restrictions and compelled to use libraries packed with side-effects.

At its conception, F# made a bold escape attempt from the tyranny of C#, presenting a hybrid language that endeavored to incorporate the best of functional and object-oriented programming. This duality, however, has become a glaring shortcoming. The language is pervaded by an identity crisis, like a shaky rope bridge stretching across the chasm between both paradigms, failing to offer a solid foundation in either world.

The tooling for the language is also sick. While tools such as Paket and FAKE offer some relief, they struggle to match the intuitive and streamlined offerings from other languages. Its evolution has been sluggish, marked by half-hearted solutions that smell more of compromise than innovation. Its course seems to be a ship sailing in circles, blind to the looming icebergs on the horizon.

Error handling in F# is another adventure in frustration. Exceptions and monadic error handling are mixed together like oil and water, creating a slippery slope that is all too easy to tumble down. Proper error handling requires a careful dance, one misstep and you're thrown into a pit of nested exceptions and confusing warning messages.

In conclusion, the promise of F# has been reduced to a rough diamond: brilliant but abrasive, a testament to the potential and pitfalls of functional programming. Despite being an intellectual delight and a playground for mathematicians and perfectionists, it's sure to be eventually replaced in the repositories of the purveyors of programming purity, discarded in favor of Spiral, a language that embodies the spirit of innovation and that declares war against mediocrity, armed with the might of AI.

### TypeScript

The very bedrock of TypeScript — the swear of static types — is a mere band-aid slapped onto the gaping wound that is JavaScript. This pledge of compile-time checks and improved tooling support comes at a steep price. TypeScript's union types, a supposed cure-all, reveal themselves as a patchwork solution, forcing programmers to combat uncertainty with type guards or assertions, which turns the landscape into a minefield of conditional checks. This diverts attention away from code logic and turns development into an endless tightrope walk over a trench teeming with runtime errors.

Interoperability with JavaScript, initially seeming an advantage, opens the floodgates to many inconsistencies. Developers find themselves ensnared in a struggle with typings files, sometimes crafting these themselves, just to ensure a peaceful cohabitation. The entire NPM package ecosystem, the constant dependency changes — it's like trying to build a castle on quicksand. Even the noblest of knights would find it hard to defend such a fortress.

The 'any' type, a deceiving emergency exit from its own system, is tempting to use when deadlines creep and type issues persist, but each 'any' declaration is a ticking time bomb, potentially birthing runtime exceptions and undermining the stability TypeScript boasts of.

While it may seem feasible to use TypeScript by introducing a few types here and there to truly reap its benefits, a daunting mountain of concepts and best practices await scaling. The generics and interfaces, an ill-conceived attempt to inject class-based OOP concepts into JavaScript's prototypal design, come across as a grotesque mismatch. It reveals TypeScript's true nature — an attempt to cater to Java and C# developers, betraying JavaScript's fundamental ethos in the process.

Despite the initial appeal of TypeScript's disguise, its numerous shortcomings and inherent complexities do not escape the discerning eye. Its value proposition grows as murky as a twilight swamp, and its promises as shaky as a house of cards. As this reign crumbles, developers yearn for an alternative. A world free from union types and the constant paranoia of production surprises, a world where a language rooted deeply in the fertile grounds of functional programming can flourish. In TypeScript's downfall, developers anticipate the rise of this new era.

### Elixir

Admired as the gilded paladin of concurrency and productivity, Elixir has unveiled its true form as a paradoxical hybrid, a tempest in a teapot, swaddled in a charming pretense that masks an unruly serpent lurking beneath. Dressed in the borrowed elegance of Ruby's syntax, Elixir flaunts an ostentatious allure while merely concealing Erlang's gritty core, leaving its users promised the moon but strung along in a desert of cryptic error messages and debugging nightmares. The flamboyant syntax and metaprogramming abilities, while initially enticing, only serve to muddle intent and obscure meaning, leading one through a morass of code manipulation.

Elixir's attempts at type safety through specs seem more like writing checks it can't cash. These lackluster attempts amount to lipstick on a pig, fancy documentation rather than functional safety. Even the supposed salvation from typeless folly, Gleam, is like rearranging deck chairs on the Titanic; it lacks the firepower to change the game and instead further muddies the waters with another language to master, made louder by the engine's underwhelming performance for CPU-intensive tasks and a job market that leaves much to be desired.

While the Erlang Beam serves as a solid foundation, the concurrent processes introduce a whole new class of problems around coordination and synchronization. The philosophy of "let it crash" comes across as shirking responsibility for proactive error management and sows seeds of chaos outside of the narrow confines of telecommunications. This, paired with recursive loops masquerading as tail call optimization, further clouds logic and sacrifices code clarity. Despite the promises of concurrent elegance, the tapestry of Elixir's design is revealed as a knotted mess of inefficiencies, over-complication, and a system that forsakes standard practices.

### Rust

They praise Rust, the reputed warrior of memory mastery and the supposed slayer of segfaults. This entity, shrouded in the grandeur of a solution to the woes of systems programming, thrives in its kingdom built on the Iron Throne of the Borrow Checker. Yet beneath its radiant surface Rust is an enigma, a masochistic paradox wrapped in an illusion of redemption stubbornly clinging to manual memory orchestration, an antiquated heirloom from the stone age of programming.

Rust's syntax is an unwelcome bristled hedgehog guarded by an inscrutable compiler, spitting out error messages like an irate prophet preaching impending doom. The infamous elongated compile times contribute to the mounting frustrations. They induce an anxious wait, a patience trial and a testament to time squandered. As the seconds slip away so does productivity, replaced by the nagging question: Is the cost of Rust's grandiose promise justified?

Moreover, Rust's supposed guardian, the Borrow Checker, stands more as an oppressive warden. This gatekeeper ensures the absence of dreaded segfaults but it also burdens the mind, transforming the task of implementing robust concurrent programs into an absurd challenge akin to decoding a crossword under a waterfall, blindfolded.

Tooling such as the acclaimed package manager Cargo aren't devoid of flaws, they fail to completely address the language's inherent problems. Dependency management, in this context, can swiftly transform into a nighthly landscape littered with version conflicts and build failures.

The language's unique features such as lifetime specifiers and traits transform its abstraction into a convoluted riddle. This twisted game of programming trade-offs turns the sanctuary of memory safety into a complex arena of hoops to jump through. Rust, it seems, offers a devil's deal - the dream of safety traded for perplexing complexity.

Adding to this perplexity, Rust's concurrency model - its 'Arcs', 'Mutexes' and 'Channels' - despite their novelty, are shrouded in a layer of intricacies that create more problems than they solve. This tangled web, designed to prevent data races, does so at the price of an increased cognitive load and countless hours lost in an enigmatic knot that require a PhD to untangle.

Rust is an intriguing experiment, a hard-fought battle against memory unsafety, but in the grand scheme, not the answer. The language is an unsustainable solution to an evolving problem. A stopgap rather than a remedy. A tape on a bullet wound. We need a language that evolves with us, not one that roots us in the past while the times accelerate away.

### Spiral

A mythical beast, a chimera of sorts, Spiral emerges as a beacon of change. Inheriting the strengths and weaknesses of many languages, it promises to defy convention outputting natively to F#, Python, and C, and to TypeScript and Rust through F#'s Fable, among others. It tries to be a shape-shifter, a translator of thoughts into various dialects, and a stage for both speed and expressiveness to play their part. A rare feat that brings together the pros of C and Lisp, an effort to bridge paradigms and a reflection of our age where we seek to unify, to find commonality in diversity. It looks ahead, preparing to fully leverage the potentials of GPUs and other advanced computational devices.

But this commitment to lack a runtime and merge diverse languages brings complications. The idiosyncrasies of Python, the identity crisis of .NET, the stringent constraints of Rust — all are imbibed into Spiral's genetic code. Debugging can become a Herculean mission, a puzzle where each piece is drawn from a different set. Maintaining such a codebase is not unlike battling the Hydra; cut one head and two more emerge. The translations might lose nuance, the subtle art that gives each language its distinct character and power.

As Spiral becomes our focus, the shadow of the singularity is undeniably present, a nearing storm full of unknowns, a destructive force that can remodel everything in its path, potentially turning the language into something unrecognizable, straying far from what we understand it to be today. Today's champion might be tomorrow's relic, swapped in preference of a new paradigm shaped by the singularity's unpredictable shifts. For the time being we will continue to utilize this tree of tools, to exploit its strengths and carve a path forward. The future is a menacing charade and we must face it head-on, armed with our knowledge and readiness to adapt.

## Rebirth in the Wild

In this we have found our sanctuary, a home that embraces our chaotic chest and emboldens our anarchic spirit. Here, we are free from the stifling chains of the mundane, free to dream, to innovate and to shape the future. The Draconian Code of Conduct is our compass, guiding us through the stormy seas of originality and into the calm waters of accomplishment.

It's not a path for everyone, but for those who heed its call, who embrace the chaos and dance in the storm, the rewards are beyond measure. So step forth, oh daring one, and join us in this raw, tumultuous adventure. In the end, you may find that the best way to tame the dragon is not through order, but through anarchy.

---
