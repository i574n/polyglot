#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

# Threading (Polyglot)

#!fsharp

#!import ../../lib/fsharp/Notebooks.dib
#!import ../../lib/fsharp/Testing.dib

#!fsharp

#!import ../../lib/spiral/common.fsx
#!import ../../lib/spiral/sm.fsx
#!import ../../lib/spiral/date_time.fsx
#!import ../../lib/spiral/file_system.fsx
#!import ../../lib/spiral/trace.fsx
#!import ../../lib/spiral/lib.fsx
#!import ../../lib/fsharp/Common.fs

#!fsharp

open Common

#!markdown

## newDisposableToken

#!fsharp

let inline newDisposableToken (mergeToken: System.Threading.CancellationToken option) =
    let cts = new System.Threading.CancellationTokenSource ()
    let cts =
        match mergeToken with
        | None -> cts
        | Some mergeToken ->
            System.Threading.CancellationTokenSource.CreateLinkedTokenSource [| cts.Token; mergeToken |]
    let disposable = new_disposable cts.Cancel
    cts.Token, disposable

#!fsharp

//// test

let mutable counter = 0

let inline run fn =
    let token, disposable = newDisposableToken None
    use _ = disposable
    fn token
    async {
        fn token
    }
    |> Async.Start

let inline fn (token : System.Threading.CancellationToken) =
    counter <- counter + (if token.IsCancellationRequested then 10 else 1)

async {
    run fn
    do! Async.Sleep 10
    return counter
}
|> Async.RunSynchronously
|> _assertEqual 11
