#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[]}}

#!markdown

# Async (Polyglot)

#!fsharp

#!import ../../lib/fsharp/Notebooks.dib
#!import ../../lib/fsharp/Testing.dib

#!fsharp

#!import ../../lib/fsharp/Common.fs

#!fsharp

#if !INTERACTIVE
open Lib
#endif

#!fsharp

open Common

#!markdown

## choice

#!fsharp

let inline choice asyncs = async {
    let e = Event<_> ()
    use cts = new System.Threading.CancellationTokenSource ()
    let fn =
        asyncs
        |> Seq.map (fun a -> async {
            let! x = a
            e.Trigger x
        })
        |> Async.Parallel
        |> Async.Ignore
    Async.Start (fn, cts.Token)
    let! result = Async.AwaitEvent e.Publish
    cts.Cancel ()
    return result
}

#!markdown

## map

#!fsharp

let inline map fn a = async {
    let! x = a
    return fn x
}

#!markdown

## catch

#!fsharp

let inline catch a =
    a
    |> Async.Catch
    |> map (function
        | Choice1Of2 result -> Ok result
        | Choice2Of2 ex -> Error ex
    )

#!markdown

## runWithTimeoutAsync

#!fsharp

let inline runWithTimeoutAsync_ (timeout : int) fn =
    let _locals () = $"timeout: {timeout} / {_locals ()}"

    let timeoutTask = async {
        do! Async.Sleep timeout
        trace Debug (fun () -> "runWithTimeoutAsync") _locals
        return None
    }

    let task = async {
        try
            let! result = fn
            return Some result
        with
        | :? System.AggregateException as ex when
            ex.InnerExceptions
            |> Seq.exists (function :? System.Threading.Tasks.TaskCanceledException -> true | _ -> false)
            ->
            let _locals () = $"ex: {ex |> SpiralSm.format_exception} / {_locals ()}"
            trace Warning (fun () -> "runWithTimeoutAsync") _locals
            return None
        | ex ->
            trace Critical (fun () -> $"runWithTimeoutAsync** / ex: {ex |> SpiralSm.format_exception}") _locals
            return None
    }

    [ timeoutTask; task ]
    |> choice

#!fsharp

let inline runWithTimeout_ timeout fn =
    fn
    |> runWithTimeoutAsync_ timeout
    |> Async.RunSynchronously

#!fsharp

//// test

Async.Sleep 120
|> runWithTimeout_ 10
|> _assertEqual None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeout_ 60
|> _assertEqual (Some ())

#!fsharp

//// test

async {
    raise (exn "error")
}
|> runWithTimeout_ 60
|> _assertEqual None

#!markdown

## runWithTimeoutChildAsync

#!fsharp

let inline runWithTimeoutChildAsync (timeout : int) fn = async {
    let _locals () = $"timeout: {timeout} / {_locals ()}"
    let! child = Async.StartChild (fn, timeout)
    return!
        child
        |> catch
        |> map (function
            | Ok result -> Some result
            | Error (:? System.TimeoutException as ex) ->
                trace Debug (fun () -> $"runWithTimeoutChildAsync") _locals
                None
            | Error ex ->
                trace Critical (fun () -> $"runWithTimeoutChildAsync** / ex: {ex |> SpiralSm.format_exception}") _locals
                None
        )
}

#!fsharp

let inline runWithTimeoutChild timeout fn =
    fn
    |> runWithTimeoutChildAsync timeout
    |> Async.RunSynchronously

#!fsharp

let inline runWithTimeoutAsync timeout fn =
    runWithTimeoutChildAsync timeout fn

let inline runWithTimeout timeout fn =
    runWithTimeoutChild timeout fn

#!fsharp

//// test

Async.Sleep 60
|> runWithTimeoutChild 10
|> _assertEqual None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeoutChild 60
|> _assertEqual (Some ())

#!fsharp

//// test

async {
    raise (exn "error")
}
|> runWithTimeoutChild 60
|> _assertEqual None

#!markdown

## runWithTimeoutStrict

#!fsharp

let inline runWithTimeoutStrict (timeout : int) fn =
    let _locals () = $"timeout: {timeout} / {_locals ()}"

    let timeoutTask = async {
        do! Async.Sleep timeout
        return None, _locals
    }

    let task = async {
        try
            return Async.RunSynchronously (fn, timeout) |> Some, _locals
        with
        | :? System.TimeoutException as ex ->
            let _locals () = $"ex: {ex |> SpiralSm.format_exception} / {_locals ()}"
            return None, _locals
        | ex ->
            trace Critical (fun () -> $"runWithTimeoutStrict / ex: {ex |> SpiralSm.format_exception}") _locals
            return raise ex
    }

    try
        [| timeoutTask; task |]
        |> Array.map Async.StartAsTask
        |> System.Threading.Tasks.Task.WhenAny
        |> fun task ->
            match task.Result.Result with
            | None, _locals ->
                trace Debug (fun () -> "runWithTimeoutStrict") _locals
                None
            | result, _ -> result
    with
    | :? System.AggregateException as ex when
        ex.InnerExceptions
        |> Seq.exists (function :? System.Threading.Tasks.TaskCanceledException -> true | _ -> false)
        ->
        let _locals () = $"ex: {ex |> SpiralSm.format_exception} / {_locals ()}"
        trace Warning (fun () -> "runWithTimeoutStrict") _locals
        None
    | ex ->
        let _locals () = $"ex: {ex |> SpiralSm.format_exception} / {_locals ()}"
        trace Critical (fun () -> "runWithTimeoutStrict**") _locals
        None

#!fsharp

//// test

Async.Sleep 60
|> runWithTimeoutStrict 10
|> _assertEqual None

#!fsharp

//// test

Async.Sleep 10
|> runWithTimeoutStrict 60
|> _assertEqual (Some ())

#!fsharp

//// test

async {
    raise (exn "error")
}
|> runWithTimeoutStrict 60
|> _assertEqual None

#!markdown

## awaitValueTask

#!fsharp

let inline awaitValueTaskUnit (task : System.Threading.Tasks.ValueTask) =
    task.AsTask () |> Async.AwaitTask

let inline awaitValueTask (task : System.Threading.Tasks.ValueTask<_>) =
    task.AsTask () |> Async.AwaitTask

#!markdown

## init

#!fsharp

let inline init x = async {
    return x
}

#!fsharp

//// test

init 1
|> Async.RunSynchronously
|> _assertEqual 1

#!markdown

## withCancellationToken

#!fsharp

let inline withCancellationToken (ct : System.Threading.CancellationToken) fn =
    Async.StartImmediateAsTask (fn, ct)
    |> Async.AwaitTask

#!fsharp

//// test

let cts = new System.Threading.CancellationTokenSource ()

async {
    let run = async {
        do! Async.Sleep 100
        return 1
    }

    let! child =
        run
        |> withCancellationToken cts.Token
        |> catch
        |> Async.StartChild

    do! Async.Sleep 50
    cts.Cancel ()
    return! child
}
|> Async.RunSynchronously
|> Result.mapError _.Message
|> _assertEqual (Error ("A task was canceled."))
