#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!markdown

# math

#!spiral

open testing
open rust_operators

#!spiral

inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"num_complex::Complex<$0>\")>] type num_complex_Complex<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::types::PyModule\")>] type pyo3_types_PyModule = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::Bound<$0>\")>] type pyo3_Bound<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::Python\")>] type pyo3_Python = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::PyAny\")>] type pyo3_PyAny = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::PyErr\")>] type pyo3_PyErr = class end"

#!spiral

inl types () =
    rust.types ()
    sm'.types ()
    types ()

#!markdown

## complex

#!spiral

nominal complex t = $"num_complex_Complex<`t>"
nominal bound t = $"pyo3_Bound<`t>"
nominal python = $"pyo3_Python"
nominal pymodule = $"pyo3_types_PyModule"
nominal pyany = $"pyo3_PyAny"
nominal pyerr = $"pyo3_PyErr"

inl complex forall t. ((re : t), (im : t)) : complex t =
    inl re = join re
    inl re = join re
    inl im = join im
    !\($'"num_complex::Complex::new(!re, !im)"')

#!spiral

// // test
// // rust=

types ()

complex (0f64, 0f64)
|> sm'.format'
|> sm'.from_std_string
|> _assert_eq "0+0i"

#!markdown

## run_test

#!spiral

inl re forall t. (c : complex t) : t =
    inl c = join c
    !\($'"!c.re"')

inl im forall t. (c : complex t) : t =
    inl c = join c
    !\($'"!c.im"')

inl complex_unbox forall t. (c : complex t) =
    re c, im c

inl (~.^) c = complex c

inl complex_eq forall t. (a : complex t) (b : complex t) : bool =
    !\($'"!a == !b"')

inl (.=) a b = complex_eq a b

instance equable complex t = complex_eq

inl complex_add forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a + !b"')

inl (.+) a b = complex_add a b

inl complex_sub forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a - !b"')

inl (.-) a b = complex_sub a b

inl complex_mult forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a * !b"')

inl (.*) a b = complex_mult a b

inl complex_div forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a / !b"')

inl (./) a b = complex_div a b

inl powc forall t. (s : complex t) (c : complex t) : complex t =
    inl c = join c
    inl s = join s
    !\($'"num_complex::Complex::powc(!c, !s)"')

inl (.**) a b = powc b a

inl complex_sin forall t. (c : complex t) : complex t =
    !\($'"!c.sin()"')

inl conj forall t. (c : complex t) : complex t =
    !\($'"!c.conj()"')

#!markdown

## zeta

#!spiral

inl rec zeta (gamma : complex f64 -> complex f64) (s : complex f64) : complex f64 =
    join
        if re s > 1 then
            am.init 10000i32 id
            |> fun x => x : a i32 _
            |> am.fold
                fun acc n =>
                    acc .+ .^(1, 0) ./ (.^(f64 n, 0) .** s)
                .^(0, 0)
        elif s = .^(-1, 0) then
            .^(-1 / 12, 0)
        else
            inl one_minus_s = .^(1 - re s, -(im s))
            inl mirror_term =
                if re one_minus_s > 1
                then zeta gamma one_minus_s
                else .^(0, 0)
            inl gamma_term = gamma (.^(1, 0) .- s)
            inl sin_term = .^(pi, 0) .* s ./ .^(2, 0) |> complex_sin
            inl reflection_formula =
                .^(2, 0) .* (.^(pi, 0) .** s) .* sin_term .* gamma_term .* mirror_term
            reflection_formula

inl zeta (gamma : complex f64 -> complex f64) (s : complex f64) : complex f64 =
    .^(0, 0)

#!markdown

## eval

#!spiral

inl module_from_code (py : python) (code : string) : resultm.result' (bound pymodule) pyerr =
    inl py = join py
    inl code = code |> sm'.as_str
    !\($'"pyo3::types::PyModule::from_code_bound(!py, !code, \\"\\", \\"\\")"')

inl use_pyanymethods () =
    global "Fable.Core.RustInterop.emitRustExpr () \");\nuse pyo3::prelude::PyAnyMethods;\n//\""

inl getattr (attr : string) (module : bound pymodule) : resultm.result' (bound pyany) pyerr =
    inl attr = attr |> sm'.as_str
    inl module = join module
    use_pyanymethods ()
    !\($'"!module.getattr(!attr)"')

inl call forall t. (args : t) (module : bound pyany) : resultm.result' (bound pyany) pyerr =
    inl args = join args
    inl module = join module
    !\($'"pyo3::prelude::PyAnyMethods::call(&!module, ((*!args).0, *(*!args).1), None)"')

inl extract forall t. (result : bound pyany) : resultm.result' t pyerr =
    inl result = join result
    use_pyanymethods ()
    !\($'"!result.extract()"')

inl eval py code args =
    inl code =
        code
        |> module_from_code py
        |> resultm.unwrap'
    inl fn =
        code
        |> getattr "fn"
        |> fun x => x : _ _ pyerr
        |> resultm.unwrap'

    fn
    |> call args
    |> resultm.unwrap'
    |> extract
    |> fun x => x : _ _ pyerr
    |> resultm.unwrap'
    |> complex
    |> Ok
    |> fun x => x : _ _ pyerr
    |> resultm.box

inl call1_ log py s code =
    inl code = join (a code : _ i32 _) |> sm'.concat_array_trailing "\n"
    
    inl s = new_pair (re s) (im s)
    inl args = new_pair log s

    eval py code args

inl gamma_ log py s =
    ;[
        "import mpmath"
        "def fn(log, s):"
        "    if log:"
        "        print(f'gamma_ / s: {s}', flush=True)"
        "    s = complex(*s)"
        "    s = mpmath.gamma(s)"
        "    return (s.real, s.imag)"
    ]
    |> call1_ log py s

inl zeta_ log py s =
    ;[
        "import mpmath"
        "def fn(log, s):"
        "    if log:"
        "        print(f'zeta_ / s: {s}', flush=True)"
        "    s = complex(*s)"
        "    try:"
        "        s = mpmath.zeta(s)"
        "    except ValueError as e:"
        "        if s.real == 1:"
        "            s = complex(float('inf'), 0)"
        "    return (s.real, s.imag)"
    ]
    |> call1_ log py s

#!markdown

## run_test

#!spiral

inl run_test log closure_fix (fn : (complex f64 -> complex f64) * (complex f64 -> complex f64) -> ()) =
    inl fn_ (py : python) : resultm.result' () pyerr =
        inl gamma__ = fun (s : complex f64) =>
            inl result = gamma_ log py s |> resultm.unwrap'
            if log then
                !\($'"println\!(\\\"gamma__ / s: {:?} / result: {:?}\\\", !s, !result)"')
                !\($'"}} // gamma__[0]"')
            result
        inl zeta__ = fun (s : complex f64) =>
            inl result = zeta_ log py s |> resultm.unwrap'

            inl z = zeta gamma__ s

            if log then
                !\($'"println\!(\\\"zeta__ / s: {:?} / result: {:?} / z: {:?}\\\", !s, !result, !z)"')
                !\($'"}} // zeta__[0]"')

    //             re result - re x |> abs
    //             |> _assert_lt 0.001
    //             
    //             im result - im x |> abs
    //             |> _assert_lt 0.001

            result
        join fn (zeta__, gamma__)

        Ok ()
        |> resultm.box
    
    join
        !\($'"pyo3::prepare_freethreaded_python()"') : ()

        !\($'"let __result = pyo3::Python::with_gil(|py| -> pyo3::PyResult<()> { //"')

        let x' = fn_ (!\($'"py"') : python)
        inl x' = join x'
        
        inl closure_fix = 2u8, 1u8
        x' |> rust.fix_closure closure_fix

        (!\($'"__result"') : _ () pyerr)
        |> resultm.unwrap'

#!markdown

## test_zeta_at_known_values_

#!spiral

inl test_zeta_at_known_values_ log = run_test log (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(2, 0), pi ** 2 / 6
        .^(-1, 0), -1 / 12
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun s, e =>
        inl result = zeta s

        result |> im |> _assert_eq 0
        re result - e |> abs |> _assert_lt 0.0001

#!spiral

// // test
// // rust=
// // print_code=false


types ()
test_zeta_at_known_values_ true

#!markdown

## test_zeta_at_2_minus2

#!spiral

inl test_zeta_at_2_minus2 log = run_test log (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(2, -2)
    inl result = zeta s

    (re result - 0.8673) |> abs |> _assert_lt 0.001
    (im result - 0.2750) |> abs |> _assert_lt 0.001

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_zeta_at_2_minus2 true

#!markdown

## test_trivial_zero_at_negative_even___

#!spiral

inl test_trivial_zero_at_negative_even___ log = run_test log (2u8, 1u8) fun zeta, gamma =>
    (join listm'.init_series -2f64 -40 -2)
    |> listm.iter fun n =>
        inl s = .^(n, 0)
        inl result = zeta s

        result |> re |> _assert_eq 0
        result |> im |> _assert_eq 0

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_trivial_zero_at_negative_even___ true

#!markdown

## test_non_trivial_zero___

#!spiral

inl test_non_trivial_zero___ log = run_test log (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(0.5, 14.134725)
        .^(0.5, 21.022040)
        .^(0.5, 25.010857)
        .^(0.5, 30.424876)
        .^(0.5, 32.935062)
        .^(0.5, 37.586178)
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun x =>
            inl result = zeta x
            result |> re |> abs |> _assert_lt 0.0001
            result |> im |> abs |> _assert_lt 0.0001

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_non_trivial_zero___ true

#!markdown

## test_real_part_greater_than_one___

#!spiral

inl test_real_part_greater_than_one___ log = run_test log (3u8, 2u8) fun zeta, gamma =>
    inl points = ;[2; 3; 4; 5; 10; 20; 50]
    (a points : _ i32 _)
    |> am.iter fun point =>
        inl s = .^(point, 0)
        inl result = zeta s
        result |> re |> _assert_gt 0
        result |> im |> _assert_eq 0

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_real_part_greater_than_one___ true

#!markdown

## test_zeta_at_1___

#!spiral

inl test_zeta_at_1___ log = run_test log (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(1, 0)
    inl result = zeta s
    result |> re |> _assert_eq limit.max
    result |> im |> _assert_eq 0

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_zeta_at_1___ true

#!markdown

## test_symmetry_across_real_axis___

#!spiral

inl test_symmetry_across_real_axis___ log = run_test log (8u8, 7u8) fun zeta, gamma =>
    inl s = .^(2, 10)
    inl result_positive_im = zeta s
    inl result_negative_im = zeta .^(re s, -(im s))
    inl conj = result_negative_im |> conj
    result_positive_im |> re |> _assert_eq (conj |> re)
    result_positive_im |> im |> _assert_eq (conj |> im)

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_symmetry_across_real_axis___ true

#!markdown

## test_behavior_near_origin___

#!spiral

inl test_behavior_near_origin___ log = run_test log (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(0.01, 0.01)
    inl result = zeta s
    result |> re |> _assert_lt limit.max
    result |> im |> _assert_lt limit.max

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_behavior_near_origin___ true

#!markdown

## test_zeta_at_minus_1

#!spiral

inl test_zeta_at_minus_1 log = run_test log (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(-1, 0)
    inl result = zeta s
    re result + 1 / 12 |> abs |> _assert_lt 0.0001
    result |> im |> _assert_eq 0

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_zeta_at_minus_1 true

#!markdown

## test_imaginary_axis

#!spiral

inl test_imaginary_axis log = run_test log (3u8, 2u8) fun zeta, gamma =>
    (join a ;[10; 20; 30; 40; 50; 60; 70; 80; 90; 100] : _ i32 _)
    |> am.iter fun s =>
        inl s = .^(0, s)
        inl result = zeta s
        result |> re |> _assert_ne 0
        result |> im |> _assert_ne 0

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_imaginary_axis true

#!markdown

## test_critical_strip

#!spiral

inl test_critical_strip log = run_test log (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(0.5, 14.134725)
        .^(0.75, 20.5)
        .^(1.25, 30.1)
        .^(0.25, 40.0)
        .^(1.0, 50.0)
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun s =>
        inl result = zeta s
        result |> re |> _assert_ne 0
        result |> im |> _assert_ne 0

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_critical_strip true

#!markdown

## test_reflection_formula_for_specific_value

#!spiral

inl test_reflection_formula_for_specific_value log = run_test log (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(3, 4)
        .^(2.5, -3.5)
        .^(1.5, 2.5)
        .^(0.5, 14.134725)
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun s =>
        inl lhs = zeta s
        inl reflection_coefficient =
            (.^(2, 0) .** s)
            .* (.^(pi, 0) .** (s .- .^(1, 0)))
            .* (.^(pi, 0) .* s ./ .^(2, 0) |> complex_sin)
            .* gamma (.^(1, 0) .- s)

        inl one_minus_s = .^(1 - re s, -(im s))
        inl rhs = reflection_coefficient .* zeta one_minus_s

        re lhs - re rhs |> abs |> _assert_lt 0.0001
        im lhs - im rhs |> abs |> _assert_lt 0.0001

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_reflection_formula_for_specific_value true

#!markdown

## test_euler_product_formula

#!spiral

inl test_euler_product_formula log = run_test log (3u8, 2u8) fun zeta, gamma =>
    inl s_values = ;[2; 2.5; 3; 3.5; 4; 4.5; 5]
    inl primes = ;[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71]
    (a s_values : _ i32 _)
    |> am.iter fun s_re =>
        inl s = .^(s_re, 0)
        inl product =
            (1, (a primes : _ i32 _))
            ||> am.fold fun acc x =>
                acc * 1 / (1 - x ** -s_re)

        inl result = zeta s
        re result - product |> abs |> _assert_lt 0.01
        result |> im |> _assert_lt 0.01

#!spiral

// // test
// // rust=
// // print_code=false

types ()
test_euler_product_formula true

#!markdown

## tests

#!spiral

inl tests () =
    !\($'"}//"') : ()

    !\($'"#[test] fn test_zeta_at_known_values_() { //"') : ()
    test_zeta_at_known_values_ false
    !\($'"} #[test] fn test_zeta_at_2_minus2() { //"') : ()
    test_zeta_at_2_minus2 false
    !\($'"} #[test] fn test_trivial_zero_at_negative_even___() { //"') : ()
    test_trivial_zero_at_negative_even___ false
    !\($'"} #[test] fn test_non_trivial_zero___() { //"') : ()
    test_non_trivial_zero___ false
    !\($'"} #[test] fn test_real_part_greater_than_one___() { //"') : ()
    test_real_part_greater_than_one___ false
    !\($'"} #[test] fn test_zeta_at_1___() { //"') : ()
    test_zeta_at_1___ false
    !\($'"} #[test] fn test_symmetry_across_real_axis___() { //"') : ()
    test_symmetry_across_real_axis___ false
    !\($'"} #[test] fn test_behavior_near_origin___() { //"') : ()
    test_behavior_near_origin___ false
    !\($'"} #[test] fn test_zeta_at_minus_1() { //"') : ()
    test_zeta_at_minus_1 false
    !\($'"} #[test] fn test_imaginary_axis() { //"') : ()
    test_imaginary_axis false
    !\($'"} #[test] fn test_critical_strip() { //"') : ()
    test_critical_strip false
    !\($'"} #[test] fn test_reflection_formula_for_specific_value() { //"') : ()
    test_reflection_formula_for_specific_value false
    !\($'"} #[test] fn test_euler_product_formula() { //"') : ()
    test_euler_product_formula false

#!spiral

// // rust=

inl main (_args : array_base string) =
    inl value = 1i32
    console.write_line ($"$\"value: {!value}\"" : string)
    0i32

inl main () =
    types ()
    $"let tests () = !tests ()" : ()
    $"let main args = !main args" : ()
