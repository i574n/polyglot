// // # math

open testing
open rust_operators

inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"num_complex::Complex<$0>\")>] type num_complex_Complex<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::types::PyModule\")>] type pyo3_types_PyModule = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::Bound<$0>\")>] type pyo3_Bound<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::Python\")>] type pyo3_Python = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::PyAny\")>] type pyo3_PyAny = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"pyo3::PyErr\")>] type pyo3_PyErr = class end"

inl types () =
    rust.types ()
    sm'.types ()
    types ()

// // ## complex

nominal complex t = $"num_complex_Complex<`t>"
nominal bound t = $"pyo3_Bound<`t>"
nominal python = $"pyo3_Python"
nominal pymodule = $"pyo3_types_PyModule"
nominal pyany = $"pyo3_PyAny"
nominal pyerr = $"pyo3_PyErr"

inl complex forall t. ((re : t), (im : t)) : complex t =
    inl re = join re
    inl im = join im
    !\($'"num_complex::Complex::new(!re, !im)"')

// // ## run_test

inl re forall t. (c : complex t) : t =
    inl c = join c
    !\($'"!c.re"')

inl im forall t. (c : complex t) : t =
    inl c = join c
    !\($'"!c.im"')

inl complex_unbox forall t. (c : complex t) =
    c |> re, c |> im

inl (~.^) c = complex c

inl complex_eq forall t. (a : complex t) (b : complex t) : bool =
    !\($'"!a == !b"')

inl (.=) a b = complex_eq a b

instance equable complex t = complex_eq

inl complex_add forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a + !b"')

inl (.+) a b = complex_add a b

inl complex_sub forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a - !b"')

inl (.-) a b = complex_sub a b

inl complex_mult forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a * !b"')

inl (.*) a b = complex_mult a b

inl complex_div forall t. (a : complex t) (b : complex t) : complex t =
    !\($'"!a / !b"')

inl (./) a b = complex_div a b

inl powc forall t. (s : complex t) (c : complex t) : complex t =
    inl c = join c
    inl s = join s
    !\($'"num_complex::Complex::powc(!c, !s)"')

inl (.**) a b = powc b a

inl complex_sin forall t. (c : complex t) : complex t =
    !\($'"!c.sin()"')

inl conj forall t. (c : complex t) : complex t =
    !\($'"!c.conj()"')

// // ## eval

inl module_from_code (py : python) (code : string) : resultm.result' (bound pymodule) pyerr =
    inl py = join py
    inl code = code |> sm'.as_str
    !\($'"pyo3::types::PyModule::from_code_bound(!py, !code, \\"\\", \\"\\")"')

inl use_pyanymethods () =
    global "Fable.Core.RustInterop.emitRustExpr () \");\nuse pyo3::prelude::PyAnyMethods;\n//\""

inl getattr (attr : string) (module : bound pymodule) : resultm.result' (bound pyany) pyerr =
    inl attr = attr |> sm'.as_str
    inl module = join module
    use_pyanymethods ()
    !\($'"!module.getattr(!attr)"')

inl call forall t. (args : t) (module : bound pyany) : resultm.result' (bound pyany) pyerr =
    inl args = join args
    inl module = join module
    !\($'"pyo3::prelude::PyAnyMethods::call(&!module, (*(*!args).0, ()), None)"')

inl extract forall t. (result : bound pyany) : resultm.result' t pyerr =
    inl result = join result
    use_pyanymethods ()
    !\($'"!result.extract()"')

inl eval py code args =
    inl code =
        code
        |> module_from_code py
        |> resultm.unwrap'
    inl fn =
        code
        |> getattr "fn"
        |> fun x => x : _ _ pyerr
        |> resultm.unwrap'

    fn
    |> call args
    |> resultm.unwrap'
    |> extract
    |> fun x => x : _ _ pyerr
    |> resultm.unwrap'
    |> complex
    |> Ok
    |> fun x => x : _ _ pyerr
    |> resultm.box

inl gamma_ py s =
    inl code =
        ;[
            "import mpmath"
            "def fn(s, _):"
            "    s = complex(*s)"
            "    s = mpmath.gamma(s)"
            "    return (s.real, s.imag)"
        ]
    inl code = (a code : _ i32 _) |> sm'.concat_array_trailing "\n"

    inl s = new_pair (s |> re) (s |> im)
    inl args = new_pair s ()

    eval py code args

inl zeta_ py s =
    inl code =
        ;[
            "import mpmath"
            "def fn(s, _):"
            "    s = complex(*s)"
            "    try:"
            "        s = mpmath.zeta(s)"
            "    except ValueError as e:"
            "        if s.real == 1:"
            "            s = complex(float('inf'), 0)"
            "    return (s.real, s.imag)"
        ]
    inl code = (a code : _ i32 _) |> sm'.concat_array_trailing "\n"
    
    inl s = new_pair (s |> re) (s |> im)
    inl args = new_pair s ()

    eval py code args

// // ## zeta

inl rec zeta (gamma : complex f64 -> complex f64) (s : complex f64) : complex f64 =
    join
        if re s > 1 then
            am.init 10000i32 id
            |> fun x => x : a i32 _
            |> am.fold
                fun acc n =>
                    acc .+ .^(1, 0) ./ (.^(f64 n, 0) .** s)
                .^(0, 0)
        elif s = .^(-1, 0) then
            .^(-1 / 12, 0)
        else
            inl one_minus_s = .^(1 - re s, -(im s))
            inl mirror_term =
                if re one_minus_s > 1
                then zeta gamma one_minus_s
                else .^(0, 0)
            inl gamma_term = gamma (.^(1, 0) .- s)
            inl sin_term = .^(pi, 0) .* s ./ .^(2, 0) |> complex_sin
            inl reflection_formula =
                .^(2, 0) .* (.^(pi, 0) .** s) .* sin_term .* gamma_term .* mirror_term
            reflection_formula

inl zeta (gamma : complex f64 -> complex f64) (s : complex f64) : complex f64 =
    .^(0, 0)

// // ## run_test

inl run_test closure_fix (fn : (complex f64 -> complex f64) * (complex f64 -> complex f64) -> ()) =
    inl fn_ (py : python) : resultm.result' () pyerr =
        inl gamma__ = fun (s : complex f64) =>
            inl s = gamma_ py s |> resultm.unwrap'
            s
        inl zeta__ = fun (s : complex f64) =>
            inl result = zeta_ py s |> resultm.unwrap'

            inl z = zeta gamma__ s

            !\($'"println\!(\\\"zeta / s: {:?} / result: {:?} / z: {:?}\\\", !s, !result, !z)"')

    //             re result - re x |> abs
    //             |> _assert_lt 0.001
    //             
    //             im result - im x |> abs
    //             |> _assert_lt 0.001

            result
        fn (zeta__, gamma__)
        
        Ok ()
        |> resultm.box
    
    join
        !\($'"pyo3::prepare_freethreaded_python()"') : ()

        !\($'"let __result = pyo3::Python::with_gil(|py| -> pyo3::PyResult<()> { //"')

        inl x = fn_
        let x' = x (!\($'"py"') : python)
        inl x' = join x'
        
        x' |> rust.fix_closure closure_fix

        (!\($'"__result"') : _ () pyerr)
        |> resultm.unwrap'

// // ## test_zeta_at_known_values_

inl test_zeta_at_known_values_ () = run_test (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(2, 0), pi ** 2 / 6
        .^(-1, 0), -1 / 12
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun s, e =>
        inl result = zeta s

        result |> im |> _assert_eq 0
        re result - e |> abs |> _assert_lt 0.0001

// // ## test_zeta_at_2_minus2

inl test_zeta_at_2_minus2 () = run_test (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(2, -2)
    inl result = zeta s

    (re result - 0.8673) |> abs |> _assert_lt 0.001
    (im result - 0.2750) |> abs |> _assert_lt 0.001

// // ## test_trivial_zero_at_negative_even___

inl test_trivial_zero_at_negative_even___ () = run_test (2u8, 1u8) fun zeta, gamma =>
    (join listm'.init_series -2f64 -40 -2)
    |> listm.iter fun n =>
        inl s = .^(n, 0)
        inl result = zeta s

        result |> re |> _assert_eq 0
        result |> im |> _assert_eq 0

// // ## test_non_trivial_zero___

inl test_non_trivial_zero___ () = run_test (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(0.5, 14.134725)
        .^(0.5, 21.022040)
        .^(0.5, 25.010857)
        .^(0.5, 30.424876)
        .^(0.5, 32.935062)
        .^(0.5, 37.586178)
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun x =>
            inl result = zeta x
            result |> re |> abs |> _assert_lt 0.0001
            result |> im |> abs |> _assert_lt 0.0001

// // ## test_real_part_greater_than_one___

inl test_real_part_greater_than_one___ () = run_test (3u8, 2u8) fun zeta, gamma =>
    inl points = ;[2; 3; 4; 5; 10; 20; 50]
    (a points : _ i32 _)
    |> am.iter fun point =>
        inl s = .^(point, 0)
        inl result = zeta s
        result |> re |> _assert_gt 0
        result |> im |> _assert_eq 0

// // ## test_zeta_at_1___

inl test_zeta_at_1___ () = run_test (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(1, 0)
    inl result = zeta s
    result |> re |> _assert_eq limit.max
    result |> im |> _assert_eq 0

// // ## test_symmetry_across_real_axis___

inl test_symmetry_across_real_axis___ () = run_test (8u8, 7u8) fun zeta, gamma =>
    inl s = .^(2, 10)
    inl result_positive_im = zeta s
    inl result_negative_im = zeta .^(re s, -(im s))
    inl conj = result_negative_im |> conj
    result_positive_im |> re |> _assert_eq (conj |> re)
    result_positive_im |> im |> _assert_eq (conj |> im)

// // ## test_behavior_near_origin___

inl test_behavior_near_origin___ () = run_test (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(0.01, 0.01)
    inl result = zeta s
    result |> re |> _assert_lt limit.max
    result |> im |> _assert_lt limit.max

// // ## test_zeta_at_minus_1

inl test_zeta_at_minus_1 () = run_test (6u8, 5u8) fun zeta, gamma =>
    inl s = .^(-1, 0)
    inl result = zeta s
    re result + 1 / 12 |> abs |> _assert_lt 0.0001
    result |> im |> _assert_eq 0

// // ## test_imaginary_axis

inl test_imaginary_axis () = run_test (3u8, 2u8) fun zeta, gamma =>
    (join a ;[10; 20; 30; 40; 50; 60; 70; 80; 90; 100] : _ i32 _)
    |> am.iter fun s =>
        inl s = .^(0, s)
        inl result = zeta s
        result |> re |> _assert_ne 0
        result |> im |> _assert_ne 0

// // ## test_critical_strip

inl test_critical_strip () = run_test (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(0.5, 14.134725)
        .^(0.75, 20.5)
        .^(1.25, 30.1)
        .^(0.25, 40.0)
        .^(1.0, 50.0)
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun s =>
        inl result = zeta s
        result |> re |> _assert_ne 0
        result |> im |> _assert_ne 0

// // ## test_reflection_formula_for_specific_value

inl test_reflection_formula_for_specific_value () = run_test (3u8, 2u8) fun zeta, gamma =>
    ;[
        .^(3, 4)
        .^(2.5, -3.5)
        .^(1.5, 2.5)
        .^(0.5, 14.134725)
    ]
    |> fun x => a x : _ i32 _
    |> am.iter fun s =>
        inl lhs = zeta s
        inl reflection_coefficient =
            (.^(2, 0) .** s)
            .* (.^(pi, 0) .** (s .- .^(1, 0)))
            .* (.^(pi, 0) .* s ./ .^(2, 0) |> complex_sin)
            .* gamma (.^(1, 0) .- s)

        inl one_minus_s = .^(1 - re s, -(im s))
        inl rhs = reflection_coefficient .* zeta one_minus_s

        re lhs - re rhs |> abs |> _assert_lt 0.0001
        im lhs - im rhs |> abs |> _assert_lt 0.0001

// // ## test_euler_product_formula

inl test_euler_product_formula () = run_test (3u8, 2u8) fun zeta, gamma =>
    inl s_values = ;[2; 2.5; 3; 3.5; 4; 4.5; 5]
    inl primes = ;[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71]
    (a s_values : _ i32 _)
    |> am.iter fun s_re =>
        inl s = .^(s_re, 0)
        inl product =
            (1, (a primes : _ i32 _))
            ||> am.fold fun acc x =>
                acc * 1 / (1 - x ** -s_re)

        inl result = zeta s
        re result - product |> abs |> _assert_lt 0.01
        result |> im |> _assert_lt 0.01

// // ## tests

inl tests () =
    !\($'"}//"') : ()

    !\($'"#[test] fn test_zeta_at_known_values_() { //"') : ()
    test_zeta_at_known_values_ ()
    !\($'"} #[test] fn test_zeta_at_2_minus2() { //"') : ()
    test_zeta_at_2_minus2 ()
    !\($'"} #[test] fn test_trivial_zero_at_negative_even___() { //"') : ()
    test_trivial_zero_at_negative_even___ ()
    !\($'"} #[test] fn test_non_trivial_zero___() { //"') : ()
    test_non_trivial_zero___ ()
    !\($'"} #[test] fn test_real_part_greater_than_one___() { //"') : ()
    test_real_part_greater_than_one___ ()
    !\($'"} #[test] fn test_zeta_at_1___() { //"') : ()
    test_zeta_at_1___ ()
    !\($'"} #[test] fn test_symmetry_across_real_axis___() { //"') : ()
    test_symmetry_across_real_axis___ ()
    !\($'"} #[test] fn test_behavior_near_origin___() { //"') : ()
    test_behavior_near_origin___ ()
    !\($'"} #[test] fn test_zeta_at_minus_1() { //"') : ()
    test_zeta_at_minus_1 ()
    !\($'"} #[test] fn test_imaginary_axis() { //"') : ()
    test_imaginary_axis ()
    !\($'"} #[test] fn test_critical_strip() { //"') : ()
    test_critical_strip ()
    !\($'"} #[test] fn test_reflection_formula_for_specific_value() { //"') : ()
    test_reflection_formula_for_specific_value ()
    !\($'"} #[test] fn test_euler_product_formula() { //"') : ()
    test_euler_product_formula ()

// // rust=

inl main (_args : array_base string) =
    inl value = 1i32
    console.write_line ($"$\"value: {!value}\"" : string)
    0i32

inl main () =
    types ()
    $"let tests () = !tests ()" : ()
    $"let main args = !main args" : ()
