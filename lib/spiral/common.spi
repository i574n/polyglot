// // # common

inl array x = x

// // ## prototype

prototype (~:>) r : forall t. t -> r
prototype append t : t -> t -> t
prototype of_string t : string -> t
prototype to_string t : t -> string

// // ## run_target

// // ## emit

inl emit forall t. (x : t) : t =
    $'!x '

// // ## upcast

inl upcast forall t u. (x : t) : u =
    $'!x :> `u '

// // ## downcast

inl downcast forall t u. (x : t) : u =
    $'!x :?> `u '

// // ## null

inl null forall t. () : t =
    $"null |> unbox<`t>"

// // ## unativeint

nominal unativeint = $"unativeint"

inl unativeint forall t {int}. (n : t) : unativeint =
    $"unativeint !n"

// // ## i32

inl i32 forall t. (x : t) : i32 =
    $"int32 !x"

// // ## i64

inl i64 forall t. (x : t) : i64 =
    $"int64 !x"

// // ## f32

inl f32 forall t. (x : t) : f32 =
    $"float32 !x"

// // ## f64

inl f64 forall t. (x : t) : f64 =
    $"float !x"

// // ## pair

type pair a b = $"(`a * `b)"

inl pair x y =
    x, y

// // ## new_pair

inl new_pair forall a b. (a : a) (b : b) : pair a b =
    $"!a, !b"

// // ## from_pair

inl from_pair forall a b. (pair : pair a b) : a * b =
    $"let (a, b) = !pair"
    $"a", $"b"

// // ## memoize

nominal lazy t = $'Lazy<`t>'

inl memoize forall t. (fn : () -> t) : () -> t =
    inl result : lazy t = $'lazy !fn ()'
    fun () => $'!result.Value'

// // ## trace_level

union trace_level =
    | Verbose
    | Debug
    | Info
    | Warning
    | Critical

instance to_string trace_level = function
    | Verbose => "Verbose"
    | Debug => "Debug"
    | Info => "Info"
    | Warning => "Warning"
    | Critical => "Critical"

instance of_string trace_level = function
    | "Verbose" => Verbose
    | "Debug" => Debug
    | "Info" => Info
    | "Warning" => Warning
    | "Critical" => Critical

// // ## get_locals

inl get_locals () = ""

// // ## trace_state

inl trace_state () =
    inl result =
        fun () =>
            {
                enabled = mut true
                count = mut 0i64
                level = mut Debug
                dump = mut false
            }
        |> memoize
    result ()

// // ## test_trace_level

inl test_trace_level level =
    inl state = trace_state ()
    inl level' = *state.level
    *state.enabled && $'!level >= !level' '

// let private replStart =
// #if INTERACTIVE || !FABLE_COMPILER
//     fun () ->
//         if System.Reflection.Assembly.GetEntryAssembly().GetName().Name <> "Microsoft.DotNet.Interactive.App"
//         then Some System.DateTime.Now.Ticks
//         else None
//     |> memoize
// #else
//     fun () -> None : int64 option
// #endif
// 
// inl repl_start () =
//     run_target function
//         | Fsharp (Native) => fun () =>
//             get_temp_path ()
//             </> ($'$"\!{!get_entry_assembly_name ()}"' : string)
//             </> (date_time.now () |> date_time.new_guid_from_date_time |> sm'.obj_to_string)
//         | target => fun () => null ()
// 
//     inl result : optionm'.option' t = $'None'
//     $"let mutable _!result = !result"
//     $"#if INTERACTIVE || !FABLE_COMPILER"
//         fun () =>
//             if get_entry_assembly_name () <> "Microsoft.DotNet.Interactive.App"
//             then date_time.now () |> date_time.ticks
//         |> memoize
//     $"#else"
//         fun () => None : option i64
//     $"#endif"
//     fn (Fsharp Wasm) () |> fun x => $"!x"
//     $"#endif"
//     $"|> fun x -> _!result <- Some x"
//     $"_!result |> Option.get"

inl xx () =
    ()

inl trace trace_level fn get_locals =
    inl text = fn ()
    console.write_line ($'$"{!text} / {!get_locals ()}"' : string)

// // ## any

nominal any = $"obj"

// // ## to_any

inl to_any forall t. (obj : t) : any =
    $"!obj"

instance (~:>) any = to_any

// // ## (/@)

inl (/@) a b =
    b |> append a

// // ## unbox

inl unbox forall t u. (x : t) : u =
    $"!x |> unbox<`u>"

// // ## (+.)

inl (+.) forall t. (a : t) (b : t) : t =
    $"!a + !b"

// // ## (-.)

inl (-.) forall t. (a : t) (b : t) : t =
    $"!a - !b"

// // ## (*.)

inl (*.) forall t. (a : t) (b : t) : t =
    $"!a * !b"

// // ## (/.)

inl (/.) forall t. (a : t) (b : t) : t =
    $"!a / !b"

// // ## (=.)

inl (=.) forall t. (a : t) (b : t) : bool =
    $"!a = !b"

// // ## (||>)

inl (||>) (arg1, arg2) fn =
    arg2 |> fn arg1

// // ## flip

inl flip fn a b =
    fn b a

// // ## join_body

inl join_body body acc x =
    if var_is x |> not
    then body acc x
    else
        inl acc = dyn acc
        join body acc x

// // ## join_body_unit

inl join_body_unit body d x =
    if var_is d |> not
    then body x
    else
        inl x = dyn x
        join body x

// // ## nameof

inl nameof x : string =
    $"nameof !x"

// // ## get_environment_variable

inl get_environment_variable (var : string) : string =
    $"System.Environment.GetEnvironmentVariable !var"

// // ## disposable

nominal disposable t = $"System.IDisposable"

// // ## use

inl use forall t. (x : t) : t =
    $"use !x = !x " : ()
    $'!x '

// // ## dispose

inl dispose (disposable : disposable _) : () =
    disposable |> $'_.Dispose()'

// // ## new_disposable

inl new_disposable (fn : () -> ()) : disposable _ =
    run_target function
        | Fsharp _ => fun () => $'{ new System.IDisposable with member _.Dispose () = !fn () }'
        // | Rust _ =>
        //     fun () =>
                // $'{ new System.IDisposable with member _.Dispose () = Fable.Core.RustInterop.emitRustExpr () "!fn()" }'
        | _ => fun () => null ()

// // ## exn

nominal exn = $"exn"

// // ## try

inl try forall t. (fn : () -> t) (ex_fn : exn -> option t) : option t =
    inl none = None : option t
    inl some (s : t) = Some s
    $'try !fn () |> !some with ex -> !ex_fn ex '

// // ## try_unit

inl try_unit forall t. (fn : () -> ()) (ex_fn : exn -> ()) : t =
    $"try"
    fn ()
    |> ignore
    $"with ex ->"
    ex_fn $'ex'
    |> ignore
    $'(*'
    $'*)'

// // ## return

inl return forall t. (x : t) : () =
    $'return !x '

inl return' forall t. (x : t) : t =
    $'return !x '

// // ## sleep

inl sleep (n : i32) : () =
    run_target function
        | Fsharp (Native) => fun () => $'System.Threading.Thread.Sleep' n
        | _ => fun () => ()

// // ## retry_fn

inl retry_fn forall t. retries (fn : () -> t) : option t =
    let rec loop retry =
        try
            fun () =>
                if retry < retries
                then fn () |> Some
                else None
            fun ex =>
                inl get_locals () = $'$"retry: {!retry} / ex: {ex |> SpiralSm.format_exception} / {!get_locals ()}"' : string
                // trace Warning (fun () => "retry_fn") getLocals
                sleep 1
                None
        |> function
            | Some x => x
            | None => loop (retry + 1)
    loop 0

// // ## main

inl main () =
    inl new_disposable x : _ () = new_disposable x
    $"let new_disposable x = !new_disposable x" : ()
    
    inl retry_fn (r : i32) (x : () -> _) : optionm'.option' () = retry_fn r x |> optionm'.box
    $"let retry_fn x = !retry_fn x" : ()
