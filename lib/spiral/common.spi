/// # common

/// ## types
inl types () =
    env.types ()
    rust.types ()
    sm'.types ()

/// ## prototype
prototype (~:>) r : forall t. t -> r

/// ## run_target

/// ## upcast
inl upcast forall t u. (x : t) : u =
    $'!x :> `u '

/// ## downcast
inl downcast forall t u. (x : t) : u =
    $'!x :?> `u '

/// ## memoize
nominal lazy t = $'Lazy<`t>'

inl memoize forall t. (fn : () -> t) : () -> t =
    inl fn = join fn
    inl result : lazy t = $'lazy !fn ()'
    fun () => $'!result.Value'

/// ## to_any
inl to_any forall t. (obj : t) : any =
    $"!obj"

instance (~:>) any = to_any

/// ## (||>)

/// ## flip
inl flip fn a b =
    fn b a

/// ## join_body
inl join_body body acc x =
    if var_is x |> not
    then body acc x
    else
        inl acc = dyn acc
        join body acc x

/// ## join_body_unit
inl join_body_unit body d x =
    if var_is d |> not
    then body x
    else
        inl x = dyn x
        join body x

/// ## nameof
inl nameof x : string =
    $"nameof !x"

/// ## disposable
nominal disposable t = $"System.IDisposable"

/// ## dispose
inl dispose (disposable : disposable _) : () =
    disposable |> $'_.Dispose()'

/// ## new_disposable
inl new_disposable (fn : () -> ()) : disposable _ =
    run_target function
        | Rust _ => fun () =>
            global "type Disposable (f : unit -> unit) = interface System.IDisposable with member _.Dispose () = f ()"
            $'new Disposable (fun () -> Fable.Core.RustInterop.emitRustExpr !fn "$0()" )'
        | Fsharp _ => fun () =>
            inl fn = join fn
            $'{ new System.IDisposable with member _.Dispose () = !fn () }'
        | _ => fun () => null ()

/// ## return
inl return forall t. (x : t) : () =
    $'return !x '

inl return' forall t. (x : t) : t =
    $'return !x '

/// ## sleep
inl sleep (n : i32) : () =
    run_target function
        | Fsharp (Native) => fun () => $'System.Threading.Thread.Sleep' n
        | _ => fun () => ()

/// ## retry_fn
inl retry_fn forall t. retries (fn : () -> t) : option t =
    let rec loop retry =
        try
            fun () =>
                if retry < retries
                then fn () |> Some
                else None
            fun ex =>
                trace Warning
                    fun () => "retry_fn"
                    fun () => $'$"retry: {!retry} / ex: %A{!ex} / {!_locals ()}"'
                sleep 1
                None
        |> function
            | Some x => x
            | None => loop (retry + 1)
    loop 0

/// ## main
inl main () =
    types ()
    init_trace_state ()
    inl new_disposable x : _ () = new_disposable x
    $"let new_disposable x = !new_disposable x" : ()

    inl retry_fn (r : i32) (x : () -> _) : optionm'.option' () = retry_fn r x |> optionm'.box
    $"let retry_fn x = !retry_fn x" : ()
    inl memoize (fn : () -> ()) : () -> () = memoize fn
    $"let memoize x = !memoize x" : ()
