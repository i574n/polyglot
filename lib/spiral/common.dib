#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[]}}

#!markdown

# common

#!spiral

// // test

open testing

#!markdown

## types

#!spiral

nominal any = $"obj"
nominal disposable = $"System.IDisposable"
nominal exn = $"exn"
nominal unativeint = $"unativeint"

let array x = x

inl unativeint forall t {int}. (n : t) : unativeint =
    $"unativeint !n"

#!markdown

## prototype

#!spiral

prototype (~:>) r : forall t. t -> r
prototype append t : t -> t -> t
prototype of_string t : string -> t
prototype to_string t : t -> string

#!markdown

## null

#!spiral

inl null forall t. () : t =
    $"null |> unbox<`t>"

#!spiral

inl i32 forall t. (x : t) : i32 =
    $"int32 !x"

inl i64 forall t. (x : t) : i64 =
    $"int64 !x"

inl f32 forall t. (x : t) : f32 =
    $"float32 !x"

inl f64 forall t. (x : t) : f64 =
    $"float !x"

#!markdown

## pair

#!spiral

type pair a b = $"(`a * `b)"

inl pair x y =
    x, y

#!spiral

// // test

pair 1i32 2i32
|> _assert_eq (1, 2)

#!markdown

## new_pair

#!spiral

inl new_pair forall a b. (a : a) (b : b) : pair a b =
    $"!a, !b"

#!markdown

## from_pair

#!spiral

inl from_pair forall a b. (pair : pair a b) : a * b =
    $"let (a, b) = !pair"
    $"a", $"b"

#!spiral

// // test

new_pair "a" 1i32
|> from_pair
|> _assert_eq ("a", 1i32)

#!spiral

// // test

new_pair "a" (new_pair 1i32 "b")
|> from_pair

#!markdown

## log_level_type

#!spiral

union log_level_type =
    | Verbose
    | Debug
    | Info
    | Warning
    | Critical

instance to_string log_level_type = function
    | Verbose => "Verbose"
    | Debug => "Debug"
    | Info => "Info"
    | Warning => "Warning"
    | Critical => "Critical"

instance of_string log_level_type = function
    | "Verbose" => Verbose
    | "Debug" => Debug
    | "Info" => Info
    | "Warning" => Warning
    | "Critical" => Critical

#!markdown

## to_any

#!spiral

inl to_any forall t. (obj : t) : any =
    $"!obj"

instance (~:>) any = to_any

#!markdown

## (/@)

#!spiral

inl (/@) a b =
    b |> append a

#!markdown

## unbox

#!spiral

inl unbox forall t u. (x : t) : u =
    $"!x |> unbox<`u>"

#!markdown

## (/+)

#!spiral

inl (/+) forall t. (a : t) (b : t) : t =
    $"!a + !b"

#!markdown

## (/=)

#!spiral

inl (/=) forall t. (a : t) (b : t) : bool =
    $"!a = !b"

#!markdown

## (||>)

#!spiral

inl (||>) (arg1, arg2) fn =
    arg2 |> fn arg1

#!spiral

// // test

(3i32, 2i32)
||> fun a b => a - b
|> _assert_eq 1

#!markdown

## flip

#!spiral

inl flip fn a b =
    fn b a

#!spiral

// // test

(1i32, 2i32)
||> flip pair
|> _assert_eq (2, 1)

#!markdown

## join_body

#!spiral

inl join_body body acc x =
    if var_is x |> not
    then body acc x
    else
        inl acc = dyn acc
        join body acc x

#!spiral

// // test

inl rec fold_list f s = function
    | Cons (x, x') => fold_list f (f s x) x'
    | Nil => s

#!spiral

// // test

[5i32; 4; join 3; 2; 1]
|> fold_list (+) 0
|> _assert_eq 15

#!spiral

// // test

[5i32; 4; join 3; 2; 1]
|> fold_list (join_body (+)) 0
|> _assert_eq 15

#!markdown

## join_body_unit

#!spiral

inl join_body_unit body d x =
    if var_is d |> not
    then body x
    else
        inl x = dyn x
        join body x

#!spiral

// // test

[5i32; 4; join 3; 2; 1]
|> fold_list (fun acc n => join_body_unit ((+) acc) n n) 0
|> _assert_eq 15

#!markdown

## run_target

#!spiral

union target_runtime =
    | Native
    | Wasm
    | Fable

union target =
    | Rust : target_runtime
    | Fsharp : target_runtime

inl run_target forall t. (fn : target -> (() -> t)) : t =
    $"let mutable result = None"
    $"#if FABLE_COMPILER_RUST && \!WASM"
    fn (Rust Native) () |> fun x => $"!x"
    $"#endif"
    $"#if FABLE_COMPILER_RUST && WASM"
    fn (Rust Wasm) () |> fun x => $"!x"
    $"#endif"
    $"#if \!FABLE_COMPILER && \!FABLE_COMPILER_RUST && \!WASM"
    fn (Fsharp Native) () |> fun x => $"!x"
    $"#endif"
    $"#if FABLE_COMPILER && \!FABLE_COMPILER_RUST && \!WASM"
    fn (Fsharp Fable) () |> fun x => $"!x"
    $"#endif"
    $"#if \!FABLE_COMPILER_RUST && WASM"
    fn (Fsharp Wasm) () |> fun x => $"!x"
    $"#endif"
    $"|> fun x -> result <- Some x"
    $"result |> Option.get"

#!spiral

// // test

run_target function
    | Fsharp (Native) => fun () => $"1uy"
    | _ => fun () => $"2uy"
|> _assert_eq 1u8

#!spiral

// // test
// // rust=

run_target function
    | Rust (Native) => fun () => $"1uy"
    | _ => fun () => $"2uy"
|> (=) 1u8
|> _assert_eq true

#!markdown

## nameof

#!spiral

inl nameof x : string =
    $"nameof !x"

#!markdown

## get_environment_variable

#!spiral

inl get_environment_variable (var : string) : string =
    $"System.Environment.GetEnvironmentVariable !var"

#!markdown

## memoize

#!spiral

nominal lazy t = $'Lazy<`t>'

inl memoize forall t. (fn : () -> t) : () -> t =
    inl result : lazy t = $'lazy !fn ()'
    fun () => $'!result.Value'

#!spiral

// // test

inl count = mut 0i32
inl add =
    fun () => count <- *count + 1
    |> memoize

add ()
add ()
add ()

*count
|> _assert_eq 1

#!spiral

// // test

fun () => failwith "test"
|> _throws
|> optionm.map sm'.format_exception
|> _assert_eq (Some "System.Exception: test")

#!markdown

## use_disposable

#!spiral

inl use_disposable (disposable : disposable) : disposable =
    $"use !disposable = !disposable" : ()
    $"!disposable"

#!markdown

## new_disposable

#!spiral

inl new_disposable (fn : () -> ()) : disposable =
    run_target function
        | Fsharp _ => fun () => $'{ new System.IDisposable with member _.Dispose () = !fn () }'
        | Rust _ =>
            inl fn = join fn
            fun () => $'{ new System.IDisposable with member _.Dispose () = Fable.Core.RustInterop.emitRustExpr () "!fn()" }'

#!spiral

// // test

inl new_disposable_test = mut 0i32
new_disposable (fun () => new_disposable_test <- *new_disposable_test + 1)
|> $'_.Dispose()'
*new_disposable_test |> _assert_eq 1

#!spiral

// // test

inl new_disposable_test = mut 0i32
fun () =>
    new_disposable fun () => new_disposable_test <- *new_disposable_test + 1
    |> use_disposable
    |> ignore
|> async.new_task
|> async.await_task
|> async.run_synchronously
*new_disposable_test |> _assert_eq 1

#!spiral

// // test

inl new_disposable_test = mut 0i32
fun () =>
    new_disposable fun () => new_disposable_test <- *new_disposable_test + 1
    |> use_disposable
    |> ignore
|> async.new_async
|> async.run_synchronously
*new_disposable_test |> _assert_eq 1

#!spiral

// // test

inl new_disposable_test = mut 0i32
fun () =>
    new_disposable fun () => new_disposable_test <- *new_disposable_test + 1
    |> ignore
|> async.new_async
|> async.run_synchronously
*new_disposable_test |> _assert_eq 0

#!markdown

## try

#!spiral

inl try forall t. (fn : () -> t) (ex_fn : exn -> ()) : option t =
    inl none = None : option t
    inl some (s : t) = Some s
    $'try !fn () |> !some with ex -> !ex_fn ex; !none '

#!markdown

## sleep

#!spiral

inl sleep (n : i32) : () =
    run_target function
        | Fsharp (Native) => fun () => $'System.Threading.Thread.Sleep' n
        | _ => fun () => ()

#!markdown

## retry_fn

#!spiral

inl retry_fn forall t. retries (fn : () -> t) : option t =
    let rec loop retry =
        try
            fun () =>
                if retry < retries
                then fn () |> Some
                else None
            fun ex =>
                let getLocals () = $"retry: {retry} / ex: {ex |> Sm.format_exception} / {getLocals ()}"
                // trace Warning (fun () => "retry_fn") getLocals
                sleep 1
        |> function
            | Some x => x
            | None => loop (retry + 1)
    loop 0

#!spiral

// // test

inl retry_fn_test = mut 0i32
fun () =>
    retry_fn_test <- *retry_fn_test + 1
    *retry_fn_test
|> retry_fn 3i32
|> _assert_eq (Some 1i32)

#!spiral

// // test

inl retry_fn_test = mut 0i32
fun () =>
    if *retry_fn_test >= 2
    then *retry_fn_test
    else
        retry_fn_test <- *retry_fn_test + 1
        failwith "test"
|> retry_fn 3i32
|> _assert_eq (Some 2i32)

#!markdown

## main

#!spiral

inl main () =
    inl retry_fn (r : i32) (x : () -> _) : optionm'.option' () =
        retry_fn r x |> optionm'.box
    $"let new_disposable x = !new_disposable x" : ()
    $"let retry_fn x = !retry_fn x" : ()
