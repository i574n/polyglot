#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!markdown

# file_system

#!spiral

open sm'_operators
open rust_operators

#!spiral

// // test

open testing

#!markdown

## types

#!spiral

inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::io::Error\")>] type std_io_Error = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::path::Path\")>] type std_path_Path = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::path::PathBuf\")>] type std_path_PathBuf = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"async_walkdir::DirEntry\")>] type async_walkdir_DirEntry = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"async_walkdir::WalkDir\")>] type async_walkdir_WalkDir = class end"

#!spiral

inl types () =
    global "#if FABLE_COMPILER // file_system.types"
    sm'.types ()
    rust.types ()
    types ()
    global "#endif // file_system.types"

#!markdown

## file_mode

#!spiral

nominal file_mode' = $'System.IO.FileMode'

union file_mode =
    | ModeCreateNew
    | ModeCreate
    | ModeOpen
    | ModeOpenOrCreate
    | Truncate
    | Append

inl file_mode = function
    | ModeCreateNew => $'System.IO.FileMode.CreateNew' : file_mode'
    | ModeCreate => $'System.IO.FileMode.Create' : file_mode'
    | ModeOpen => $'System.IO.FileMode.Open' : file_mode'
    | ModeOpenOrCreate => $'System.IO.FileMode.OpenOrCreate' : file_mode'
    | Truncate => $'System.IO.FileMode.Truncate' : file_mode'
    | Append => $'System.IO.FileMode.Append' : file_mode'

#!markdown

## file_access

#!spiral

nominal file_access' = $'System.IO.FileAccess'

union file_access =
    | AccessRead
    | AccessWrite
    | AccessReadWrite

inl file_access = function
    | AccessRead => $'System.IO.FileAccess.Read' : file_access'
    | AccessWrite => $'System.IO.FileAccess.ReadWrite' : file_access'
    | AccessReadWrite => $'System.IO.FileAccess.ReadWrite' : file_access'

#!markdown

## file_share

#!spiral

nominal file_share' = $'System.IO.FileShare'

union file_share =
    | ShareNone
    | ShareRead
    | ShareWrite
    | ShareReadWrite
    | ShareDelete

inl file_share = function
    | ShareNone => $'System.IO.FileShare.None' : file_share'
    | ShareRead => $'System.IO.FileShare.Read' : file_share'
    | ShareWrite => $'System.IO.FileShare.Write' : file_share'
    | ShareReadWrite => $'System.IO.FileShare.ReadWrite' : file_share'
    | ShareDelete => $'System.IO.FileShare.Delete' : file_share'

#!markdown

## file_stream

#!spiral

nominal file_stream' = $'System.IO.FileStream'

inl file_stream (path : string) mode access share : file_stream' =
    run_target function
        | Fsharp (Native) => fun () =>
            inl mode = mode |> file_mode
            inl access = access |> file_access
            inl share = share |> file_share
            $'new System.IO.FileStream (!path, !mode, !access, !share)'
        | _ => fun () => null ()

#!markdown

## path

#!spiral

nominal path = $'std_path_Path'
nominal path_buf = $'std_path_PathBuf'

#!markdown

## new_path_buf

#!spiral

inl new_path_buf (path : string) : path_buf =
    open rust_operators
    inl path = path |> sm'.to_std_string
    !\\(path, $'"std::path::PathBuf::from($0)"')

#!markdown

## path_buf_from

#!spiral

inl path_buf_from (path : rust.box path) : path_buf =
    open rust_operators
    !\\(path, $'"std::path::PathBuf::from($0)"')

#!markdown

## path_buf_join

#!spiral

inl path_buf_join (s : string) (path_buf : path_buf) : path_buf =
    open rust_operators
    !\\((path_buf, s |> sm'.to_std_string), $'"$0.join($1)"')

#!markdown

## path_display

#!spiral

inl path_display (path : rust.ref' path) : sm'.std_string =
    open rust_operators
    !\\(path, $'"$0.display().to_string()"')

#!markdown

## path_buf_file_name

#!spiral

inl path_buf_file_name (path : path_buf) : optionm'.option' (rust.ref' sm'.os_str) =
    open rust_operators
    !\($'"!path.file_name()"')

#!markdown

## path_buf_display

#!spiral

inl path_buf_display (path_buf : path_buf) : sm'.std_string =
    open rust_operators
    !\\(path_buf, $'"$0.display().to_string()"')

#!markdown

## path_buf_exists

#!spiral

inl path_buf_exists (path_buf : path_buf) : bool =
    open rust_operators
    !\\(path_buf, $'"$0.exists()"')

#!markdown

## path_buf_is_dir

#!spiral

inl path_buf_is_dir (path_buf : path_buf) : bool =
    open rust_operators
    !\\(path_buf, $'"$0.is_dir()"')

#!markdown

## path_buf_is_file

#!spiral

inl path_buf_is_file (path_buf : path_buf) : bool =
    open rust_operators
    !\\(path_buf, $'"$0.is_file()"')

#!markdown

## path_buf_parent

#!spiral

inl path_buf_parent (path_buf : path_buf) : optionm'.option' path_buf =
    open rust_operators
    !\\(path_buf, $'"$0.parent().map(std::path::PathBuf::from)"')

#!markdown

## ts_path_join

#!spiral

inl ts_path_join (b : string) (a : string) : string =
    open ts_operators
    global "type IPathJoin = abstract join: [<System.ParamArray>] paths: string[] -> string"
    inl path : $'IPathJoin' = ts.import_all "path"

    inl a = join a
    inl b = join b
    !\($'"!path.join(!a, !b)"')

#!markdown

## (< />)

#!spiral

inl (</>) (a : string) (b : string) : string =
    run_target function
        | Rust (Native) => fun () =>
            a |> new_path_buf |> path_buf_join b |> path_buf_display |> sm'.from_std_string
        | Fsharp (Native) => fun () =>
            $'System.IO.Path.Combine (!a, !b)'
        | TypeScript _ => fun () =>
            a |> ts_path_join b
        | _ => fun () => null ()

#!markdown

## dir_entry

#!spiral

nominal dir_entry = $'async_walkdir_DirEntry'

#!markdown

## walk_dir

#!spiral

nominal walk_dir = $'async_walkdir_WalkDir'

#!markdown

## io_error

#!spiral

nominal io_error = $"std_io_Error"

#!markdown

## dir_entry_path

#!spiral

inl dir_entry_path (dir_entry : dir_entry) : path_buf =
    !\\(dir_entry, $'"async_walkdir::DirEntry::path(&$0)"')

#!markdown

## get_temp_path

#!spiral

inl get_temp_path () : string =
    $'System.IO.Path.GetTempPath' ()

#!markdown

## get_file_name

#!spiral

inl get_file_name (path : string) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.Path.GetFileName'
        | _ => fun () => null ()

#!markdown

## get_full_path

#!spiral

inl get_full_path (path : string) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            inl path = join path
            path |> $'System.IO.Path.GetFullPath'
        | Rust (Native) => fun () =>
            open rust_operators
            inl path = !\\(path, $'"std::fs::canonicalize(&*$0)"') : resultm.result' path_buf io_error
            path
            |> resultm.unwrap'
            |> path_buf_display
            |> sm'.from_std_string
        | _ => fun () => null ()

#!spiral

// // test

"." |> get_full_path

#!spiral

// // test
// // rust=
// // trace=true

types ()
"." |> get_full_path
|> console.write_line

#!markdown

## get_current_directory

#!spiral

inl get_current_directory () : string =
    run_target function
        | Fsharp (Native) => fun () =>
            $'System.IO.Directory.GetCurrentDirectory' ()
        | Rust (Native) => fun () =>
            open rust_operators
            inl current_dir = !\($'"std::env::current_dir()"') : resultm.result' path_buf io_error
            current_dir
            |> resultm.unwrap'
            |> path_buf_display
            |> sm'.from_std_string
        | _ => fun () => null ()

#!spiral

// // test

get_current_directory ()

#!markdown

## create_temp_directory_name

#!spiral

inl create_temp_directory_name () =
    run_target function
        | Fsharp (Native) => fun () =>
            get_temp_path ()
            </> ($'$"\!{!get_entry_assembly_name ()}"' : string)
            </> (date_time.now () |> date_time.new_guid_from_date_time |> sm'.obj_to_string)
        | target => fun () => null ()

#!spiral

// // test

create_temp_directory_name ()
|> _assert_contains ($'System.IO.Path.DirectorySeparatorChar' : char)

#!markdown

## directory_info

#!spiral

nominal directory_info = $'System.IO.DirectoryInfo'

inl directory_info (path : string) : directory_info =
    path |> $'`directory_info '

#!markdown

## directory_info_exists

#!spiral

inl directory_info_exists (info : directory_info) : bool =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!info.Exists'
        | _ => fun () => null ()

#!markdown

## directory_info_creation_time

#!spiral

inl directory_info_creation_time (info : directory_info) : date_time.date_time =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!info.CreationTime'
        | _ => fun () => null ()

#!markdown

## directory_info_name

#!spiral

inl directory_info_name (info : directory_info) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!info.Name'
        | _ => fun () => null ()

#!markdown

## directory_info_full_name

#!spiral

inl directory_info_full_name (info : directory_info) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!info.FullName'
        | _ => fun () => null ()

#!markdown

## get_source_directory

#!spiral

inl get_source_directory () =
    $'__SOURCE_DIRECTORY__' : string

#!spiral

// // test

get_source_directory ()
|> directory_info
|> directory_info_name
|> _assert_eq "spiral"

#!markdown

## create_directory

#!spiral

inl create_directory (path : string) : directory_info =
    run_target function
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.Directory.CreateDirectory'
        | _ => fun () => null ()

#!markdown

## directory_exists

#!spiral

inl directory_exists (path : string) : bool =
    run_target function
        | Rust (Native) => fun () =>
            inl path = path |> new_path_buf
            (path |> path_buf_exists) && (path |> path_buf_is_dir)
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.Directory.Exists'
        | TypeScript (Native) => fun () =>
            global "type IFsExistsSync = abstract existsSync: path: string -> bool"
            inl fs : $'IFsExistsSync' = ts.import_all "fs"
            ts.emit_expr path $'"!fs.existsSync($0)"'
        | _ => fun () => null ()

#!markdown

## directory_get_parent

#!spiral

inl directory_get_parent (path : string) : optionm'.option' string =
    run_target function
        | Rust (Native) => fun () =>
            path
            |> new_path_buf
            |> path_buf_parent
            |> optionm'.try'
            |> path_buf_display
            |> sm'.from_std_string
            |> Some
        | Fsharp (Native) => fun () =>
            inl parent : directory_info = path |> $'System.IO.Directory.GetParent'
            if parent =. null ()
            then None
            else parent |> directory_info_full_name |> Some
        | TypeScript _ => fun () =>
            global "type IPathDirname = abstract dirname: path: string -> string"
            inl fs : $'IPathDirname' = ts.import_all "path"
            ts.emit_expr path $'"!fs.dirname($0)"' |> Some
        | _ => fun () => null ()
    |> optionm'.box

#!markdown

## file_delete

#!spiral

inl file_delete (path : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.File.Delete'
        | _ => fun () => null ()

#!markdown

## file_move

#!spiral

inl file_move (old_path : string) (new_path : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            $'System.IO.File.Move (!old_path, !new_path)'
        | _ => fun () => null ()

#!markdown

## file_exists

#!spiral

inl file_exists (path : string) : bool =
    run_target function
        | Rust (Native) => fun () =>
            inl path_buf = path |> new_path_buf
            (path_buf |> path_buf_exists) && (path_buf |> path_buf_is_file)
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.File.Exists'
        | TypeScript (Native) => fun () =>
            global "type IFsExistsSync = abstract existsSync: path: string -> bool"
            inl fs : $'IFsExistsSync' = ts.import_all "fs"
            ts.emit_expr path $'"!fs.existsSync($0)"'
        | _ => fun () => null ()

#!markdown

## directory_delete

#!spiral

inl directory_delete recursive (path : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            $'System.IO.Directory.Delete (!path, !recursive)'
        | _ => fun () => null ()

#!markdown

## read_all_text_async

#!spiral

inl read_all_text_async (path : string) : _ string =
    run_target function
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.File.ReadAllTextAsync' |> async.await_task
        | _ => fun () => null ()

#!markdown

## file_exists_content

#!spiral

inl file_exists_content path content : _ bool =
    run_target function
        | Fsharp (Native) => fun () =>
            fun () =>
                if path |> file_exists |> not
                then false |> return |> fun x => $'(*' : ()
                else
                    $'*) else' : ()
                    inl existing_content = path |> read_all_text_async |> async.let'
                    content = existing_content |> return |> fun x => $'(*' : ()
                |> fun x => $'*)' : ()
            |> async.new_async_unit
        | _ => fun () => null ()

#!markdown

## write_all_text

#!spiral

inl write_all_text (path : string) (text : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            $'System.IO.File.WriteAllText (!path, !text)'
        | _ => fun () => null ()

#!markdown

## write_all_text_async

#!spiral

inl write_all_text_async (path : string) (text : string) : _ () =
    run_target function
        | Fsharp (Native) => fun () =>
            $'System.IO.File.WriteAllTextAsync (!path, !text)' |> async.await_task
        | _ => fun () => null ()

#!markdown

## write_all_text_exists

#!spiral

inl write_all_text_exists path contents =
    fun () =>
        inl exists' = contents |> file_exists_content path |> async.let'
        if not exists'
        then contents |> write_all_text_async path |> async.do
    |> async.new_async

#!markdown

## delete_directory_async

#!spiral

inl delete_directory_async path : _ i64 =
    run_target function
        | Fsharp (Native) => fun () =>
            let rec loop (retry : i64) =
                fun () =>
                    try_unit
                        fun () =>
                            path |> directory_delete true
                            retry |> return
                        fun ex =>
                            if retry % 100i64 = 0 then
                                inl ex = ex |> sm'.format_exception
                                let get_locals () = $'$"path: {!path |> !get_file_name} / ex: {!ex} / {!get_locals ()}"' : string
                                // trace Debug (fun () -> "delete_directory_async") getLocals
                                console.write_line ($'$"delete_directory_async / {!get_locals ()}"' : string)
                            async.sleep 10i32 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async
            loop 0
        | _ => fun () => null ()

#!markdown

## create_temp_directory

#!spiral

inl create_temp_directory () =
    run_target function
        | Fsharp (Native) => fun () =>
            inl temp_folder = create_temp_directory_name ()
            inl result = temp_folder |> create_directory

            inl exists' = result |> directory_info_exists
            if not exists' then
                inl creation_time = result |> directory_info_creation_time
                inl result = ($'{| Exists = !exists'; CreationTime = !creation_time |}' : any) |> sm'.format_debug
                inl get_locals () : string =
                    $'$"temp_folder: {!temp_folder} / result: {!result} {!get_locals ()}"'
                // trace Debug (fun () => "createTempDirectory") get_locals
                console.write_line ($'$"create_temp_directory / {!get_locals ()}"' : string)
            inl disposable : _ () = new_disposable fun () =>
                temp_folder
                |> delete_directory_async
                |> async.ignore
                |> async.run_synchronously
            temp_folder, disposable
        | _ => fun () => null ()

#!spiral

// // test

inl path, disposable = create_temp_directory ()
disposable |> use |> ignore
path
|> directory_exists
|> _assert_eq true

#!spiral

// // test

inl lock_directory path =
    fun () =>
        trace Debug (fun () => "_1") get_locals
        "0" |> write_all_text_async (path </> "test.txt") |> async.do
        file_stream
            (path </> "test.txt")
            ModeOpen
            AccessReadWrite
            ShareNone
        |> use
        |> ignore
        trace Debug (fun () => "_2") get_locals
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") get_locals
        () |> return
    |> async.new_async

inl temp_dir, disposable = create_temp_directory ()
disposable |> use |> ignore
inl path = temp_dir </> "test"

fun () =>
    trace Debug (fun () => "1") get_locals
    path |> create_directory |> ignore
    trace Debug (fun () => "2") get_locals
    inl child = path |> lock_directory |> async.start_child |> async.let'
    trace Debug (fun () => "3") get_locals
    async.sleep 60 |> async.do
    trace Debug (fun () => "4") get_locals
    inl retries = path |> delete_directory_async |> async.let'
    trace Debug (fun () => "5") get_locals
    child |> async.do
    trace Debug (fun () => "6") get_locals
    retries |> return
|> async.new_async_unit
|> async.run_with_timeout 3000
|> fun x => x : _ i64
|> function
    | Some (retries : i64) =>
        retries
        |> _assert_between
            (if runtime.is_windows () then 50 else 0)
            (if runtime.is_windows () then 150 else 0)

        true
    | _ => false
|> _assert_eq true

#!markdown

## wait_for_file_access

#!spiral

inl wait_for_file_access access path =
    run_target function
        | Fsharp (Native) => fun () =>
            inl file_access, file_share =
                access
                |> optionm'.default_value (AccessReadWrite, ShareRead)
            let rec loop (retry : i64) : _ i64 =
                fun () =>
                    try_unit
                        fun () =>
                            file_stream
                                path
                                ModeOpen
                                file_access
                                file_share
                            |> use
                            |> ignore
                            retry |> return
                        fun ex =>
                            if retry > 0 && retry % 100i64 = 0 then
                                inl ex = ex |> sm'.format_exception
                                let get_locals () = $'$"path: {!path |> !get_file_name} / retry: {!retry} / ex: {!ex} / {!get_locals ()}"' : string
                                // trace Debug (fun () -> "wait_for_file_access") getLocals
                                console.write_line ($'$"wait_for_file_access / {!get_locals ()}"' : string)
                            async.sleep 10i32 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async
            loop 0
        | _ => fun () => null ()

inl wait_for_file_access_read path =
    path
    |> wait_for_file_access (Some (
        AccessRead,
        ShareRead
    ))

#!spiral

// // test

inl lock_file path =
    fun () =>
        trace Debug (fun () => "_1") get_locals
        inl stream : file_stream' =
            file_stream
                path
                ModeOpen
                AccessReadWrite
                ShareNone
            |> use
        trace Debug (fun () => "_2") get_locals
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") get_locals
        ($'!stream.Seek (0L, System.IO.SeekOrigin.Begin)' : i64) |> ignore
        trace Debug (fun () => "_4") get_locals
        $'!stream.WriteByte' 49u8
        trace Debug (fun () => "_5") get_locals
        stream |> $'_.Flush()'
        trace Debug (fun () => "_6") get_locals
    |> async.new_async

inl temp_dir, disposable = create_temp_directory ()
disposable |> use |> ignore
inl path = temp_dir </> "test.txt"

fun () =>
    trace Debug (fun () => "1") get_locals
    "0" |> write_all_text_async path |> async.do
    trace Debug (fun () => "2") get_locals
    inl child = path |> lock_file |> async.start_child |> async.let'
    trace Debug (fun () => "3") get_locals
    async.sleep 1 |> async.do
    trace Debug (fun () => "4") get_locals
    inl retries = path |> wait_for_file_access None |> async.let'
    trace Debug (fun () => "5") get_locals
    inl text = path |> read_all_text_async |> async.let'
    trace Debug (fun () => "6") get_locals
    child |> async.do
    trace Debug (fun () => "7") get_locals
    (retries, text) |> return
|> async.new_async_unit
|> async.run_with_timeout 3000
|> function
    | Some ((retries : i64), text) =>
        retries
        |> _assert_between
            (if runtime.is_windows () then 50 else 100)
            (if runtime.is_windows () then 150 else 200)

        text |> _assert_eq (join "1")

        true
    | _ => false
|> _assert_eq true

#!markdown

## read_all_text_retry_async

#!spiral

inl read_all_text_retry_async full_path : async.async (optionm'.option' string) =
    run_target function
        | Fsharp (Native) => fun () =>
            let rec loop (retry : i64) =
                fun () =>
                    try_unit
                        fun () =>
                            if retry > 0
                            then
                                full_path
                                |> wait_for_file_access_read
                                |> async.run_with_timeout_async 1000
                                |> async.ignore
                                |> async.do
                            full_path |> read_all_text_async |> async.map (Some >> optionm'.box) |> async.return_await
                        fun ex =>
                            if retry <> 0 then
                                inl ex = ex |> sm'.format_exception
                                let get_locals () = $'$"retry: {!retry} / ex: {!ex} / {!get_locals ()}"' : string
                                trace Debug (fun () => $'"read_all_text_retry_async"' : string) get_locals
                                (None : _ string) |> optionm'.box |> return |> fun x => $'(*' : ()
                            else
                                $'*) else' : ()
                                loop (retry + 1) |> async.return_await |> fun x => $'(*' : ()
                            |> fun x => $'*)' : ()
                |> async.new_async
            loop 0
        | _ => fun () => null ()

#!markdown

## delete_file_async

#!spiral

inl delete_file_async path : _ i64 =
    run_target function
        | Fsharp (Native) => fun () =>
            let rec loop (retry : i64) =
                fun () =>
                    try_unit
                        fun () =>
                            path |> file_delete
                            return retry
                        fun ex =>
                            if retry % 100 = 0 then
                                inl ex = ex |> sm'.format_exception
                                let getLocals () = $'$"path: {!path |> !get_file_name} / ex: {ex} / {!get_locals ()}"'
                                trace Warning (fun () => "delete_file_async") get_locals
                            async.sleep 10 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async
            loop 0
        | _ => fun () => null ()

#!spiral

// // test

inl lock_file path =
    fun () =>
        trace Debug (fun () => "_1") get_locals
        file_stream
            path
            ModeOpen
            AccessReadWrite
            ShareNone
        |> use
        |> ignore
        trace Debug (fun () => "_2") get_locals
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") get_locals
    |> async.new_async

inl temp_dir, disposable = create_temp_directory ()
disposable |> use |> ignore
inl path = temp_dir </> "test.txt"

fun () =>
    trace Debug (fun () => "1") get_locals
    "0" |> write_all_text_async path |> async.do
    trace Debug (fun () => "2") get_locals
    inl child = lock_file path |> async.start_child |> async.let'
    trace Debug (fun () => "3") get_locals
    async.sleep 1 |> async.do
    trace Debug (fun () => "4") get_locals
    inl retries = delete_file_async path |> async.let'
    trace Debug (fun () => "5") get_locals
    child |> async.do
    trace Debug (fun () => "6") get_locals
    return retries
|> async.new_async_unit
|> async.run_with_timeout 3000
|> function
    | Some (retries : i64) =>
        retries
        |> _assert_between
            (if runtime.is_windows () then 50 else 0)
            (if runtime.is_windows () then 150 else 0)

        true
    | _ => false
|> _assert_eq true

#!markdown

## move_file_async

#!spiral

inl move_file_async new_path old_path : _ i64 =
    run_target function
        | Fsharp (Native) => fun () =>
            let rec loop (retry : i64) =
                fun () =>
                    try_unit
                        fun () =>
                            file_move old_path new_path
                            return retry
                        fun ex =>
                            if retry % 100 = 0 then
                                let get_locals () =
                                    inl ex = ex |> sm'.format_exception
                                    $'$"old_path: {!old_path |> !get_file_name} / new_path: {!new_path |> !get_file_name} / ex: {!ex} / {!get_locals ()}"' : string
                                trace Warning (fun () => "move_file_async") get_locals
                            async.sleep 10 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async_unit
            loop 0
        | _ => fun () => null ()

#!spiral

// // test

inl lock_file path =
    fun () =>
        trace Debug (fun () => "_1") get_locals
        file_stream
            path
            ModeOpen
            AccessReadWrite
            ShareNone
        |> use
        |> ignore
        trace Debug (fun () => "_2") get_locals
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") get_locals
    |> async.new_async

inl temp_dir, disposable = create_temp_directory ()
disposable |> use |> ignore
let path = temp_dir </> "test.txt"
let new_path = temp_dir </> "test2.txt"

fun () =>
    trace Debug (fun () => "1") get_locals
    "0" |> write_all_text_async path |> async.do
    trace Debug (fun () => "2") get_locals
    inl child = lock_file path |> async.start_child |> async.let'
    trace Debug (fun () => "3") get_locals
    async.sleep 1 |> async.do
    trace Debug (fun () => "4") get_locals
    inl retries1 = path |> move_file_async new_path |> async.let'
    trace Debug (fun () => "5") get_locals
    inl retries2 = new_path |> wait_for_file_access None |> async.let'
    trace Debug (fun () => "6") get_locals
    inl text = new_path |> read_all_text_async |> async.let'
    trace Debug (fun () => "7") get_locals
    child |> async.do
    trace Debug (fun () => "8") get_locals
    (retries1, retries2, text) |> return
|> async.new_async_unit
|> async.run_with_timeout 3000
|> function
    | Some (retries1, retries2, text) =>
        retries1
        |> _assert_between
            (if runtime.is_windows () then 50i64 else 0)
            (if runtime.is_windows () then 150 else 0)

        retries2
        |> _assert_between
            (if runtime.is_windows () then 0i64 else 100)
            (if runtime.is_windows () then 0 else 200)

        text |> _assert_eq (join "0")

        true
    | _ => false
|> _assert_eq true

#!markdown

## find_parent

#!spiral

inl find_parent name is_file root_dir =
    let rec loop dir =
        if dir </> name |> (if is_file then file_exists else directory_exists)
        then dir
        else
            inl result = dir |> (join directory_get_parent)
            match result |> optionm'.unbox with
            | Some parent => parent |> loop
            | None => failwith $'$"""No parent for {if !is_file then "file" else "dir"} \'{!name}\' at \'{!root_dir}\' (until \'{!dir}\')"""'
    loop root_dir

#!spiral

// // test
// // print_code=false

a ;[ ".paket", false; "paket.dependencies", true ]
|> am.map fun (file, is_file) =>
    get_source_directory ()
    |> find_parent file is_file
    |> directory_info
    |> directory_info_name
|> am'.distinct
|> _assert_eq (a ;[ "polyglot" ] : _ i32 _)

#!spiral

// // test
// // rust=
// // print_code=false

types ()
a ;[ ".paket", false; "paket.dependencies", true ]
|> am.map fun (file, is_file) =>
    fun () =>
        join
            get_source_directory ()
            |> find_parent file is_file
            |> new_path_buf
            |> path_buf_file_name
            |> optionm'.try'
            |> sm'.to_os_string
            |> sm'.os_to_str
            |> optionm'.try'
            |> sm'.ref_to_std_string
            |> sm'.from_std_string
            |> Some
            |> optionm'.box
    |> fun x => x () |> optionm'.unbox
    |> optionm'.default_value ""
|> am'.distinct
|> fun result =>
    result |> am'.length |> _assert_eq 1i32
    index result 0i32 |> _assert_eq "polyglot"

#!markdown

## get_repository_root

#!spiral

inl get_repository_root () =
    get_source_directory ()
    |> find_parent ("polyglot" </> ".paket") false
    |> fun root => root </> "polyglot"

#!markdown

## main

#!spiral

inl main () =
    types ()
    init_trace_state ()
    $"let delete_directory_async x = !delete_directory_async x" : ()
    $"let wait_for_file_access x = !wait_for_file_access x" : ()
    $"let wait_for_file_access_read x = !wait_for_file_access_read x" : ()
    $"let read_all_text_async x = !read_all_text_async x" : ()
    $"let file_exists_content x = !file_exists_content x" : ()
    $"let write_all_text_async x = !write_all_text_async x" : ()
    $"let write_all_text_exists x = !write_all_text_exists x" : ()
    $"let delete_file_async x = !delete_file_async x" : ()
    $"let move_file_async x = !move_file_async x" : ()
    $"let read_all_text_retry_async x = !read_all_text_retry_async x" : ()
    $"let create_temp_directory_name () = !create_temp_directory_name ()" : ()
    $"let create_temp_directory () = !create_temp_directory ()" : ()
    $"let get_source_directory () = !get_source_directory ()" : ()
    $"let find_parent x = !find_parent x" : ()
    $"let get_repository_root () = !get_repository_root ()" : ()
    inl combine x = (</>) x
    $"let (</>) x = !combine x" : ()
