#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"aliases":[],"name":"spiral"}]}}

#!markdown

# file_system

#!spiral

open sm'_operators
open rust
open rust_operators

#!spiral

//// test

open testing

#!markdown

## fsharp

#!markdown

### file_mode

#!spiral

nominal file_mode' = $'System.IO.FileMode'

union file_mode =
    | ModeCreateNew
    | ModeCreate
    | ModeOpen
    | ModeOpenOrCreate
    | Truncate
    | Append

inl file_mode = function
    | ModeCreateNew => $'System.IO.FileMode.CreateNew' : file_mode'
    | ModeCreate => $'System.IO.FileMode.Create' : file_mode'
    | ModeOpen => $'System.IO.FileMode.Open' : file_mode'
    | ModeOpenOrCreate => $'System.IO.FileMode.OpenOrCreate' : file_mode'
    | Truncate => $'System.IO.FileMode.Truncate' : file_mode'
    | Append => $'System.IO.FileMode.Append' : file_mode'

#!markdown

### file_access

#!spiral

nominal file_access' = $'System.IO.FileAccess'

union file_access =
    | AccessRead
    | AccessWrite
    | AccessReadWrite

inl file_access = function
    | AccessRead => $'System.IO.FileAccess.Read' : file_access'
    | AccessWrite => $'System.IO.FileAccess.ReadWrite' : file_access'
    | AccessReadWrite => $'System.IO.FileAccess.ReadWrite' : file_access'

#!markdown

### file_share

#!spiral

nominal file_share' = $'System.IO.FileShare'

union file_share =
    | ShareNone
    | ShareRead
    | ShareWrite
    | ShareReadWrite
    | ShareDelete

inl file_share = function
    | ShareNone => $'System.IO.FileShare.None' : file_share'
    | ShareRead => $'System.IO.FileShare.Read' : file_share'
    | ShareWrite => $'System.IO.FileShare.Write' : file_share'
    | ShareReadWrite => $'System.IO.FileShare.ReadWrite' : file_share'
    | ShareDelete => $'System.IO.FileShare.Delete' : file_share'

#!markdown

### file_stream

#!spiral

nominal file_stream' = $'System.IO.FileStream'

inl file_stream (path : string) mode access share : file_stream' =
    run_target function
        | Fsharp (Native) => fun () =>
            inl mode = mode |> file_mode
            inl access = access |> file_access
            inl share = share |> file_share
            $'new System.IO.FileStream (!path, !mode, !access, !share)'
        | _ => fun () => null ()

#!markdown

### file_info

#!spiral

nominal file_info =
    `(
        global "#if FABLE_COMPILER\ntype System_IO_FileInfo = bool\n#else\ntype System_IO_FileInfo = System.IO.FileInfo\n#endif\n"
        $'' : $'System_IO_FileInfo'
    )

inl file_info (path : string) : file_info =
    run_target function
        | Fsharp (Native) => fun () => path |> convert
        | _ => fun () => null ()

#!markdown

### directory_info

#!spiral

nominal directory_info =
    `(
        global "#if FABLE_COMPILER\ntype System_IO_DirectoryInfo = bool\n#else\ntype System_IO_DirectoryInfo = System.IO.DirectoryInfo\n#endif\n"
        $'' : $'System_IO_DirectoryInfo'
    )

inl directory_info (path : string) : directory_info =
    run_target function
        | Fsharp (Native) => fun () => path |> convert
        | _ => fun () => null ()

#!markdown

### directory_info_exists

#!spiral

inl directory_info_exists (info : directory_info) : bool =
    run_target function
        | Fsharp (Native) => fun () => info |> $'_.Exists'
        | _ => fun () => null ()

#!markdown

### directory_info_creation_time

#!spiral

inl directory_info_creation_time (info : directory_info) : date_time.date_time =
    run_target function
        | Fsharp (Native) => fun () => info |> $'_.CreationTime'
        | _ => fun () => null ()

#!markdown

### directory_info_name

#!spiral

inl directory_info_name (info : directory_info) : string =
    run_target function
        | Fsharp (Native) => fun () => info |> $'_.Name'
        | _ => fun () => null ()

#!markdown

### directory_info_full_name

#!spiral

inl directory_info_full_name (info : directory_info) : string =
    run_target function
        | Fsharp (Native) => fun () => info |> $'_.FullName'
        | _ => fun () => null ()

#!markdown

### file_attributes

#!spiral

nominal file_attributes = $'System.IO.FileAttributes'

#!markdown

### directory_info_attributes

#!spiral

let directory_info_attributes (info : directory_info) : file_attributes =
    run_target function
        | Fsharp (Native) => fun () => info |> $'_.Attributes'
        | _ => fun () => null ()

#!markdown

### file_attributes_reparse_point

#!spiral

let file_attributes_reparse_point () : file_attributes =
    run_target function
        | Fsharp (Native) => fun () => $'`file_attributes.ReparsePoint'
        | _ => fun () => null ()

#!markdown

### file_attributes_has_flag

#!spiral

let file_attributes_has_flag (flag : file_attributes) (file_attributes : file_attributes) : bool =
    run_target function
        | Fsharp (Native) => fun () => $'!file_attributes.HasFlag !flag '
        | _ => fun () => null ()

#!markdown

### create_directory

#!spiral

let create_directory (path : string) : directory_info =
    run_target function
        | Fsharp (Native) => fun () => path |> $'System.IO.Directory.CreateDirectory'
        | _ => fun () => null ()

#!markdown

### directory_get_files

#!spiral

let directory_get_files (path : string) : array_base string =
    run_target function
        | Fsharp (Native) => fun () => path |> $'System.IO.Directory.GetFiles'
        | _ => fun () => null ()

#!markdown

### file_move

#!spiral

let file_move (new_path : string) (old_path : string) : () =
    run_target function
        | Fsharp (Native) => fun () => $'System.IO.File.Move (!old_path, !new_path)'
        | _ => fun () => ()

#!markdown

### read_all_text_async

#!spiral

let read_all_text_async (path : string) : _ string =
    run_target function
        | Fsharp (Native) => fun () => path |> $'System.IO.File.ReadAllTextAsync' |> async.await_task
        | _ => fun () => null ()

#!markdown

### write_all_text_async

#!spiral

let write_all_text_async (path : string) (text : string) : _ () =
    run_target function
        | Fsharp (Native) => fun () => $'System.IO.File.WriteAllTextAsync (!path, !text)' |> async.await_task
        | _ => fun () => null ()

#!markdown

### file_system_info

#!spiral

nominal file_system_info = $'System.IO.FileSystemInfo'

#!markdown

### get_source_directory

#!spiral

inl get_source_directory () =
    $'__SOURCE_DIRECTORY__' : string

#!spiral

//// test

get_source_directory ()
|> directory_info
|> directory_info_name
|> _assert_eq "spiral"

#!markdown

## rust

#!markdown

### display

#!spiral

nominal display =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::path::Display\")>]\ntype std_path_Display = class end\n#else\ntype std_path_Display = string\n#endif\n"
        $'' : $'std_path_Display'
    )

#!markdown

### path

#!spiral

nominal path =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::path::Path\")>]\n#endif\ntype std_path_Path = class end"
        $'' : $'std_path_Path'
    )

#!markdown

### path_buf

#!spiral

nominal path_buf =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::path::PathBuf\")>]\ntype std_path_PathBuf = class end\n#else\ntype std_path_PathBuf = string\n#endif\n"
        $'' : $'std_path_PathBuf'
    )

#!markdown

### new_path_buf

#!spiral

inl new_path_buf (path : sm'.std_string) : path_buf =
    run_target function
        | Rust _ => fun () => !\\(path, $'"std::path::PathBuf::from($0)"')
        | _ => fun () => path |> unbox

#!markdown

### path_buf_from

#!spiral

inl path_buf_from (path : rust.box path) : path_buf =
    !\\(path, $'"std::path::PathBuf::from($0)"')

#!markdown

### path_buf_join

#!spiral

inl path_buf_join (s : string) (path_buf : path_buf) : path_buf =
    !\\((path_buf, s |> sm'.to_std_string), $'"$0.join($1)"')

#!markdown

### path_buf_strip_prefix

#!spiral

inl path_buf_strip_prefix (s : string) (path_buf : path_buf) : path_buf =
    !\\((path_buf, s |> sm'.to_std_string), $'"$0.strip_prefix($1).unwrap().to_path_buf()"')

#!markdown

### path_display

#!spiral

inl path_display (path : rust.ref path) : display =
    !\\(path, $'"$0.display()"')

#!markdown

### path_buf_display

#!spiral

inl path_buf_display (path_buf : path_buf) : display =
    run_target_args (fun () => path_buf) function
        | Rust _ => fun path_buf => !\\(path_buf, $'"$0.display()"')
        | _ => fun path_buf => path_buf |> unbox

#!markdown

### path_buf_file_name

#!spiral

inl path_buf_file_name (path : path_buf) : optionm'.option' (rust.ref sm'.os_str) =
    !\\(path, $'"$0.file_name()"')

#!markdown

### path_buf_exists

#!spiral

inl path_buf_exists (path_buf : path_buf) : bool =
    !\\(path_buf, $'"$0.exists()"')

#!markdown

### path_buf_is_dir

#!spiral

inl path_buf_is_dir (path_buf : path_buf) : bool =
    !\\(path_buf, $'"$0.is_dir()"')

#!markdown

### path_buf_is_file

#!spiral

inl path_buf_is_file (path_buf : path_buf) : bool =
    !\\(path_buf, $'"$0.is_file()"')

#!markdown

### path_buf_is_symlink

#!spiral

inl path_buf_is_symlink (path_buf : path_buf) : bool =
    !\\(path_buf, $'"$0.is_symlink()"')

#!markdown

### path_buf_parent

#!spiral

inl path_buf_parent (path_buf : path_buf) : optionm'.option' path_buf =
    !\\(path_buf, $'"$0.parent().map(std::path::PathBuf::from)"')

#!markdown

### dir_entry

#!spiral

nominal dir_entry =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"async_walkdir::DirEntry\")>]\n#endif\ntype async_walkdir_DirEntry = class end"
        $'' : $'async_walkdir_DirEntry'
    )

#!markdown

### walk_dir

#!spiral

nominal walk_dir =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"async_walkdir::WalkDir\")>]\n#endif\ntype async_walkdir_WalkDir = class end"
        $'' : $'async_walkdir_WalkDir'
    )

#!markdown

### async_walkdir_filtering

#!spiral

nominal async_walkdir_filtering =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"async_walkdir::Filtering\")>]\n#endif\ntype async_walkdir_Filtering = class end"
        $'' : $'async_walkdir_Filtering'
    )

#!markdown

### filtering

#!spiral

union filtering =
    | Ignore
    | IgnoreDir
    | Continue

#!markdown

### async_walkdir_error

#!spiral

nominal async_walkdir_error =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"async_walkdir::Error\")>]\n#endif\ntype async_walkdir_Error = class end"
        $'' : $'async_walkdir_Error'
    )

#!markdown

### new_walk_dir

#!spiral

inl new_walk_dir (dir : string) : walk_dir =
    !\\(dir, $'"async_walkdir::WalkDir::new(&*$0)"')
    // inl walk_dir : walk_dir = walk_dir |> rust.to_mut
    // (!\($'"true; let mut !walk_dir = !walk_dir"') : bool) |> ignore

#!markdown

### walk_dir_filter

#!spiral

inl walk_dir_filter (fn : dir_entry -> async.future_pin_send filtering) (walk_dir : walk_dir) : walk_dir =
    inl fn entry = async.new_future_send fun () =>
        inl result = fn entry |> async.await_send
        inl filtering : async_walkdir_filtering =
            match result with
            | Ignore => !\($'"async_walkdir::Filtering::Ignore"')
            | IgnoreDir => !\($'"async_walkdir::Filtering::IgnoreDir"')
            | Continue => !\($'"async_walkdir::Filtering::Continue"')
        filtering
    !\\((walk_dir, fn), $'"async_walkdir::WalkDir::filter($0, move |x| $1(x))"')

#!markdown

### file_type

#!spiral

nominal file_type =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::fs::FileType\")>]\n#endif\ntype std_fs_FileType = class end"
        $'' : $'std_fs_FileType'
    )

#!markdown

### dir_entry_file_type

#!spiral

inl dir_entry_file_type (dir_entry : dir_entry) : async.future_pin_send (resultm.result' file_type stream.io_error) =
    inl dir_entry = dir_entry |> rust.emit
    !\($'"Box::pin(async_walkdir::DirEntry::file_type(&!dir_entry))"')

#!markdown

### file_type_is_dir

#!spiral

inl file_type_is_dir (file_type : file_type) : bool =
    !\\(file_type, $'"std::fs::FileType::is_dir(&$0)"')

#!markdown

### file

#!spiral

nominal file =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::fs::File\")>]\n#endif\ntype std_fs_File = class end"
        $'' : $'std_fs_File'
    )

#!markdown

### file_open

#!spiral

inl file_open (path : string) : resultm.result' file stream.io_error =
    !\($'"std::fs::File::open(&*!path)"')

#!markdown

### rename

#!spiral

inl rename (to : string) (path : string) : resultm.result' () stream.io_error =
    !\($'"std::fs::rename(&*!path, &*!to)"')

#!markdown

### dir_entry_path

#!spiral

inl dir_entry_path (dir_entry : dir_entry) : path_buf =
    !\\(dir_entry, $'"async_walkdir::DirEntry::path(&$0)"')

#!markdown

### create_dir_all

#!spiral

inl create_dir_all (path : string) : resultm.result' () stream.io_error =
    !\\(path, $'"std::fs::create_dir_all(&*$0)"')

#!markdown

### file_info_link_target

#!spiral

inl file_info_link_target (file_info : file_info) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            file_info |> $'_.LinkTarget'
        | _ => fun () => null ()

#!markdown

### read

#!spiral

inl read (path : string) : resultm.result' (am'.vec u8) stream.io_error =
    !\\(path, $'"std::fs::read(&*$0)"')

#!markdown

## typescript

#!markdown

### ts_path_join

#!spiral

inl ts_path_join (b : string) (a : string) : string =
    open typescript_operators
    global "type IPathJoin = abstract join: [<System.ParamArray>] paths: string[] -> string"
    inl path : $'IPathJoin' = typescript.import_all "path"
    !\\((a, b), $'"!path.join($0, $1)"')

#!markdown

## file_system

#!markdown

### (< />)

#!spiral

let (</>) (a : string) (b : string) : string =
    run_target_args (fun () => a, b) function
        | Rust (Contract) => fun _ => null ()
        | Rust (Native) => fun a, b =>
            a
            |> sm'.to_std_string
            |> new_path_buf
            |> path_buf_join b
            |> path_buf_display
            |> sm'.format'
            |> sm'.from_std_string
        | TypeScript (Native) => fun a, b =>
            a |> ts_path_join b
        | Fsharp (Native) => fun a, b =>
            $'System.IO.Path.Combine (!a, !b)'
        | target => fun a, b => failwith $'$"file_system.(</>) / target: {!target} / a: {!a} / b: {!b}"'

#!markdown

### get_temp_path

#!spiral

let get_temp_path () : string =
    run_target function
        | Rust (Contract) => fun () => null ()
        | Rust (Native) => fun () =>
            !\($'"std::env::temp_dir()"')
            |> path_buf_display
            |> sm'.format'
            |> sm'.from_std_string
        | Fsharp (Native) => fun () =>
            $'System.IO.Path.GetTempPath' ()
        | target => fun () => failwith $'$"file_system.get_temp_path / target: {!target}"'

#!markdown

### get_file_name

#!spiral

let get_file_name (path : string) : string =
    run_target_args' path function
        | Fsharp (Native) => fun path =>
            path |> $'System.IO.Path.GetFileName'
        | Rust (Native) => fun path =>
            path
            |> sm'.to_std_string
            |> new_path_buf
            |> path_buf_file_name
            |> optionm'.map' sm'.from_os_str_ref
            |> optionm'.unbox
            |> optionm'.default_value ""
        | Rust (Contract) => fun _ => null ()
        | target => fun path => failwith $'$"file_system.get_file_name / target: {!target} / path: {!path}"'

#!markdown

### get_file_name_without_extension

#!spiral

let get_file_name_without_extension (path : string) : string =
    run_target_args' path function
        | Rust (Contract) => fun _ => null ()
        | Rust (Native) => fun path =>
            inl path_buf = path |> sm'.to_std_string |> new_path_buf
            inl file_stem = !\\(path_buf, $'"$0.file_stem()"')
            match file_stem |> optionm'.map' sm'.from_os_str_ref |> optionm'.unbox with
            | Some file_stem => file_stem
            | None => ""
        | _ => fun path =>
            path |> $'System.IO.Path.GetFileNameWithoutExtension'

#!markdown

### get_directory_name

#!spiral

let get_directory_name (path : string) : string =
    run_target_args' path function
        | Fsharp _ => fun path =>
            path |> $'System.IO.Path.GetDirectoryName'
        | Rust (Native) => fun path =>
            path
            |> sm'.to_std_string
            |> new_path_buf
            |> path_buf_file_name
            |> optionm'.map' sm'.from_os_str_ref
            |> optionm'.unbox
            |> optionm'.default_value ""
        | _ => fun _ => null ()

#!markdown

### get_extension

#!spiral

let get_extension (path : string) : string =
    run_target_args' path function
        | Rust (Contract) => fun _ => null ()
        | Rust (Native) => fun path =>
            inl path_buf = path |> sm'.to_std_string |> new_path_buf
            !\\(path_buf, $'"$0.extension()"')
            |> optionm'.unwrap
            |> sm'.from_os_str_ref
        | _ => fun path =>
            path |> $'System.IO.Path.GetExtension'

#!markdown

### directory_separator_char

#!spiral

let directory_separator_char () : char =
    run_target function
        | Rust (Native) => fun () => !\($'"std::path::MAIN_SEPARATOR"')
        | _ => fun () => $'System.IO.Path.DirectorySeparatorChar'

#!markdown

### get_current_directory

#!spiral

let get_current_directory () : string =
    run_target function
        | Rust (Contract | Wasm) => fun () => null ()
        | Rust (Native) => fun () =>
            inl current_dir = !\($'"std::env::current_dir()"') : resultm.result' path_buf stream.io_error
            current_dir
            |> resultm.unwrap'
            |> path_buf_display
            |> sm'.format'
            |> sm'.from_std_string
        | Fsharp (Native) => fun () =>
            $'System.IO.Directory.GetCurrentDirectory' ()
        | _ => fun () => null ()

#!spiral

//// test

get_current_directory ()
|> _assert_contains (directory_separator_char ())

#!markdown

### directory_exists

#!spiral

let directory_exists (path : string) : bool =
    run_target_args' path function
        | Fsharp (Native) => fun path =>
            path |> $'System.IO.Directory.Exists'
        | Rust (Native) => fun path =>
            inl path = path |> sm'.to_std_string |> new_path_buf
            path_buf_exists path && path_buf_is_dir path
        | TypeScript (Native) => fun path =>
            global "type IFsExistsSync = abstract existsSync: path: string -> bool"
            open typescript_operators
            inl fs : $'IFsExistsSync' = typescript.import_all "fs"
            !\\((fs, path), $'"$0.existsSync($1)"')
        | _ => fun _ => null ()

#!markdown

### directory_get_parent

#!spiral

let directory_get_parent (path : string) : optionm'.option' string =
    run_target_args' path function
        | Fsharp (Native) => fun path =>
            inl parent : directory_info = path |> $'System.IO.Directory.GetParent'
            if parent =. null ()
            then None
            else parent |> directory_info_full_name |> Some
            |> optionm'.box
        | Rust (Native) => fun path =>
            inl path_buf = path |> sm'.to_std_string |> new_path_buf
            inl parent = path_buf |> path_buf_parent
            parent
            |> optionm'.map' (path_buf_display >> sm'.format' >> sm'.from_std_string)
        | TypeScript _ => fun path =>
            open typescript_operators
            global "type IPathDirname = abstract dirname: path: string -> string"
            inl fs : $'IPathDirname' = typescript.import_all "path"
            !\\(path, $'"!fs.dirname($0)"') |> Some |> optionm'.box
        | _ => fun _ => null ()

#!markdown

### create_temp_path'

#!spiral

let create_temp_path' (guid : guid.guid) =
    run_target_args' guid function
        | Rust (Contract) => fun _ => null ()
        | _ => fun guid =>
            get_temp_path ()
            </> join "!create_temp_path_"
            </> (env.get_entry_assembly_name ())
            </> (guid |> sm'.obj_to_string)

#!spiral

//// test
///! fsharp
///! rust -d chrono

guid.hash_guid ""
|> create_temp_path'
|> _assert_contains (directory_separator_char ())

#!markdown

### create_temp_path

#!spiral

let create_temp_path () =
    run_target function
        | Rust (Contract) => fun () => null ()
        | _ => fun () =>
            date_time.now ()
            |> date_time.new_guid_from_date_time
            |> create_temp_path'

#!markdown

### file_copy

#!spiral

let file_copy (new_path : string) (old_path : string) : () =
    run_target_args' (old_path, new_path) function
        | Fsharp (Native) => fun old_path, new_path =>
            $'System.IO.File.Copy (!old_path, !new_path, true)'
        | Rust (Native) => fun old_path, new_path =>
            inl result : _ _ stream.io_error = !\\((old_path, new_path), $'"std::fs::copy(&*$0, &*$1)"')
            match result |> resultm.map_error' sm'.format' |> resultm.unbox with
            | Ok (result : u64) =>
                trace Debug
                    fun () => "file_system.file_copy"
                    fun () => { old_path new_path result }
            | Error error =>
                trace Warning
                    fun () => "file_system.file_copy"
                    fun () => { old_path new_path error }
        | _ => fun _ => ()

#!markdown

### file_exists

#!spiral

let file_exists (path : string) : bool =
    run_target_args' path function
        | Fsharp (Native) => fun path =>
            path |> $'System.IO.File.Exists'
        | Rust (Native) => fun path =>
            inl path_buf = path |> sm'.to_std_string |> new_path_buf
            path_buf_exists path_buf && path_buf_is_file path_buf
        | TypeScript (Native) => fun path =>
            open typescript_operators
            global "type IFsExistsSync = abstract existsSync: path: string -> bool"
            inl fs : $'IFsExistsSync' = typescript.import_all "fs"
            !\\((fs, path), $'"$0.existsSync($1)"')
        | _ => fun _ => null ()

#!markdown

### directory_delete

#!spiral

let directory_delete recursive (path : string) : () =
    run_target_args' (path, recursive) function
        | Fsharp (Native) => fun path, recursive =>
            $'System.IO.Directory.Delete (!path, !recursive)'
        | Rust (Native) => fun path, recursive =>
            if path |> directory_exists then
                if recursive
                then !\\(path, $'"std::fs::remove_dir_all(&*$0).unwrap()"')
                else !\\(path, $'"std::fs::remove_dir(&*$0).unwrap()"')
        | _ => fun _ => ()

#!markdown

### write_all_text

#!spiral

inl write_all_text (path : string) (text : string) : () =
    run_target_args' (path, text) function
        | Fsharp (Native) => fun path, text =>
            $'System.IO.File.WriteAllText (!path, !text)'
        | Rust (Native) => fun path, text =>
            !\\((path, text), $'"std::fs::write(&*$0, &*$1).unwrap()"')
        | _ => fun _ => ()

#!markdown

### read_all_bytes

#!spiral

inl read_all_bytes (path : string) : am'.vec u8 =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!path |> System.IO.File.ReadAllBytes'
            |> am'.to_vec
        | Rust (Native) => fun () =>
            path |> read |> resultm.unwrap'
        | _ => fun () => null ()

#!markdown

### read_all_text

#!spiral

inl read_all_text (path : string) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            $'!path |> System.IO.File.ReadAllText'
        | Rust (Native) => fun () =>
            path
            |> read_all_bytes
            |> sm'.string_from_utf8
            |> resultm.unwrap'
            |> sm'.from_std_string
        | _ => fun () => null ()

#!markdown

### directory_create_symbolic_link

#!spiral

inl directory_create_symbolic_link (target : string) (path : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            ($'System.IO.Directory.CreateSymbolicLink (!path, !target)' : file_system_info)
            |> ignore
        | Rust (Native) => fun () =>
            (!\\((target, path), $'"true; #[cfg(windows)] std::os::windows::fs::symlink_dir(&*$0, &*$1).unwrap()"') : bool) |> ignore
            (!\\((target, path), $'"true; #[cfg(unix)] std::os::unix::fs::symlink(&*$0, &*$1).unwrap()"') : bool) |> ignore
        | _ => fun () => ()

#!markdown

### file_create_symbolic_link

#!spiral

inl file_create_symbolic_link (target : string) (path : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            ($'System.IO.File.CreateSymbolicLink (!path, !target)' : file_system_info)
            |> ignore
        | Rust (Native) => fun () =>
            (!\\((target, path), $'"true; #[cfg(windows)] std::os::windows::fs::symlink_file(&*$0, &*$1).unwrap()"') : bool) |> ignore
            (!\\((target, path), $'"true; #[cfg(unix)] std::os::unix::fs::symlink(&*$0, &*$1).unwrap()"') : bool) |> ignore
        | _ => fun () => ()

#!markdown

### file_type

#!spiral

union file_type =
    | File
    | Directory

#!markdown

### find_parent

#!spiral

inl find_parent file_type name root_dir =
    inl is_file = file_type = File
    let rec loop dir =
        if dir </> name |> (if is_file then file_exists else directory_exists)
        then dir |> Ok
        else
            inl result = dir |> directory_get_parent
            match result |> optionm'.unbox with
            | Some parent => parent |> loop
            | None => ($'$"""No parent for {if !is_file then "file" else "dir"} \'{!name}\' at \'{!root_dir}\' (until \'{!dir}\')"""' : string) |> Error
    loop root_dir

#!spiral

//// test

a ;[ Directory, ".paket"; File, "paket.dependencies" ]
|> am.map fun file_type, file =>
    get_source_directory ()
    |> find_parent file_type file
    |> resultm.get
    |> directory_info
    |> directory_info_name
|> am'.distinct
|> fun (a x : _ int _) => x
|> _assert_eq' ;[ "polyglot" ]

#!spiral

//// test
///! rust

a ;[ Directory, ".paket"; File, "paket.dependencies" ]
|> am.map fun file_type, file =>
    fun () =>
        join
            get_source_directory ()
            |> find_parent file_type file
            |> resultm.get
            |> sm'.to_std_string
            |> new_path_buf
            |> path_buf_file_name
            |> optionm'.try'
            |> sm'.from_os_str_ref
            |> Some
            |> optionm'.box
    |> fun x => x () |> optionm'.unbox
    |> optionm'.default_value ""
|> am'.distinct
|> fun result =>
    result |> am'.length |> _assert_eq 1i32
    index result 0i32 |> _assert_eq "polyglot"

#!markdown

### get_workspace_root

#!spiral

inl get_workspace_root () =
    (None, [ get_source_directory; get_current_directory ])
    ||> listm.fold fun acc path =>
        match acc with
        | Some path => Some path
        | None =>
            path ()
            |> find_parent Directory ("polyglot" </> "workspace")
            |> function
                | Ok path => Some path
                | Error error =>
                    trace Warning
                        fun () => "file_system.get_workspace_root"
                        fun () => { error }
                    None
    |> optionm.value
    |> fun root => root </> "polyglot"

#!markdown

### get_workspace_root_external

#!spiral

inl get_workspace_root_external () =
    inl workspace_root = get_workspace_root ()
    inl current_dir = get_current_directory () |> sm'.to_lower
    inl workspace_root = workspace_root |> sm'.to_lower
    if current_dir |> sm'.starts_with workspace_root
    then Error workspace_root
    else Ok workspace_root

#!spiral

//// test

get_workspace_root_external ()
|> resultm.unwrap_err
|> get_file_name
|> _assert_eq "polyglot"

#!markdown

### file_delete

#!spiral

inl file_delete (path : string) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            path |> $'System.IO.File.Delete'
        | Rust (Native) => fun () =>
            inl result : resultm.result' () stream.io_error =
                !\\(path, $'"std::fs::remove_file(&*$0)"')
            match result |> resultm.map_error' sm'.format |> resultm.unbox with
            | Ok () => ()
            | Error error' => trace Critical (fun () => "file_system.file_delete") fun () => { error' }
        | _ => fun () => ()

#!markdown

### read_link

#!spiral

let read_link (path : string) : resultm.result' path_buf stream.io_error =
    let run loop n error path' =
        inl name = path' |> get_file_name
        inl parent = path' |> directory_get_parent |> optionm'.unbox
        inl error'' = error |> sm'.format
        match parent with
        | _ when n >= 11 =>
            ($'$"file_system.read_link / "' : string)
            +. $'$"path: {!path} / n: {!n} / path\': {!path'} / name: {!name}"'
            |> stream.new_io_error
            |> resultm.err
        | Some parent when path' <>. "" =>
            match loop (n + 1) parent |> resultm.map_error' sm'.format |> resultm.unbox with
            | Ok parent' =>
                (parent' |> path_buf_display |> convert) </> name
                |> sm'.to_std_string
                |> new_path_buf
                |> resultm.ok''
            | Error error' =>
                ($'$"file_system.read_link / "' : string)
                +. $'$"error\': {!error'} / error: {!error''} / name: {!name}"'
                |> stream.new_io_error
                |> resultm.err
        | _ =>
            ($'$"file_system.read_link / run / The file or directory is not a reparse point. / "' : string)
            +. $'$"path: {!path} / error: {!error''} / path\': {!path'} / name: {!name}"'
            |> stream.new_io_error
            |> resultm.err

    run_target function
        | Rust _ => fun () =>
            if path |> directory_exists
            then !\\(path, $'"std::fs::read_link(&*$0)"')
            else
                let rec loop n path' =
                    run_target function
                        | Rust _ => fun () =>
                            inl result : _ _ stream.io_error = !\\(path', $'"std::fs::read_link(&*$0)"')
                            inl result = result |> resultm.map_error' sm'.format |> resultm.unbox
                            match result with
                            | Ok x => x |> resultm.ok''
                            | Error error => path' |> run loop n error
                        | _ => fun () => null ()
                path |> loop 0u8
        | TypeScript _ => fun () => null ()
        | Fsharp _ => fun () =>
            let rec loop n path' =
                inl result =
                    path'
                    |> directory_info
                    |> directory_info_attributes
                    |> file_attributes_has_flag (file_attributes_reparse_point ())
                if result then
                    path'
                    |> file_info
                    |> file_info_link_target
                    |> unbox
                    |> resultm.ok''
                else
                    inl error =
                        ($'$"file_system.read_link / Fsharp / "' : string)
                        +. $'$"The file or directory is not a reparse point. / "'
                        +. $'$"path: {!path} / result: {!result} / path\': {!path'} / n: {!n}"'
                        |> stream.new_io_error
                    path' |> run loop n error
            path |> loop 0u8
        | _ => fun () => $'Unchecked.defaultof<_>'

#!markdown

### normalize_path

#!spiral

let normalize_path (path : string) : string =
    if path = ""
    then ""
    else
        inl path =
            match path |> read_link |> resultm.ok' |> optionm'.unbox with
            | Some path_buf =>
                inl result =
                    path_buf
                    |> path_buf_display
                    |> convert
                if result = ""
                then path
                else result
            | None => path
        if path = ""
        then ""
        else
            inl path = path |> sm'.replace_regex @"^\\\\\?\\" ""
            $'$"{!path.[0] |> string |> _.ToLower()}{!path.[1..]}"' |> sm'.replace "\\" "/"

#!markdown

### get_full_path

#!spiral

let get_full_path (path : string) : string =
    run_target_args (fun () => path) function
        | Fsharp (Native) => fun path =>
            path |> $'System.IO.Path.GetFullPath'
        | Rust (Native) => fun path =>
            inl path_buf = path |> sm'.to_std_string |> new_path_buf
            if path_buf |> path_buf_exists |> not then
                inl current_dir = get_current_directory ()
                current_dir </> path
                |> normalize_path
                |> sm'.split "/"
                |> fun x =>
                    ((a x : _ i32 _), (0i32, (a ;[] : _ i32 _)))
                    ||> am.foldBack fun x level, acc =>
                        match x, level with
                        | "..", _ => level + 1, acc
                        | ".", _ => level, acc
                        | _, 0 when x |> sm'.ends_with ":" => 0, a ;[ $'$"{!current_dir.[0]}:"' ] ++ acc
                        | _, 0 => 0, a ;[ x ] ++ acc
                        | _ => level - 1, acc
                |> snd
                |> seq.of_array'
                |> sm'.concat (directory_separator_char () |> sm'.obj_to_string)
            else
                inl path = !\\(path, $'"std::fs::canonicalize(&*$0)"') : resultm.result' path_buf stream.io_error
                path
                |> resultm.unwrap'
                |> path_buf_display
                |> sm'.format'
                |> sm'.from_std_string
        | _ => fun _ => null ()

#!spiral

//// test

"."
|> get_full_path
|> directory_info
|> directory_info_name
|> _assert_eq "spiral"

#!spiral

//// test

"dir/.././._file"
|> get_full_path
|> _assert_eq (get_current_directory () </> "._file")

#!spiral

//// test
///! rust -d regex

"."
|> get_full_path
|> sm'.to_std_string
|> new_path_buf
|> path_buf_file_name
|> optionm'.unwrap
|> sm'.from_os_str_ref
|> _assert_eq "spiral"

#!spiral

//// test
///! rust -d regex

"dir/.././._file"
|> get_full_path
|> _assert_eq (get_current_directory () </> "._file")

#!markdown

### standardize_path

#!spiral

let standardize_path path =
    path |> get_full_path |> normalize_path

#!markdown

### absolute_path

#!spiral

let absolute_path path =
    inl current_dir = get_current_directory ()
    current_dir </> path |> standardize_path

#!markdown

### new_file_uri

#!spiral

inl new_file_uri (path : string) : string =
    inl path = path |> sm'.trim_start [ '/' ]
    $'$"file:///{!path}"'

#!spiral

//// test

@"\\?\C:\test"
|> normalize_path
|> new_file_uri
|> _assert_eq "file:///c:/test"

#!spiral

//// test
///! rust -d regex

@"\\?\C:\test"
|> normalize_path
|> new_file_uri
|> _assert_eq "file:///c:/test"

#!markdown

## fsharp

#!markdown

### file_exists_content_async

#!spiral

let file_exists_content_async path content : async.async bool =
    run_target function
        | Fsharp (Native) => fun () =>
            fun () =>
                fix_condition
                    fun () => path |> file_exists |> not
                    fun () => false |> return
                    fun () =>
                        inl existing_content = path |> read_all_text_async |> async.let'
                        content = existing_content |> return
            |> async.new_async_unit
        | _ => fun () => null ()

#!markdown

### write_all_text_exists_async

#!spiral

let write_all_text_exists_async path contents =
    fun () =>
        inl exists' = contents |> file_exists_content_async path |> async.let'
        if not exists'
        then contents |> write_all_text_async path |> async.do
    |> async.new_async

#!markdown

### delete_directory_async

#!spiral

let delete_directory_async path : _ i64 =
    let rec loop (retry : i64) =
        run_target function
            | Fsharp (Native) => fun () =>
                fun () =>
                    try_unit
                        fun () =>
                            path |> directory_delete true
                            retry |> return
                        fun ex =>
                            if retry % 100i64 = 0 then
                                trace Debug
                                    fun () => "file_system.delete_directory_async"
                                    fun () => {
                                        ex = ex () |> sm'.format_exception
                                        path = path |> get_file_name
                                    }
                            async.sleep 10i32 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async
            | _ => fun () => null ()
    loop 0

#!markdown

### trace_file

#!spiral

let rec trace_file text =
    run_target function
    | Fsharp (Native) => fun () =>
        try_unit
            fun () =>
                inl assembly_name = env.get_entry_assembly_name ()
                inl guid = date_time.now () |> date_time.new_guid_from_date_time
                inl file_name = $'$"{!assembly_name}_{!guid}.txt"'

                inl workspace_root = get_workspace_root ()
                inl trace_dir = workspace_root </> "target/trace"
                trace_dir |> create_directory |> ignore
                inl path = trace_dir </> file_name
                text |> write_all_text_async path |> async.run_synchronously
            fun ex =>
                inl text = $'$"file_system.trace_file / ex: %A{!ex}"'
                text |> console.write_line
                text |> trace_file
    | _ => fun () => ()

#!spiral

//// test

inl get_count dir : i64 =
    inl files = dir |> directory_get_files
    a files |> am'.length

inl trace_dir = get_workspace_root () </> "target/trace"
trace_dir |> create_directory |> ignore

inl count = get_count trace_dir

trace_file "test"

get_count trace_dir
|> _assert_eq (count + 1)

#!markdown

### init_trace_file

#!spiral

inl init_trace_file enabled =
    inl state_trace_file = get_trace_state_or_init None .trace_file
    state_trace_file <- if enabled then trace_file else ignore

#!markdown

## file_system

#!markdown

### create_dir

#!spiral

let create_dir dir =
    run_target_args' dir function
        | Rust (Contract | Wasm) => fun _ => null ()
        | Rust (Native) => fun dir =>
            match dir |> create_dir_all |> resultm.map_error' sm'.format' |> resultm.unbox with
            | Ok () =>
                trace Verbose
                    fun () => "file_system.create_dir"
                    fun () => { dir }
            | Error error =>
                trace Critical
                    fun () => "file_system.create_dir"
                    fun () => { dir error }
            inl disposable : _ () = new_disposable fun () =>
                dir
                |> directory_delete true
            disposable
        | _ => fun dir =>
            inl directory_info = dir |> create_directory
            inl exists' = directory_info |> directory_info_exists
            if not exists' then
                inl creation_time = directory_info |> directory_info_creation_time
                inl result = ($'{| Exists = !exists'; CreationTime = !creation_time |}' : infer) |> sm'.format_debug
                trace Debug
                    fun () => "file_system.create_dir"
                    fun () => { dir result }
            inl disposable : _ () = new_disposable fun () =>
                dir
                |> delete_directory_async
                |> async.ignore
                |> async.run_synchronously
            disposable

#!markdown

### create_temp_dir

#!spiral

inl create_temp_dir () =
    inl dir = create_temp_path ()
    dir, dir |> create_dir

#!spiral

//// test
///! fsharp
///! rust -d chrono

inl path, disposable = create_temp_dir ()
join
    path
    |> directory_exists
    |> _assert_eq true
    disposable |> use |> ignore
    path
    |> directory_exists
    |> _assert_eq true
path
|> directory_exists
|> _assert_eq false

#!spiral

//// test
//// timeout=30000

inl lock_directory path =
    fun () =>
        trace Debug (fun () => "_1") id
        "0" |> write_all_text_async (path </> "test.txt") |> async.do
        file_stream
            (path </> "test.txt")
            ModeOpen
            AccessReadWrite
            ShareNone
        |> use
        |> ignore
        trace Debug (fun () => "_2") id
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") id
        () |> return
    |> async.new_async

inl temp_dir, disposable = create_temp_dir ()
disposable |> use |> ignore
inl path = temp_dir </> "test"

fun () =>
    trace Debug (fun () => "1") id
    path |> create_directory |> ignore
    trace Debug (fun () => "2") id
    inl child = path |> lock_directory |> async.start_child |> async.let'
    trace Debug (fun () => "3") id
    async.sleep 60 |> async.do
    trace Debug (fun () => "4") id
    inl retries = path |> delete_directory_async |> async.let'
    trace Debug (fun () => "5") id
    child |> async.do
    trace Debug (fun () => "6") id
    retries |> return
|> async.new_async_unit
|> async.run_with_timeout 3000
|> fun x => x : _ i64
|> function
    | Some (retries : i64) =>
        retries
        |> _assert_between
            (if platform.is_windows () then 50 else 0)
            (if platform.is_windows () then 180 else 0)

        true
    | _ => false
|> _assert_eq true

#!markdown

### create_temp_dir'

#!spiral

inl create_temp_dir' (hash : string) =
    inl dir = hash |> guid.hash_guid |> create_temp_path'
    dir, dir |> create_dir

#!markdown

### link_directory

#!spiral

let link_directory target_path path =
    if target_path |> directory_exists |> not
    then target_path |> create_dir |> ignore

    inl lib_dir_path = path |> directory_get_parent |> optionm'.default_value' ""
    if lib_dir_path |> directory_exists |> not
    then lib_dir_path |> create_dir |> ignore

    if (path |> directory_exists)
        && (path |> read_link |> resultm.is_err) then
        path |> directory_delete true

    if path |> directory_exists |> not then
        path |> directory_create_symbolic_link target_path

#!markdown

### link_file

#!spiral

let link_file target_path path =
    if (path |> file_exists)
        && (path |> read_link |> resultm.is_err) then
        path |> file_delete

    if path |> file_exists |> not then
        path |> file_create_symbolic_link target_path

#!spiral

//// test
///! fsharp
///! rust -d sha2 regex

inl file_name = "LICENSE"
inl text = file_name

inl test_hash =
    (file_name, text)
    |> sm'.format_debug
    |> crypto.hash_text

inl workspace_root = get_workspace_root ()
inl test_dir = workspace_root </> "target/test/file_system" </> test_hash

inl disposable = test_dir |> create_dir
disposable |> use |> ignore

inl dir_path = test_dir </> "dir1"

if dir_path |> directory_exists
then dir_path |> directory_delete true

dir_path |> create_dir |> ignore

inl path = dir_path </> file_name
text |> write_all_text path

inl dir_link_path = test_dir </> "link1"

dir_link_path |> link_directory dir_path

inl link_path = dir_link_path </> file_name

link_path
|> read_all_text
|> _assert_eq text

dir_link_path
|> read_link
|> resultm.unwrap'
|> path_buf_display
|> convert
|> _assert sm'.ends_with "dir1"

link_path
|> read_link
|> resultm.unwrap'
|> path_buf_display
|> convert
|> _assert sm'.ends_with "LICENSE"

inl link_name = "LICENSE_"

inl link_path = dir_path </> link_name

link_path |> link_file path

inl link_path' = dir_link_path </> link_name

link_path'
|> read_all_text
|> _assert_eq text

link_path
|> read_link
|> resultm.unwrap'
|> path_buf_display
|> convert
|> _assert sm'.ends_with "LICENSE"

link_path'
|> read_link
|> resultm.unwrap'
|> path_buf_display
|> convert
|> _assert sm'.ends_with "LICENSE"

#!markdown

## rust

#!markdown

### file_exists_content

#!spiral

let file_exists_content path content : bool =
    run_target function
        | Rust (Native) => fun () =>
            if path |> file_exists |> not
            then false
            else
                inl existing_content = path |> read_all_text
                content = existing_content
        | _ => fun () => null ()

#!markdown

### write_all_text_exists

#!spiral

let write_all_text_exists path contents =
    inl exists' = contents |> file_exists_content path
    if not exists' then
        inl dir = path |> directory_get_parent |> optionm'.default_value' ""
        if dir |> directory_exists |> not
        then dir |> create_dir |> ignore
        contents |> write_all_text path

#!markdown

## fsharp

#!markdown

### wait_for_file_access

#!spiral

let wait_for_file_access access path =
    let rec loop (retry : i64) : _ i64 =
        run_target function
            | Fsharp (Native) => fun () =>
                inl file_access, file_share =
                    access
                    |> optionm'.default_value (AccessReadWrite, ShareRead)
                fun () =>
                    try_unit
                        fun () =>
                            file_stream
                                path
                                ModeOpen
                                file_access
                                file_share
                            |> use
                            |> ignore
                            retry |> return
                        fun ex =>
                            if retry > 0 && retry % 100i64 = 0 then
                                trace Debug
                                    fun () => "file_system.wait_for_file_access"
                                    fun () => {
                                        path = path |> get_file_name
                                        retry
                                        ex = ex () |> sm'.format_exception
                                    }
                            async.sleep 10i32 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async
            | _ => fun () => null ()
    loop 0

#!markdown

### wait_for_file_access_read

#!spiral

let wait_for_file_access_read path =
    path
    |> wait_for_file_access (Some (
        AccessRead,
        ShareRead
    ))

#!spiral

//// test
//// timeout=30000

inl lock_file path =
    fun () =>
        trace Debug (fun () => "_1") id
        inl stream : file_stream' =
            file_stream
                path
                ModeOpen
                AccessReadWrite
                ShareNone
            |> use
        trace Debug (fun () => "_2") id
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") id
        ($'!stream.Seek (0L, System.IO.SeekOrigin.Begin)' : i64) |> ignore
        trace Debug (fun () => "_4") id
        $'!stream.WriteByte' 49u8
        trace Debug (fun () => "_5") id
        stream |> $'_.Flush()'
        trace Debug (fun () => "_6") id
    |> async.new_async

inl file_name = "test.txt"
inl text = "0"

inl temp_dir, disposable =
    (file_name, text)
    |> sm'.format_debug
    |> crypto.hash_text
    |> create_temp_dir'
disposable |> use |> ignore
inl path = temp_dir </> file_name

fun () =>
    trace Debug (fun () => "1") id
    text |> write_all_text_async path |> async.do
    trace Debug (fun () => "2") id
    inl child = path |> lock_file |> async.start_child |> async.let'
    trace Debug (fun () => "3") id
    async.sleep 1 |> async.do
    trace Debug (fun () => "4") id
    inl retries = path |> wait_for_file_access None |> async.let'
    trace Debug (fun () => "5") id
    inl text = path |> read_all_text_async |> async.let'
    trace Debug (fun () => "6") id
    child |> async.do
    trace Debug (fun () => "7") id
    (retries, text) |> return
|> async.new_async_unit
|> async.run_with_timeout 3000
|> function
    | Some ((retries : i64), text) =>
        retries
        |> _assert_between
            (if platform.is_windows () then 50 else 100)
            (if platform.is_windows () then 180 else 200)

        text |> _assert_eq (join "1")

        true
    | _ => false
|> _assert_eq true

#!markdown

### read_all_text_retry_async

#!spiral

let read_all_text_retry_async full_path : async.async (optionm'.option' string) =
    let rec loop (retry : i64) =
        fun () =>
            try_unit
                fun () =>
                    if retry > 0
                    then
                        full_path
                        |> wait_for_file_access_read
                        |> async.run_with_timeout_async 1000
                        |> async.ignore
                        |> async.do
                    full_path |> read_all_text_async |> async.map (Some >> optionm'.box) |> async.return_await
                fun ex =>
                    fix_condition
                        fun () => retry <> 0
                        fun () =>
                            trace Debug
                                fun () => "file_system.read_all_text_retry_async"
                                fun () => {
                                    retry
                                    ex = ex () |> sm'.format_exception
                                }
                            (None : _ string) |> optionm'.box |> return
                        fun () =>
                            loop (retry + 1) |> async.return_await
        |> async.new_async
    loop 0

#!markdown

### move_file_async

#!spiral

let move_file_async new_path old_path : _ i64 =
    let rec loop (retry : i64) =
        run_target function
            | Fsharp (Native) => fun () =>
                fun () =>
                    try_unit
                        fun () =>
                            old_path |> file_move new_path
                            return retry
                        fun ex =>
                            if retry % 100 = 0 then
                                trace Warning
                                    fun () => "move_file_async"
                                    fun () => {
                                        old_path = old_path |> get_file_name
                                        new_path = new_path |> get_file_name
                                        ex = ex () |> sm'.format_exception
                                    }
                            async.sleep 10 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async_unit
            | _ => fun () => null ()
    loop 0

#!spiral

//// test
//// timeout=30000

inl lock_file path =
    fun () =>
        trace Debug (fun () => "_1") id
        file_stream
            path
            ModeOpen
            AccessReadWrite
            ShareNone
        |> use
        |> ignore
        trace Debug (fun () => "_2") id
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") id
    |> async.new_async

fun () =>
    inl file_name = "test.txt"
    inl text = "0"

    inl temp_dir, disposable =
        (file_name, text)
        |> sm'.format_debug
        |> crypto.hash_text
        |> create_temp_dir'
    disposable |> use |> ignore
    let path = temp_dir </> file_name
    let new_path = temp_dir </> "test2.txt"

    trace Debug (fun () => "1") id
    text |> write_all_text_async path |> async.do
    trace Debug (fun () => "2") id
    inl child = lock_file path |> async.start_child |> async.let'
    trace Debug (fun () => "3") id
    async.sleep 1 |> async.do
    trace Debug (fun () => "4") id
    inl retries1 = path |> move_file_async new_path |> async.let'
    trace Debug (fun () => "5") id
    inl retries2 = new_path |> wait_for_file_access None |> async.let'
    trace Debug (fun () => "6") id
    inl text = new_path |> read_all_text_async |> async.let'
    trace Debug (fun () => "7") id
    child |> async.do
    trace Debug (fun () => "8") id
    (retries1, retries2, text) |> return
|> async.new_async_unit
|> async.run_with_timeout 3000
|> function
    | Some (retries1, retries2, text) =>
        retries1
        |> _assert_between
            (if platform.is_windows () then 50i64 else 0)
            (if platform.is_windows () then 200 else 0)

        retries2
        |> _assert_between
            (if platform.is_windows () then 0i64 else 100)
            (if platform.is_windows () then 0 else 200)

        text |> _assert_eq (join "0")

        true
    | _ => false
|> _assert_eq true

#!markdown

### delete_file_async

#!spiral

let delete_file_async path : _ i64 =
    let rec loop (retry : i64) =
        run_target function
            | Fsharp (Native) => fun () =>
                fun () =>
                    try_unit
                        fun () =>
                            path |> file_delete
                            return retry
                        fun ex =>
                            if retry % 100 = 0 then
                                trace Warning
                                    fun () => "delete_file_async"
                                    fun () => {
                                        path = path |> get_file_name
                                        ex = ex () |> sm'.format_exception
                                    }
                            async.sleep 10 |> async.do
                            loop (retry + 1) |> async.return_await
                |> async.new_async
            | _ => fun () => null ()
    loop 0

#!spiral

//// test
//// timeout=30000

inl lock_file path =
    fun () =>
        trace Debug (fun () => "_1") id
        file_stream
            path
            ModeOpen
            AccessReadWrite
            ShareNone
        |> use
        |> ignore
        trace Debug (fun () => "_2") id
        async.sleep 2000 |> async.do
        trace Debug (fun () => "_3") id
    |> async.new_async

fun () =>
    inl file_name = "test.txt"
    inl text = "0"

    inl temp_dir, disposable =
        (file_name, text)
        |> sm'.format_debug
        |> crypto.hash_text
        |> create_temp_dir'
    disposable |> use |> ignore
    inl path = temp_dir </> file_name

    trace Debug (fun () => "1") id
    text |> write_all_text_async path |> async.do
    trace Debug (fun () => "2") id
    inl child = lock_file path |> async.start_child |> async.let'
    trace Debug (fun () => "3") id
    async.sleep 1 |> async.do
    trace Debug (fun () => "4") id
    inl retries = delete_file_async path |> async.let'
    trace Debug (fun () => "5") id
    child |> async.do
    trace Debug (fun () => "6") id
    return retries
|> async.new_async_unit
|> async.run_with_timeout 3000
|> function
    | Some (retries : i64) =>
        retries
        |> _assert_between
            (if platform.is_windows () then 50 else 0)
            (if platform.is_windows () then 180 else 0)

        true
    | _ => false
|> _assert_eq true

#!markdown

## main

#!spiral

inl main () =
    init_trace_state None
    $'let delete_directory_async x = !delete_directory_async x' : ()
    $'let wait_for_file_access x = !wait_for_file_access x' : ()
    $'let wait_for_file_access_read x = !wait_for_file_access_read x' : ()
    $'let read_all_text_async x = !read_all_text_async x' : ()
    $'let file_exists_content x = !file_exists_content x' : ()
    $'let write_all_text_async x = !write_all_text_async x' : ()
    $'let write_all_text_exists x = !write_all_text_exists_async x' : ()
    $'let delete_file_async x = !delete_file_async x' : ()
    $'let move_file_async x = !move_file_async x' : ()
    $'let read_all_text_retry_async x = !read_all_text_retry_async x' : ()
    $'let create_temp_path () = !create_temp_path ()' : ()
    $'let create_temp_dir () = !create_temp_dir ()' : ()
    $'let create_temp_dir\' x = !create_temp_dir' x' : ()
    $'let get_source_directory () = !get_source_directory ()' : ()
    $'let normalize_path x = !normalize_path x' : ()
    $'let new_file_uri x = !new_file_uri x' : ()
    $'let get_workspace_root () = !get_workspace_root ()' : ()
    $'let trace_file x = !trace_file x' : ()
    $'let init_trace_file x = !init_trace_file x' : ()
    $'let link_directory x = !link_directory x' : ()
    inl combine x = (</>) x
    $'let (</>) x = !combine x' : ()
