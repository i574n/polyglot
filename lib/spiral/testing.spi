// // # testing

inl __expect fn log b a =
    if log then
        a |> sm'.format_debug |> console.write_line
    inl result = fn a b
    inl result =
        result || join result
    if log
    then $"$\"__expect / actual: %A{!a} / expected: %A{!b}\""
    else "__expect"
    |> assert result

inl __assert_approx_eq log e b a = __expect (fun a b => abs (b - a) < (e |> optionm.defaultWith 0.00000001)) log b a
inl _assert_approx_eq e b a = __assert_approx_eq true e b a

inl __assert_eq log b a = __expect (=) log b a
inl _assert_eq b a = __assert_eq true b a

inl __assert_eq' log b a = __expect (=.) log b a
inl _assert_eq' b a = __assert_eq' true b a

inl __assert_ne log b a = __expect (fun a b => a = b |> fun x => join x |> not) log b a
inl _assert_ne b a = __assert_ne true b a

inl __assert_gt log b a = __expect (>) log b a
inl _assert_gt b a = __assert_gt true b a

inl __assert_ge log b a = __expect (>=) log b a
inl _assert_ge b a = __assert_ge true b a

inl __assert_lt log b a = __expect (<) log b a
inl _assert_lt b a = __assert_lt true b a

inl __assert_le log b a = __expect (<=) log b a
inl _assert_le b a = __assert_le true b a

inl __contains forall t. log (b : t) a =
    __expect
        (fun a b => a |> $'Seq.tryFind' ((=) b) |> optionm'.unbox |> fun (x : option t) => x <> None)
        log b a
inl _contains b a = __contains true b a

inl _throws (fn : () -> ()) : option exn =
    inl none = None : option exn
    inl some (s : exn) = Some s
    $"try !fn (); !none with ex -> ex |> !some"

inl print_and_return x =
    $"printfn $\"print_and_return / x: {!x}\""
    x
