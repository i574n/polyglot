/// # async
open rust_operators

/// ## types
inl types () =
    backend_switch {
        Fsharp = fun () =>
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"futures::future::JoinAll<$0>\")>]\n#endif\ntype futures_future_JoinAll<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"futures::future::TryJoinAll<$0>\")>]\n#endif\ntype futures_future_TryJoinAll<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"rayon::iter::Map<$0, _>\")>]\n#endif\ntype rayon_iter_Map<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"rayon::vec::IntoIter<$0>\")>]\n#endif\ntype rayon_vec_IntoIter<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::future::Future<Output = $0>\")>]\n#endif\ntype std_future_Future<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"tokio::prelude::stream::Fuse<$0>\")>]\n#endif\ntype futures_future_Fuse<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"tokio::task::JoinHandle<$0>\")>]\n#endif\ntype tokio_task_JoinHandle<'T> = class end"
            global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"tokio_stream::StreamExt\")>]\n#endif\ntype tokio_stream_StreamExt = class end"
        Python = fun () => ()
    }

/// ## rust

/// ### future
nominal future t = $'std_future_Future<`t>'

/// ### future_pin
type future_pin t = rust.pin (rust.box (rust.dyn' (future t)))

/// ### future_pin_send
type future_pin_send t = rust.pin (rust.box (rust.send (rust.dyn' (future t))))

/// ### block_on
inl block_on forall t. (fn : future_pin t) : t =
    inl runtime : infer =
        !\($'$"tokio::runtime::Builder::new_multi_thread().enable_all().build().unwrap()"')
    !\\(fn, $'"!runtime.handle().block_on($0)"')

/// ### block_on'
inl block_on' forall t. (fn : future_pin t) : t =
    !\\(fn, $'"futures_lite::future::block_on($0)"')

/// ### block_on''
inl block_on'' forall t. (fn : future_pin t) : t =
    !\\(fn, $'"futures::executor::block_on($0)"')

/// ### block_on'''
inl block_on''' forall t. (fn : future_pin t) : t =
    !\\(fn, $'"async_std::task::block_on($0)"')

/// ### block_on_send
inl block_on_send forall t. (fn : future_pin_send t) : t =
    !\($'"tokio::runtime::block_on(!fn)"')

/// ### stream_ext
nominal stream_ext = $'tokio_stream_StreamExt'

/// ### join_handle
nominal join_handle t = $'tokio_task_JoinHandle<`t>'

/// ### spawn
inl spawn forall t. (fn : future_pin_send t) : join_handle t =
    !\($'"tokio::runtime::spawn(!fn)"')

/// ### try_join_all
nominal try_join_all t = $'futures_future_TryJoinAll<`t>'

inl try_join_all forall t. (x : am'.vec (future_pin (resultm.result' t sm'.std_string))) : try_join_all (future_pin (resultm.result' t sm'.std_string)) =
    inl x = join x
    !\($'"futures::future::try_join_all(!x)"')

/// ### fuse
nominal fuse t = $'futures_future_Fuse<`t>'

inl future_fuse forall t. (x : future_pin t) : fuse (future_pin t) =
    !\($'"futures::future::FutureExt::fuse(!x)"')

/// ### join_all
nominal join_all t = $'futures_future_JoinAll<`t>'

inl join_all forall t. (x : am'.vec (future_pin t)) : join_all (future_pin t) =
    inl x = join x
    !\($'"futures::future::join_all(!x)"')

/// ### join_all_send
inl join_all_send forall t. (x : am'.vec (future_pin_send t)) : join_all (future_pin_send t) =
    inl x = join x
    !\($'"futures::future::join_all(!x)"')

/// ### await_handle
inl await_handle forall t. (x : join_handle t) : t =
    !\($'"!x.await"')

/// ### await_all
inl await_all forall t. (x : join_all (future_pin t)) : am'.vec t =
    !\($'"!x.await"')

/// ### await_all_send
inl await_all_send forall t. (x : join_all (future_pin_send t)) : am'.vec t =
    !\($'"!x.await"')

/// ### try_await_all
inl try_await_all forall t. (x : try_join_all (future_pin (resultm.result' t sm'.std_string))) : resultm.result' (am'.vec t) sm'.std_string =
    !\($'"!x.await"')

/// ### try_await_all_send
inl try_await_all_send forall t. (x : try_join_all (future_pin_send (resultm.result' t sm'.std_string))) : resultm.result' (am'.vec t) sm'.std_string =
    !\($'"!x.await"')

/// ### await
inl await forall t. (x : future_pin t) : t =
    !\($'"!x.await"')

/// ### await
inl await_send forall t. (x : future_pin_send t) : t =
    !\($'"!x.await"')

/// ### into_iter
nominal into_iter t = $'rayon_vec_IntoIter<`t>'

/// ### into_par_iter
inl into_par_iter forall t. (x : am'.vec t) : into_iter t =
    !\($'"rayon::iter::IntoParallelIterator::into_par_iter(!x)"')

/// ### par_iter
inl par_iter forall t. (x : am'.vec t) : into_iter t =
    !\($'"rayon::iter::IntoParallelIterator::par_iter(!x)"')

/// ### iter_map
nominal iter_map t u = $'rayon_iter_Map<`t>'

/// ### par_map
inl par_map forall t u. (fn : t -> u) (ar : into_iter t) : iter_map (into_iter t) u =
    !\\((ar, fn), $'"rayon::iter::ParallelIterator::map($0, |x| $1(x))"')

/// ### par_collect
inl par_collect forall t u. (iter : iter_map (into_iter t) u) : am'.vec u =
    !\\(iter, $'"rayon::iter::ParallelIterator::collect($0)"')

/// ### try_join_all_iter
inl try_join_all_iter forall t. (x : am'.vec (future_pin_send (resultm.result' t sm'.std_string))) : try_join_all (future_pin_send (resultm.result' t sm'.std_string)) =
    inl x = join x
    !\($'"futures::future::try_join_all(!x)"')

/// ### new_future
inl new_future forall t. (x : () -> t) : future_pin t =
    join
        !\($'"{Box::pin(async { //"')
        x () |> fun x => join $'!x '
        !\($'"}}) //"')

/// ### new_future_move
inl new_future_move forall t. (x : () -> t) : future_pin t =
    join
        !\($'"{Box::pin(async move { //"')
        x () |> fun x => join $'!x '
        !\($'"}}) //"')

/// ### future_init
inl future_init forall t. (depth : (u8 * u8)) (flag : u8) (x : () -> t) : future_pin t =
    // join
    //     if flag = 1
    //     then new_future_move x
    //     else new_future x
    if flag = 1
    then !\($'"let __result = Box::pin(async move { //"')
    else !\($'"let __result = Box::pin(async { //"')

    let x' = x ()
    inl x' = join x'

    x' |> rust.fix_closure depth

    !\($'"__result"')

/// ### future_init_send
inl future_init_send forall t. (depth : (u8 * u8)) (flag : u8) (x : () -> t) : future_pin_send t =
    // join
    //     if flag = 1
    //     then new_future_move x
    //     else new_future x
    join
        if flag = 1
        then !\($'"let __result = Box::pin(async move { //"')
        else !\($'"let __result = Box::pin(async { //"')

        let x' = x ()
        inl x' = join x'

        x' |> rust.fix_closure depth

        !\($'"__result"')

/// ### new_future_move_init
inl new_future_move_init forall t. (depth : (u8 * u8)) (flag : u8) (x : () -> t) : future_pin t =
    future_init depth flag x
    // join
    //     !\($'"{Box::pin(async move { //"')
    //     inl x' = x () |> fun x => join $'!x '
    //         inl depth = depth |> fst
    //         if depth = 1
    //         then !\($'"!x' })"')
    //         elif depth = 2
    //         then !\($'"!x' }})"')
    //         elif depth = 3
    //         then !\($'"!x' }}})"')
    //         elif depth = 4
    //         then !\($'"!x' }}}})"')

    //         !\($'"// 1"')

/// ## fsharp

/// ### async
nominal async t = $'Async<`t>'

/// ### task
nominal task t =
    `(
        typecase t with
        | () => $'' : $'System.Threading.Tasks.Task'
        | _ => $'' : $'System.Threading.Tasks.Task<`t>'
    )

/// ### new_async_unit
inl new_async_unit forall t. (fn : () -> ()) : async t =
    run_target function
        | Fsharp (Native) => fun () =>
            inl result : optionm'.option' (async t) = optionm'.none' ()
            $'let mutable _!result = !result '
            $'async {'
            fn ()
            $'}'
            $'|> fun x -> _!result <- Some x'
            $'match _!result with Some x -> x | None -> failwith "async.new_async_unit / _!result=None"'
        | _ => fun () => null ()

/// ### new_async
inl new_async forall t. (fn : () -> t) : async t =
    new_async_unit (fn >> ignore)

/// ### new_task
inl new_task forall t. (fn : () -> t) : task t =
    run_target function
        | Fsharp (Native) => fun () =>
            inl result : optionm'.option' (task t) = optionm'.none' ()
            $'let mutable _!result = !result '
            $'task {'
            fn () |> ignore
            $'}'
            $'|> fun x -> _!result <- Some x'
            $'match _!result with Some x -> x | None -> failwith "async.new_task / _!result=None"'
        | _ => fun () => null ()

/// ### await_task
inl await_task forall t. (a : task t) : async t =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.AwaitTask'
        | _ => fun () => null ()

/// ### ignore
inl ignore forall t. (a : async t) : async () =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.Ignore'
        | _ => fun () => null ()

/// ### run_synchronously
inl run_synchronously forall t. (a : async t) : t =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.RunSynchronously'
        | _ => fun () => null ()

/// ### start
inl start (a : async ()) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.Start'
        | _ => fun () => null ()

/// ### start_child
inl start_child forall t. (a : async t) : async (async t) =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.StartChild'
        | _ => fun () => null ()

/// ### start_child_timeout
inl start_child_timeout forall t. (timeout : i32) (a : async t) : async (async t) =
    run_target function
        | Fsharp (Native) => fun () =>
            $'Async.StartChild (!a, !timeout)'
        | _ => fun () => null ()

/// ### start_immediate
inl start_immediate forall t. (a : async t) : () =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.StartImmediate'
        | _ => fun () => null ()

/// ### task_canceled_exception
nominal task_canceled_exception = $'System.Threading.Tasks.TaskCanceledException'

/// ### sleep
inl sleep (ms : i32) : async () =
    run_target function
        | Fsharp (Native) => fun () =>
            ms |> $'Async.Sleep'
        | _ => fun () => null ()

/// ### do
inl do (a : async ()) : () =
    $'do\! !a '

/// ### let'
inl let' forall t. (a : async t) : t =
    $'let\! !a = !a '
    $'!a '

/// ### return_await
inl return_await forall t. (a : async t) : () =
    $'return\! !a '

/// ### return_await'
inl return_await' forall t. (a : async t) : t =
    $'return\! !a '

/// ### map
inl map forall t u. (fn : t -> u) (a : async t) : async u =
    fun () =>
        inl x = a |> let'
        fn x |> return
    |> new_async_unit

/// ### catch'
inl catch' forall t e. (a : async t) : async (choice2' t e) =
    run_target function
        | Fsharp (Native) => fun () =>
            a |> $'Async.Catch'
        | _ => fun () => null ()

/// ### catch
inl catch forall t e. (a : async t) : async (result t e) =
    a
    |> catch'
    |> map choice2_unbox
    |> map function
        | C1of2 result => Ok result
        | C2of2 ex => Error ex

/// ### run_with_timeout_async
inl run_with_timeout_async forall t. (timeout : i32) (fn : async t) : async (option t) =
    run_target function
        | Fsharp (Native) => fun () =>
            fun () =>
                inl _locals () = $'$"timeout: {!timeout} / {!_locals ()}"'
                inl child = fn |> start_child_timeout timeout |> let'
                child
                |> catch
                |> map function
                    | Ok result => Some result
                    | Error ex when ex |> sm'.format_debug |> sm'.contains "System.TimeoutException" =>
                        trace Debug (fun () => $'"async.run_with_timeout_async"') _locals
                        None
                    | Error (ex : exn) =>
                        inl ex = ex |> sm'.format_exception
                        trace Critical (fun () => $'$"async.run_with_timeout_async** / ex: {!ex}"') _locals
                        None
                |> return_await
            |> new_async_unit
        | _ => fun () => null ()

/// ### run_with_timeout
inl run_with_timeout timeout fn =
    fn
    |> run_with_timeout_async timeout
    |> run_synchronously

/// ### cancellation_token
inl cancellation_token () : async threading.cancellation_token =
    $'Async.CancellationToken'

inl default_cancellation_token () : threading.cancellation_token =
    $'Async.DefaultCancellationToken'

/// ### merge_cancellation_token_with_default_async
inl merge_cancellation_token_with_default_async
    (token : threading.cancellation_token)
    : async threading.cancellation_token
    =
    run_target function
        | Fsharp (Native) => fun () =>
            fun () =>
                inl ct = cancellation_token () |> let'
                inl dct = default_cancellation_token ()
                inl cts = threading.create_linked_token_source ;[ ct; dct; token ]
                cts |> threading.cancellation_source_token |> return
            |> new_async_unit
        | _ => fun () => null ()

/// ### with_trace_level
inl with_trace_level forall t. level fn : _ t = new_async fun () =>
    inl trace_state = get_trace_state_or_init None
    inl old_trace_level = *trace_state.level
    inl trace_level = trace_state.level
    try_finally
        fun () =>
            trace_level <- level
            fn |> return_await
        fun () =>
            trace_level <- old_trace_level

/// ### value_task
nominal value_task = $'System.Threading.Tasks.ValueTask'

/// ### value_task_as_task
inl value_task_as_task (task : value_task) : task () =
    $'!task.AsTask' ()

/// ### await_value_task_unit
inl await_value_task_unit (task : value_task) : async () =
    task |> value_task_as_task |> await_task

/// ## main
inl main () =
    types ()
    $'let merge_cancellation_token_with_default_async x = !merge_cancellation_token_with_default_async x' : ()
