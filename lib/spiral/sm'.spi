// // # sm'
open rust_operators

// // ## types
inl types () =
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"str\")>]\n#endif\ntype Str = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"base64::DecodeError\")>]\n#endif\ntype base64_DecodeError = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"borsh::io::Error\")>]\n#endif\ntype borsh_io_Error = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"js_sys::JsString\")>]\n#endif\ntype js_sys_JsString = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"serde_json::Error\")>]\n#endif\ntype serde_json_Error = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"serde_json::Value\")>]\n#endif\ntype serde_json_Value = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"serde_wasm_bindgen::Error\")>]\n#endif\ntype serde_wasm_bindgen_Error = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::ffi::OsStr\")>]\n#endif\ntype std_ffi_OsStr = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::ffi::OsString\")>]\n#endif\ntype std_ffi_OsString = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::fmt::Display<$0>\")>]\n#endif\ntype std_fmt_Display<'T> = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::str::Utf8Error\")>]\n#endif\ntype std_str_Utf8Error = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::string::FromUtf8Error\")>]\n#endif\ntype std_string_FromUtf8Error = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::string::String\")>]\n#endif\ntype std_string_String = class end"
    global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"std::slice::Windows<$0>\")>]\n#endif\ntype std_slice_Windows<'T> = class end"

inl types () =
    rust.types ()
    types ()

nominal display t = $"std_fmt_Display<`t>"
nominal str = $"Str"
nominal base64_decode_error = $"base64_DecodeError"
nominal borsh_io_error = $"borsh_io_Error"
nominal utf8_error = $"std_str_Utf8Error"
nominal from_utf8_error = $"std_string_FromUtf8Error"
nominal json_value = $"serde_json_Value"
nominal json_error = $"serde_json_Error"
nominal serde_wasm_bindgen_error = $"serde_wasm_bindgen_Error"
nominal js_string = $"js_sys_JsString"
nominal os_str = $"std_ffi_OsStr"
nominal os_string = $"std_ffi_OsString"
nominal std_string = $"std_string_String"

// // ## contains
inl contains (value : string) (s : string) : bool =
    $"!s.Contains !value"

// // ## ends_with
inl ends_with (value : string) (s : string) : bool =
    $"!s.EndsWith !value"

// // ## last_index_of
inl last_index_of (search : string) (s : string) : i32 =
    $"!s.LastIndexOf !search"

// // ## pad_left
inl pad_left (total_width : i32) (padding_char : char) (s : string) : string =
    $"!s.PadLeft (!total_width, !padding_char)"

// // ## pad_right
inl pad_right (total_width : i32) (padding_char : char) (s : string) : string =
    $"!s.PadRight (!total_width, !padding_char)"

// // ## starts_with
inl starts_with (value : string) (s : string) : bool =
    $"!s.StartsWith !value"

// // ## substring
inl substring (start : i32) (len : i32) (str : string) : string =
    $"!str.Substring (!start, !len)"

// // ## to_lower
inl to_lower (input : string) : string =
    $"!input.ToLower ()"

// // ## to_upper
inl to_upper (input : string) : string =
    $"!input.ToUpper ()"

// // ## trim
inl trim (input : string) : string =
    $"!input.Trim ()"

// // ## trim_end
inl trim_end (trim_chars : array_base char) (input : string) : string =
    $"!input.TrimEnd !trim_chars"

// // ## trim_start
inl trim_start (trim_chars : array_base char) (input : string) : string =
    $"!input.TrimStart !trim_chars"

// // ## length
inl length forall dim. (input : string) : dim =
    $"!input |> String.length"

// // ## slice
inl slice from to s : string =
    sm.slice s { from to }

// // ## range
union range dim =
    | Start : dim
    | End : dim -> dim

inl range start end s =
    inl start, end =
        match start, end with
        | Start start, End fn =>
            start, s |> length |> fn
        | End start_fn, End end_fn =>
            inl len = s |> length
            start_fn len, end_fn len
    s |> slice start end

// // ## raw_string_literal
inl raw_string_literal (s : string) : rust.ref' str =
    !\($"\"r#\\\"\" + !s + \"\\\"#\"")

// // ## raw_string_literal_static
inl raw_string_literal_static (s : string) : rust.static_ref' str =
    !\($"\"r#\\\"\" + !s + \"\\\"#\"")

// // ## (~#)
inl (~#) s =
    s |> raw_string_literal

// // ## (~##)
inl (~##) s =
    s |> raw_string_literal_static

// // ## include_str
inl include_str (path : string) : rust.ref' str =
    !\($'"include_str\!(\\\"" + !path + "\\\")"')

// // ## as_str
inl as_str (s : string) : rust.ref' str =
    !\\(s, $'"fable_library_rust::String_::LrcStr::as_str(&$0)"')

// // ## from_std_string
inl from_std_string (str : std_string) : string =
    !\\(str, $'"fable_library_rust::String_::fromString($0)"')

// // ## ref_to_std_string
inl ref_to_std_string (str : rust.ref' str) : std_string =
    !\\(str, $'"String::from($0)"')

// // ## to_std_string
inl to_std_string (s : string) : std_string =
    inl s = join s
    s |> as_str |> ref_to_std_string

// // ## as_str_std
inl as_str_std (s : std_string) : rust.ref' str =
    inl s = join s
    !\($'"!s.as_str()"')

// // ## into_boxed_str
inl into_boxed_str (s : std_string) : rust.box str =
    !\($'"!s.into_boxed_str()"')

// // ## as_os_ref
inl as_os_ref (s : os_string) : rust.ref' os_str =
    !\\(s, $'"$0.as_ref()"')

// // ## to_os_string
inl to_os_string (s : rust.ref' os_str) : os_string =
    !\\(s, $'"$0.to_os_string()"')

// // ## os_to_str
inl os_to_str (s : os_string) : optionm'.option' (rust.ref' str) =
    !\\(s, $'"$0.to_str()"')

// // ## from_os_str_ref
inl from_os_str_ref s =
    s
    |> to_os_string
    |> os_to_str
    |> optionm'.unwrap
    |> ref_to_std_string
    |> from_std_string

// // ## obj_to_string
inl obj_to_string x : string =
    x |> $'_.ToString()'

// // ## to_string any
instance to_string any =
    obj_to_string

// // ## to_string result t u
instance to_string result t u = fun x =>
    real
        open rust
        typecase (t * u) with
        | string * string =>
            match x with
            | Ok x => x
            | Error x => $'"sm\'.to_string result / Error: " + !x + ""' : string
        | std_string * std_string =>
            match x with
            | Ok x => from_std_string x
            | Error x => $'"sm\'.to_string result / Error: " + string !x + ""' : string
        | _ => obj_to_string `u x

// // ## format''
inl format'' (format : string) : std_string =
    !\($'@@$"format\!(" + !format + ")"')

// // ## format'
inl format' x : std_string =
    run_target function
        | Rust _ => fun () =>
            !\\(x, $'@@$"format\!(""{{}}"", $0)"')
        | _ => fun () => null ()

// // ## format_debug
inl format_debug x : string =
    $'$"%A{!x}"'

// // ## format_debug'
inl format_debug' x : std_string =
    !\\(x, $'@@$"format\!(""{{:?}}"", $0)"')

// // ## format_pretty'
inl format_pretty' x : std_string =
    !\\(x, $'@@$"format\!(""{{:#?}}"", $0)"')

// // ## format_exception
inl format_exception (ex : exn) : string =
    run_target function
        | Fsharp (Native) => fun () => $'$"{!ex.GetType ()}: {!ex.Message}"'
        | _ => fun () => ex |> format_debug

// // ## replace
inl replace (old_value : string) (new_value : string) (s : string) : string =
    $"!s.Replace (!old_value, !new_value)"

// // ## replace_regex
inl replace_regex (pattern : string) (replacement : string) (s : string) : string =
    run_target function
        | Fsharp (Native) => fun () =>
            $"System.Text.RegularExpressions.Regex.Replace (!s, !pattern, !replacement)"
        | Rust (Native) => fun () =>
            open rust_operators
            inl pattern = join pattern
            inl s = join s
            inl replacement = join replacement
            !\\((pattern, s, replacement), $'$"&regex::Regex::new(&$0).unwrap().replace_all(&$1, &*$2)"')
            |> ref_to_std_string
            |> from_std_string
        | _ => fun () => null ()

// // ## serialize
inl serialize forall t. (x : t) : resultm.result' std_string json_error =
    !\($'"serde_json::to_string(&!x)"')

// // ## deserialize
inl deserialize forall t. (json : string) : resultm.result' t std_string =
    inl json = join json
    inl json = json |> as_str
    !\($'"serde_json::from_str(&!json)"')
    |> resultm.map_error' fun (x : json_error) => x |> format'

// // ## borsh_deserialize
inl borsh_deserialize forall t. (data : array_base u8) : resultm.result' t std_string =
    inl data = data |> am'.as_slice
    !\($'"let mut !data = !data"')
    inl result = !\($'"borsh::BorshDeserialize::deserialize(&mut !data)"')
    result
    |> resultm.map_error' fun (x : borsh_io_error) => x |> format'

// // ## deserialize_vec
inl deserialize_vec (value : json_value) : resultm.result' (am'.vec u8) std_string =
    inl value = join value
    !\($'"serde_json::from_value(!value)"')
    |> resultm.map_error' fun (x : json_error) => x |> format'

// // ## encode_uri_component
inl encode_uri_component (s : std_string) : js_string =
    !\($'"js_sys::encode_uri_component(&!s)"')

// // ## strip_prefix
inl strip_prefix (prefix : char) (s : std_string) : optionm'.option' (rust.ref' str) =
    inl s = join s
    !\($'"!s.strip_prefix(!prefix)"')

// // ## str_from_utf8
inl str_from_utf8 (bytes : rust.ref' (am'.slice u8)) : resultm.result' (rust.ref' str) utf8_error =
    !\($'"std::str::from_utf8(!bytes)"')

// // ## string_from_utf8
inl string_from_utf8 (bytes : am'.vec u8) : resultm.result' std_string from_utf8_error =
    !\($'"std::string::String::from_utf8(!bytes)"')

// // ## base64_decode
inl base64_decode (s : std_string) : result std_string std_string =
    fun () =>
        inl s = join s
        inl bytes : resultm.result' (am'.vec u8) base64_decode_error =
            !\($'"base64::Engine::decode(&base64::engine::general_purpose::STANDARD, !s)"')
        bytes
        |> resultm.map_error' format'
        |> resultm.try'
        |> string_from_utf8
        |> resultm.map_error' format'
    |> fun x =>
        join x ()
        |> resultm.unbox

// // ## concat_array_trailing
inl concat_array_trailing (separator : string) (input : a i32 string) =
    ("", input)
    ||> am.fold fun acc (x : string) =>
        $'!acc + !x + !separator + ""'

// // ## concat_list_trailing
inl concat_list_trailing separator input =
    ("", input)
    ||> listm.fold fun acc (x : string) =>
        $'!acc + !x + !separator + ""'

// // ## concat_list_heap_trailing
inl concat_list_heap_trailing separator input =
    inl separator = join separator
    inl separator = separator |> as_str
    ("", input)
    ||> listm.fold fun acc (x : string) =>
        inl acc = acc |> to_std_string
        inl x = x |> as_str
        $'$"{!acc}{!x}{!separator}"'

// // ## concat
inl concat (a : string) (b : seq.seq' _) : string =
    inl a = join a
    b |> $"String.concat" a

// // ## ellipsis
inl ellipsis (max : i32) (s : string) =
    if sm.length s <= max
    then s
    else s |> slice 0 (max - 1) |> fun x => $'!x + "..."'

// // ## ellipsis_end
inl ellipsis_end (max : i64) (s : string) =
    inl len = sm.length s
    if len <= max
    then s
    else
        inl half = f64 max / 2
        inl start_half = half |> math.ceil |> i64
        inl end_half = half |> math.floor |> i64
        inl start = s |> slice 0 (start_half - 1)
        inl end = s |> slice (len - end_half) (len - 1)
        (a ;[start; "..."; end] : _ i32 _)
        |> seq.of_array
        |> concat ""

// // ## format_ellipsis
inl format_ellipsis s =
    s
    |> format_debug
    |> ellipsis_end 400

// // ## split
inl split (separator : string) (str : string) : array_base string =
    $"!str.Split !separator"

// // ## split_string
inl split_string (separator : array_base string) (str : string) : array_base string =
    run_target function
        | Fsharp (Native) => fun () => $"!str.Split (!separator, System.StringSplitOptions.None)"
        | _ => fun () => str |> split ((a separator : _ i32 _) |> seq.of_array |> concat "")

// // ## join'
inl join' (concat : string) (s : a i32 string) : string =
    $"System.String.Join (!concat, !s)"

// // ## to_char_array
inl to_char_array (str : string) : a i32 char =
    am.init (str |> sm.length) (fun i => sm.index str i)

// // ## to_char_list
inl to_char_list (str : string) : list char =
    listm.init (str |> sm.length) (fun (i : i64) => sm.index str i)

nominal encoding = $'System.Text.Encoding'

inl encoding_utf8 () : encoding =
    $'System.Text.Encoding.UTF8'

// // ## utf8_get_bytes
inl utf8_get_bytes (s : string) : a i32 u8 =
    s |> $'`encoding.UTF8.GetBytes'

// // ## byte_to_string
inl byte_to_string (format : string) (x : u8) : string =
    $'!x.ToString' format

// // ## windows
nominal windows t = $'std_slice_Windows<`t>'

inl windows (len : unativeint) (source : am'.vec u8) : windows u8 =
    inl source = source |> rust.new_box |> rust.box_leak
    // inl source' = source |> rust.clone
    inl result = !\\(len, $'"<[_]>::windows(!source, $0)"')
    // source |> rust.drop
    result

// // ## any
inl any forall t. (fn : string -> bool) (source : windows t) : bool =
    (!\($'"true; let mut !source = !source"') : bool) |> ignore
    inl fn' x =
        x
        |> str_from_utf8
        |> resultm.unwrap_or' #""
        |> ref_to_std_string
        |> from_std_string
        |> fn
    !\\(fn', $'"!source.any(move |x| $0(x))"')

// // ## slice_contains
inl slice_contains (text : string) (source : am'.vec u8) : bool =
    fun () =>
        inl source = join source
        source
        |> windows (text |> length |> (fun x => x : i32) |> unativeint)
        |> any ((=.) text)
    |> fun x => join x ()

// // ## as_bytes
inl as_bytes (text : string) : rust.ref' (am'.slice u8) =
    inl text = join text
    !\($'"!text.as_bytes()"')

// // ## main
inl main () =
    types ()
    $"let contains x = !contains x" : ()
    $"let ends_with x = !ends_with x" : ()
    $"let pad_left x = !pad_left x" : ()
    $"let pad_right x = !pad_right x" : ()
    $"let replace x = !replace x" : ()
    $"let replace_regex x = !replace_regex x" : ()
    inl slice (a : i32) (b : i32) c = slice a b c
    $"let slice x = !slice x" : ()
    $"let split x = !split x" : ()
    $"let split_string x = !split_string x" : ()
    $"let starts_with x = !starts_with x" : ()
    $"let substring x = !substring x" : ()
    $"let to_lower x = !to_lower x" : ()
    $"let to_upper x = !to_upper x" : ()
    $"let trim x = !trim x" : ()
    $"let trim_end x = !trim_end x" : ()
    $"let trim_start x = !trim_start x" : ()
    $"let ellipsis x = !ellipsis x" : ()
    $"let ellipsis_end x = !ellipsis_end x" : ()
    $"let format_exception x = !format_exception x" : ()
    $"let concat_array_trailing x = !concat_array_trailing x" : ()
    inl concat a (b : seq.seq' string) = concat a b
    $"let concat x = !concat x" : ()
    $"let join' x = !join' x" : ()
    $"let to_char_array x = !to_char_array x" : ()

// // ## to_string std_string
open rust
instance to_string std_string = from_std_string
