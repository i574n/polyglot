// // # am

open rust_operators

// // ## append

instance append a dim {int; number} t =
    am.append

// // ## /@

inl (/@) a b =
    b |> append a

// // ## collect

inl collect forall t r. (fn : t -> a i32 r) (items : a i32 t) : a i32 r =
    items
    |> am.map fn
    |> am.fold (/@) (a ;[])

// // ## choose

inl choose f l =
    (l, [])
    ||> am.foldBack fun x acc =>
        match f x with
        | Some y => y :: acc
        | None => acc
    |> listm.toArray

// // ## sum

inl sum (a' : a _ _) =
    a' |> am.fold (+) 0

// // ## init_series

inl init_series start end inc =
    inl total = conv ((end - start) / inc) + 1
    am.init total (conv >> (*) inc >> (+) start) : a i32 _

// // ## head

inl head (ar : a _ _) =
    if var_is ar || length ar > 0
    then index ar 0
    else error_type "The length of the array should be greater than 0."

// // ## last

inl last (ar : a _ _) =
    inl len = length ar
    if var_is ar || len > 0
    then index ar (len - 1)
    else error_type "The length of the array should be greater than 0."

// // ## try_pick

inl try_pick forall t u. (fn : t -> option u) (array : a _ t) : option u =
    (array, None)
    ||> am.foldBack fun x acc =>
        match acc with
        | Some _ => acc
        | None => x |> fn

// // ## from_vec

inl from_vec forall dim el. (vec : rust.vec el) : a dim el =
    inl vec = join vec
    !\($'"fable_library_rust::NativeArray_::array_from(!vec)"')

// // ## to_vec

inl to_vec forall t. (ar : array_base t) : rust.vec t =
    inl ar = join ar
    !\($'"!ar.to_vec()"')

// // ## map_vec

inl map_vec forall dim t u. (fn : t -> u) (ar : a dim t) : a dim u =
    inl fn = join fn
    inl (a ar) = ar
    inl ar = ar |> to_vec
    !\($'"!ar.iter().map(|x| !fn(x.clone())).collect()"')
    |> from_vec

// // ## map_base

inl map_base forall t u. (fn : t -> u) (x : array_base t) : array_base u =
    a x
    |> am.map fn
    |> fun (a x : _ i64 _) => x

inl average forall el {number}. (array : a _ el) : el =
    $"!array |> Array.average"

inl length forall dim el {number}. (array : a dim el) : dim =
    $"!array |> Array.length"

inl parallel_map forall dim el el'. (fn : el -> el') (array : a dim el) : a dim el' =
    $"!array |> Array.Parallel.map !fn"

inl sort_by forall dim el. (fn : el -> _) (array : a dim el) : a dim el =
    $"!array |> Array.sortBy !fn"

inl sort_descending forall dim el. (array : a dim el) : a dim el =
    $"!array |> Array.sortDescending"

inl transpose forall dim el. (array : a dim (a dim el)) : a dim (a dim el) =
    $"!array |> Array.transpose"

inl try_item forall dim el. (i : i32) (array : a dim el) : option el =
    $"!array |> Array.tryItem !i" |> optionm'.unbox

// // ## indexed

inl indexed (array : a _ _) =
    (([], 0), array)
    ||> am.fold fun (acc, i) x =>
        (i, x) :: acc, i + 1
    |> fst
    |> listm.rev
    |> listm.toArray

// // ## enumerate

inl enumerate forall dim {int; number} t. (ar : a dim t) : a dim (unativeint * t) =
    inl (a ar) = ar
    inl ar = ar |> to_vec
    !\($'"!ar.into_iter().enumerate().map(std::rc::Rc::new).collect()"')
    |> from_vec
    |> map_vec from_pair

// // ## indexed'

inl indexed' forall t dim {int; number} dim' {int; number} u {number}. (ar : a dim t) : a dim' (u * t) =
    ((0, a ;[]), ar)
    ||> am.fold fun (i, acc) x =>
        i + 1, acc /@ a ;[i, x]
    |> snd
