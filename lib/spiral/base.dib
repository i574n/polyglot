#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[]}}

#!markdown

# base

#!spiral

//// test

open testing

#!markdown

## array

#!spiral

inl array x = x

#!markdown

## prototype

#!spiral

prototype append t : t -> t -> t
prototype of_string t : string -> t
prototype to_string t : t -> string

#!markdown

## not'

#!spiral

inl not' x =
    join not x

#!markdown

## (+.)

#!spiral

inl (+.) forall t. (a : t) (b : t) : t =
    $"!a + !b"

#!markdown

## (-.)

#!spiral

inl (-.) forall t. (a : t) (b : t) : t =
    $"!a - !b"

#!markdown

## (*.)

#!spiral

inl (*.) forall t. (a : t) (b : t) : t =
    $"!a * !b"

#!markdown

## (/.)

#!spiral

inl (/.) forall t. (a : t) (b : t) : t =
    $"!a / !b"

#!markdown

## (=.)

#!spiral

inl (=.) forall t. (a : t) (b : t) : bool =
    $"!a = !b"

#!markdown

## (<>.)

#!spiral

inl (<>.) forall t. (a : t) (b : t) : bool =
    $"!a <> !b"

#!markdown

## (||>)

#!spiral

inl (||>) (arg1, arg2) fn =
    arg2 |> fn arg1

#!markdown

## (++)

#!spiral

inl (++) a b =
    b |> append a

#!markdown

## target_runtime

#!spiral

union target_runtime =
    | Native
    | Wasm
    | Contract

#!markdown

## target

#!spiral

union target =
    | Rust : target_runtime
    | Fsharp : target_runtime
    | TypeScript : target_runtime
    | Python : target_runtime

#!markdown

## defaultof

#!spiral

inl defaultof forall t. () : t =
    $'Unchecked.defaultof<`t>'

#!markdown

## emit

#!spiral

inl emit forall t. (x : t) : t =
    $'!x '

#!markdown

## emit_unit

#!spiral

inl emit_unit forall t. (x : t) : () =
    $'!x '

#!markdown

## ref

#!spiral

nominal ref t = $'`t ref'

#!markdown

## new_ref

#!spiral

inl new_ref forall t. (x : t) : ref t =
    $'ref !x '

#!markdown

## ref_value

#!spiral

inl ref_value forall t. (x : ref t) : t =
    $'!x.Value'

#!markdown

## ref_set_value

#!spiral

inl ref_set_value forall t. (value : t) (ref : ref t) : ref t =
    $'!ref.Value <- !value '
    ref

#!markdown

## unbox

#!spiral

inl unbox forall t u. (x : t) : u =
    $"!x |> unbox<`u>"

#!markdown

## capture

#!spiral

inl capture forall t. (fn : () -> t) : t =
    inl result = dyn true
    $'let mutable _!result : `t option = None '
    $'('
    $'(fun () ->'
    $'(fun () ->'
    fn () |> emit_unit
    $')'
    $"|> fun x -> x ()"
    $') () )'
    $"|> fun x -> _!result <- Some x"
    $'_!result.Value '

#!markdown

## run_target

#!spiral

inl run_target forall t. (fn : target -> (() -> t)) : t =
    inl result = dyn true
    $'let mutable _!result : `t option = None '
    $'\n#if FABLE_COMPILER || WASM || CONTRACT'
    $'\n#if FABLE_COMPILER_RUST && \!WASM && \!CONTRACT'
    fn (Rust Native) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_RUST && WASM'
    fn (Rust Wasm) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_RUST && CONTRACT'
    fn (Rust Contract) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_TYPESCRIPT'
    fn (TypeScript Native) () |> emit_unit
    $'#endif\n#if FABLE_COMPILER_PYTHON'
    fn (Python Native) () |> emit_unit
    $'#endif\n#else'
    fn (Fsharp Native) () |> emit_unit
    $'#endif'
    $'|> fun x -> _!result <- Some x'
    $'_!result.Value'

#!spiral

//// test

run_target function
    | Fsharp (Native) => fun () => $"1uy"
    | _ => fun () => $"2uy"
|> _assert_eq 1u8

#!spiral

//// test
///! rust

run_target function
    | Rust (Native) => fun () => $"1uy"
    | _ => fun () => $"2uy"
|> _assert_eq 1u8

#!markdown

## exn

#!spiral

nominal exn = $"exn"

#!markdown

## try

#!spiral

inl try forall t. (fn : () -> t) (ex_fn : exn -> option t) : option t =
    inl none = None : option t
    inl some (s : t) = Some s
    $'try !fn () |> !some with ex -> !ex_fn ex '

#!markdown

## try_unit

#!spiral

inl try_unit forall t. (fn : () -> ()) (ex_fn : exn -> ()) : t =
    $"try"
    fn ()
    |> ignore
    $"with ex ->"
    ex_fn $'ex'
    |> ignore
    $'(*'
    $'*)'

#!markdown

## try_finally

#!spiral

inl try_finally forall t. (fn : () -> ()) (finally : () -> ()) : t =
    $"try"
    fn ()
    |> ignore
    $"finally"
    finally ()
    |> ignore
    $'(*'
    $'*)'

#!markdown

## fix_condition

#!spiral

inl fix_condition x a b =
    if x ()
    then a () |> fun x => $'(*' : ()
    else
        $'*) else' : ()
        b () |> fun x => $'(*' : ()
    |> fun x => $'*)' : ()

#!markdown

## any

#!spiral

nominal any = $"obj"

#!markdown

## u8

#!spiral

inl u8 forall t. (x : t) : u8 =
    $"uint8 !x"

#!markdown

## u64

#!spiral

inl u64 forall t. (x : t) : u64 =
    $"uint64 !x"

#!markdown

## i32

#!spiral

inl i32 forall t. (x : t) : i32 =
    $"int32 !x"

#!markdown

## i64

#!spiral

inl i64 forall t. (x : t) : i64 =
    $"int64 !x"

#!markdown

## f32

#!spiral

inl f32 forall t. (x : t) : f32 =
    $"float32 !x"

#!markdown

## f64

#!spiral

inl f64 forall t. (x : t) : f64 =
    $"float !x"

#!markdown

## unativeint

#!spiral

nominal unativeint = $"unativeint"

inl unativeint forall t. (n : t) : unativeint =
    $"unativeint !n"

#!markdown

## convert_i32

#!spiral

inl convert_i32 forall t. (x : t) : i32 =
    x |> $'System.Convert.ToInt32'

#!markdown

## convert

#!spiral

inl convert forall t u. (x : t) : u =
    $'`u !x '

#!markdown

## pair

#!spiral

type pair a b = $"(`a * `b)"

inl pair x y =
    x, y

#!markdown

## null

#!spiral

inl null forall t. () : t =
    $"null |> unbox<`t>"

#!markdown

## use

#!spiral

inl use forall t. (x : t) : t =
    $"use !x = !x " : ()
    $'!x '

#!markdown

## pair

#!spiral

//// test

pair 1i32 2i32
|> _assert_eq (1, 2)

#!markdown

## new_pair

#!spiral

inl new_pair forall a b. (a : a) (b : b) : pair a b =
    $"!a, !b"

#!markdown

## from_pair

#!spiral

inl from_pair forall a b. (pair : pair a b) : a * b =
    $"let (a, b) = !pair"
    $"a", $"b"

#!spiral

//// test

new_pair "a" 1i32
|> from_pair
|> _assert_eq ("a", 1i32)

#!spiral

//// test

new_pair "a" (new_pair 1i32 "b")
|> from_pair

#!markdown

## get_union_fields

#!spiral

inl get_union_fields forall union_type. () : list union_type =
    real
        real_core.union_to_record
            `union_type
            forall union_record_type. =>
                real_core.record_type_fold
                    fun acc key =>
                        forall value. =>
                            inl item = real_core.nominal_create `union_type (key, ())
                            (::) `union_type item acc
                    (Nil `union_type)
                    `union_record_type

#!spiral

//// test

inl fields : list target_runtime = get_union_fields ()
fields
|> listm'.box
|> listm'.to_array'
|> am'.sort
|> fun x => x : a i32 _
|> _assert_eq (a ;[ Native; Wasm; Contract ])

#!markdown

## get_union_fields_untag

#!spiral

inl get_union_fields_untag forall union_type. () : list union_type =
    real
        real_core.union_to_record
            `union_type
            forall union_record_type. =>
                inl result =
                    real_core.record_type_fold_back
                        fun _key =>
                            forall value. (acc, (i : i32)) =>
                                inl item : union_type =
                                    real_core.union_untag `union_type i
                                        (fun k => forall v. => real_core.nominal_create `union_type (k, ()))
                                        (fun _ => failwith `union_type "Invalid tag.")
                                (::) `union_type item acc, (+) `i32 i 1
                        `union_record_type
                        (Nil `union_type, 0i32)
                inl result = fst `(list union_type) `i32 result
                listm.rev `union_type result

#!spiral

//// test

inl fields : list target_runtime = get_union_fields_untag ()
fields
|> listm'.box
|> listm'.to_array'
|> fun x => x : a i32 _
|> _assert_eq (a ;[ Native; Wasm; Contract ])
