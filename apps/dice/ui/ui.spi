inl types () =
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::ev::MouseEvent\")>] type leptos_ev_MouseEvent = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Button\")>] type leptos_html_Button = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Div\")>] type leptos_html_Div = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::html::Input\")>] type leptos_html_Input = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::Fragment\")>] type leptos_Fragment = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::HtmlElement<$0>\")>] type leptos_HtmlElement<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::IntoView\")>] type leptos_IntoView = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::RwSignal<$0>\")>] type leptos_RwSignal<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::Resource<$0, $1>\")>] type leptos_Resource<'T, 'U> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"leptos::View\")>] type leptos_View = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"rexie::Rexie\")>] type rexie_Rexie = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"rexie::Error\")>] type rexie_Error = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::rc::Rc<$0>\")>] type std_rc_Rc<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Box<$0>\")>] type Box<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::pin::Pin<$0>\")>] type std_pin_Pin<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::sync::Arc<$0>\")>] type std_sync_Arc<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::string::String\")>] type std_string_String = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"dyn $0\")>] type Dyn<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Fn() -> $0\")>] type Fn<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"FnOnce() -> $0\")>] type FnOnce<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"Fn()\")>] type FnUnit = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"std::future::Future<Output = $0>\")>] type Future<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"impl $0\")>] type Impl<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"&$0\")>] type Ref<'T> = class end"
    global "[<Fable.Core.Erase; Fable.Core.Emit(\"str\")>] type Str = class end"


nominal async t = $"Async<`t>"

nominal mouse_event = $"leptos_ev_MouseEvent"
nominal button = $"leptos_html_Button"
nominal div = $"leptos_html_Div"
nominal input = $"leptos_html_Input"
nominal fragment = $"leptos_Fragment"
nominal html_element t = $"leptos_HtmlElement<`t>"
nominal into_view = $"leptos_IntoView"
nominal rw_signal t = $"leptos_RwSignal<`t>"
nominal resource t u = $"leptos_Resource<`t, `u>"
nominal view = $"leptos_View"
nominal rexie = $"rexie_Rexie"
nominal rexie_error = $"rexie_Error"
nominal rc t = $"std_rc_Rc<`t>"
nominal box t = $"Box<`t>"
nominal pin t = $"std_pin_Pin<`t>"
nominal arc t = $"std_sync_Arc<`t>"
nominal std_string = $"std_string_String"
nominal dyn' t = $"Dyn<`t>"
nominal fn' t = $"Fn<`t>"
nominal fn_once t = $"FnOnce<`t>"
nominal fn_unit = $"FnUnit"
nominal future t = $"Future<`t>"
nominal impl t = $"Impl<`t>"
nominal ref' t = $"Ref<`t>"
nominal result' t u = $"Result<`t, `u>"
nominal str = $"Str"

inl result_get forall t e. (source : result t e) : t =
    match source with
    | Ok x => x
    | Error x => failwith $'$"Result value was Error: {!x}"'

inl raw_string_literal (s : string) : ref' str =
    rust.emit_expr () $"\"r#\\\"\" + !s + \"\\\"#\""

inl (~#) (s : string) : ref' str =
    raw_string_literal s

inl mount_to_body (view_fn : () -> impl into_view) =
    rust.emit_expr view_fn $'"leptos::mount_to_body(|| $0())"' : ()

inl log_string (text : string) =
    rust.emit_expr () $'@@"leptos::logging::log\!(""" + !text + @@""")"' : ()

inl log (text : string) =
    rust.emit_expr text $'@@$"leptos::logging::log\!(""{{}}"", $0)"' : ()

inl log_debug (text : string) =
    rust.emit_expr text $'@@$"leptos::logging::log\!(""{{:?}}"", $0)"' : ()

inl log_pretty (text : string) =
    rust.emit_expr text $'@@$"leptos::logging::log\!(""{{:#?}}"", $0)"' : ()

inl format_debug x : std_string =
    rust.emit_expr x $'@@$"format\!(""{{:?}}"", $0)"'

inl format_pretty x : std_string =
    rust.emit_expr x $'@@$"format\!(""{{:#?}}"", $0)"'

inl to_view (macro : string) : impl into_view =
    rust.emit_expr () $'"leptos::view\! { " + !macro + " }"'

inl to_fragment (macro : string) : fragment =
    rust.emit_expr () $'"leptos::view\! { " + !macro + " }"'

inl fragment_to_view (fragment : fragment) : impl into_view =
    rust.emit_expr () $'"leptos::IntoView::into_view(!fragment)"'

inl to_view' (macro : html_element div) : impl into_view =
    rust.emit_expr () $'"leptos::view\! { {!macro} }"'

inl as_str (s : string) : ref' str =
    inl s = join s
    rust.emit_expr () $'$"fable_library_rust::String_::LrcStr::as_str(&!s)"'

inl to_std_string (s : string) : std_string =
    inl s = s |> as_str
    rust.emit_expr () $'$"String::from(!s)"'

inl future_init forall t. (depth : u8) (x : () -> t) : pin (box (dyn' (future t))) =
    rust.emit_expr () $'"let __future_init = Box::pin(async { //"'
    let x' = x ()
    inl x' = join x'
    if depth = 3
    then rust.emit_expr () $'"!x' }}})"'
    else rust.emit_expr () $'"!x' }})"'
    if depth = 0 || depth = 3
    then rust.emit_expr () $'"{ { // "'
    elif depth = 2
    then rust.emit_expr () $'"{ // "'
    rust.emit_expr () $'"__future_init"'

inl await forall t. (x : pin (box (dyn' (future t)))) : t =
    rust.emit_expr () $'"!x.await"'

inl result_unwrap forall t u. (x : result' t u) : t =
    rust.emit_expr () $'"!x.unwrap()"'

inl create_signal forall t. (value : t) : (() -> t) * (t -> ()) =
    rust.emit_expr () $'$"leptos::create_signal(!value)"'

inl create_rw_signal forall t. (value : t) : rw_signal t =
    rust.emit_expr () $'$"leptos::create_rw_signal(!value)"'

inl create_local_resource forall t u. (source : () -> t) (fetcher : t -> pin (box (dyn' (future u)))) : resource t u =
    inl source = join source
    rust.emit_expr fetcher $'"leptos::create_local_resource(move || !source(), |x| async move { $0(x).await })"'

inl use_context forall t. () : t =
    rust.emit_expr () $'"leptos::use_context::<std::rc::Rc<`t>>().unwrap().into()"'

inl signal_get forall t. (signal : rw_signal t) : t =
    inl signal = join signal
    rust.emit_expr () $'$"leptos::SignalGet::get(&!signal)"'

inl signal_update forall t. (fn : t -> t) (signal : rw_signal t) =
    inl fn = join fn
    inl signal = join signal
    rust.emit_expr () $'$"leptos::SignalUpdate::update(&!signal, |x| *x = !fn(*x))"' : ()

inl resource_get forall t u. (resource : resource t u) : optionm'.option_fsharp u =
    inl resource = join resource
    rust.emit_expr () $'$"leptos::SignalGet::get(&!resource)"'


type state =
    {
        dark_mode : rw_signal bool
    }

type global_state =
    heap {
        state : rw_signal state
    }

inl input () =
    inl (explorer_backend_host, set_explorer_backend_host) = create_signal("explorer-backend-mainnet-prod-24ktefolwq-uc.a.run.app" |> to_std_string)

    inl input' : html_element input =
        rust.emit_expr
            (explorer_backend_host, set_explorer_backend_host)
            $'$"leptos::view\! {{ <input class=\\\"bg-gray-50 dark:bg-gray-900 flex-1 h-8\\\" prop:value=$0 on:keyup=move |event: web_sys::KeyboardEvent| {{ $1(leptos::event_target_value(&event)) }} /> }}"'
    $"!input' |> unbox" : impl into_view

inl content () =
    inl font_size = 14i32
    inl font_size : string = $"string !font_size"
    inl font_size = font_size |> as_str

    inl input' = input ()
    inl input' : html_element input = $"!input' |> unbox"

    inl result : html_element div =
        rust.emit_expr
            font_size
            $'"leptos::view\! { <div class=\\\"bg-gray-50 dark:bg-gray-900 flex flex-1 min-h-screen min-w-full place-items-baseline text-gray-700 dark:text-gray-200 text-sm\\\" style=\\\"font-size: \\\".to_owned() + *$0 + \\\"px; place-items: baseline;\\\">label:{!input'}</div> }"'
    $"!result |> unbox" : impl into_view

inl build_database () : pin (box (dyn' (future (result rexie rexie_error)))) =
    log $'"ui.build_database ()"'

    fun () =>
        inl rexie : pin (box (dyn' (future (result' rexie rexie_error)))) = rust.emit_expr () $'"Box::pin(rexie::Rexie::builder(\\\"database\\\").version(1).add_object_store(rexie::ObjectStore::new(\\\"store\\\")).build())"'
        inl rexie : result' rexie rexie_error = rexie |> await
        inl rexie : rexie = rexie |> result_unwrap
        Ok rexie
    |> future_init 1

inl get_dark_mode (db : rexie) : pin (box (dyn' (future (result' (option bool) rexie_error)))) =
    log $'"ui.get_dark_mode ()"'
    fun () =>
        inl x = Some true
        $"Ok !x"
    |> future_init 2

inl dark_mode_button () =
    log $'"ui.dark_mode_button ()"'
    inl global_state : global_state = use_context ()

    inl database : resource (option ()) rexie =
        create_local_resource
            fun () => None
            fun _ =>
                fun () =>
                    log $'"ui.dark_mode_button () / database create_local_resource"'
                    build_database () |> await |> result_get
                |> future_init 0

    inl dark_mode : resource (optionm'.option_fsharp rexie) (option bool) =
        create_local_resource
            fun () =>
                database
                |> resource_get
            fun (database : optionm'.option_fsharp rexie) =>
                fun () =>
                    inl database_log = database |> format_debug
                    log $'"ui.dark_mode_button () / dark_mode create_local_resource / database: " + string !database_log + ""'
                    match database |> optionm'.from_fsharp with
                    | Some database => database |> get_dark_mode |> await |> result_unwrap
                    | None => None
                |> future_init 3

    inl on_click (_mouse_event : mouse_event) =
        global_state.state |> signal_get
        |> fun state => state.dark_mode |> signal_update fun x =>
            not x

    inl on_click = join on_click

    $'$"<button class=\\\"fixed bottom-4 right-4 bg-gray-500 text-white p-2 rounded-full\\\" on:click=move |mouse_event| !on_click(mouse_event)>{{(|| {{ leptos::logging::log\!(\\\"button () / render\\\"); leptos::view\! {{<></>}} }})()}}{{\\\"ðŸŒ“ï¸Ž\\\"}}</button>"'
    |> to_view

inl home () =
    log $'"ui.home ()"'

    inl global_state : global_state = use_context ()

    inl content' = content ()
    inl content' : html_element div = $"!content' |> unbox"

    inl class_dark () =
        global_state.state |> signal_get
        |> fun state => state.dark_mode |> signal_get

    inl class_dark = join class_dark

    inl dark_mode_button' = dark_mode_button ()
    inl dark_mode_button' : html_element button = $"!dark_mode_button' |> unbox"

    $'"<div class=\\\"flex flex-1\\\" class:dark={move || !class_dark()}>{!dark_mode_button'}{!content'}</div>"' |> to_view

inl app () =
    log $'"ui.app ()"'

    rust.emit_expr () $'"leptos_meta::provide_meta_context()"'

    inl global_state : global_state =
        heap {
            state =
                create_rw_signal
                    {
                        dark_mode = create_rw_signal true
                    }
        }

    rust.emit_expr () $'$"leptos::provide_context::<std::rc::Rc<`global_state>>(!global_state)"'

    inl home' = home ()
    inl home' : html_element div = $"!home' |> unbox"
    inl home' : view = rust.emit_expr () $'"leptos::IntoView::into_view(!home')"'

    $"!home' |> unbox" : impl into_view

inl main (args : array string) =
    log $'"main / args: " + string !args + ""'

    rust.emit_expr () $'"let _ = console_log::init_with_level(log::Level::Debug)"'
    rust.emit_expr () $'"console_error_panic_hook::set_once()"'

    log_string "main / mount_to_body"

    fun () =>
        app ()
    |> mount_to_body

    0i32

inl main () =
    types ()

    $"let main args = !main args" : ()
