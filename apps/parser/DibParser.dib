#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"name":"spiral"}]}}

#!markdown

# DibParser (Polyglot)

#!fsharp

#r @"../../../../../../../.nuget/packages/fsharp.control.asyncseq/3.2.1/lib/netstandard2.1/FSharp.Control.AsyncSeq.dll"
#r @"../../../../../../../.nuget/packages/system.reactive/6.0.1-preview.1/lib/net6.0/System.Reactive.dll"
#r @"../../../../../../../.nuget/packages/system.reactive.linq/6.0.1-preview.1/lib/netstandard2.0/System.Reactive.Linq.dll"
#r @"../../../../../../../.nuget/packages/argu/6.2.4/lib/netstandard2.0/Argu.dll"
#r @"../../../../../../../.nuget/packages/fparsec/2.0.0-beta2/lib/netstandard2.1/FParsec.dll"
#r @"../../../../../../../.nuget/packages/fparsec/2.0.0-beta2/lib/netstandard2.1/FParsecCS.dll"

#!fsharp

#!import ../../lib/fsharp/Notebooks.dib
#!import ../../lib/fsharp/Testing.dib

#!pwsh

ls ~/.nuget/packages/argu

#!fsharp

#!import ../../lib/fsharp/Common.fs
#!import ../../lib/fsharp/CommonFSharp.fs
#!import ../../lib/fsharp/Async.fs
#!import ../../lib/fsharp/AsyncSeq.fs
#!import ../../lib/fsharp/Runtime.fs
#!import ../../lib/fsharp/FileSystem.fs

#!fsharp

#if !INTERACTIVE
open Lib
#endif

#!fsharp

open Common
open FParsec
open SpiralFileSystem.Operators

#!spiral

//// test
//// test_force

open testing

#!spiral

open parsing
open sm'_operators
open file_system_operators

#!markdown

## escapeCell (test)

#!fsharp

//// test
//// test_force

let inline escapeCell input =
    input
    |> SpiralSm.split "\n"
    |> Array.map (function
        | line when line |> SpiralSm.starts_with "\\#!" || line |> SpiralSm.starts_with "\\#r" ->
            System.Text.RegularExpressions.Regex.Replace (line, "^\\\\#", "#")
        | line -> line
    )
    |> SpiralSm.concat "\n"

#!fsharp

//// test

$"a{nl}\\#!magic{nl}b{nl}"
|> escapeCell
|> _assertEqual $"a{nl}#!magic{nl}b{nl}"

#!markdown

## escape_cell (test)

#!spiral

//// test
//// test_force

inl escape_cell input =
    input
    |> sm'.split "\n"
    |> am'.to_list_base'
    |> listm'.unbox
    |> listm.map function
        | line when (line |> sm'.starts_with "\\#!") || (line |> sm'.starts_with "\\#r") =>
            sm'.replace_regex line "^\\\\#" "#"
        | line => line
    |> sm'.concat_list "\n"

#!spiral

//// test

"a\n\#!magic\nb\n"
|> escape_cell
|> _assert_eq "a\n#!magic\nb\n"

#!markdown

## magicMarker

#!fsharp

let magicMarker : Parser<string, unit> = pstring "#!"

#!fsharp

//// test

"#!magic"
|> run magicMarker
|> _assertEqual (
    Success ("#!", (), Position ("", 2, 1, 3))
)

#!fsharp

//// test

"##!magic"
|> run magicMarker
|> _assertEqual (
    Failure (
        $"Error in Ln: 1 Col: 1{nl}##!magic{nl}^{nl}Expecting: '#!'{nl}",
        ParserError (
            Position ("", 0, 1, 1),
            null,
            ErrorMessageList (ExpectedString "#!")
        ),
        ()
    )
)

#!markdown

## magic_marker

#!spiral

inl magic_marker () : parser string =
    "#!" |> p_string

#!spiral

//// test

"#!magic"
|> run_parser (magic_marker ())
|> resultm.get
|> sm'.format_debug
|> _assert_eq $$("#!", "magic", new_parser_state 0 1 3 7)

#!spiral

//// test

"##!magic"
|> run_parser (magic_marker ())
|> sm'.format_debug
|> _assert_eq (
    "US0_1\n  \"parsing.p_string / unexpected string / { "
    ++# $'"expected = ##!!; got = ####; rest = ####!!magic; s = !(new_parser_state 0 1 1 8) }\\\""'
)

#!spiral

//// test

"\n#!x"
|> run_parser ((new_line () >>. magic_marker ()) <|> (eof () >>. p_return "") |> look_ahead)
|> resultm.get
|> sm'.format_debug
|> _assert_eq $$("#!", "\n#!x", new_parser_state 0 1 1 4)

#!markdown

## magicCommand

#!fsharp

let magicCommand =
    magicMarker
    >>. manyTill anyChar newline
    |>> (System.String.Concat >> SpiralSm.trim)

#!fsharp

//// test

"#!magic

a"
|> run magicCommand
|> _assertEqual (
    Success ("magic", (), Position ("", 8, 2, 1))
)

#!fsharp

//// test

" #!magic

a"
|> run magicCommand
|> _assertEqual (
    Failure (
        $"Error in Ln: 1 Col: 1{nl} #!magic{nl}^{nl}Expecting: '#!'{nl}",
        ParserError (
            Position ("", 0, 1, 1),
            null,
            ErrorMessageList (ExpectedString "#!")
        ),
        ()
    )
)

#!markdown

## magic_command

#!spiral

inl magic_command () =
    magic_marker ()
    >>. many_chars_till (any_char ()) (new_line ())
    |>> sm'.trim

#!spiral

//// test

"#!magic\n\na"
|> run_parser (magic_command ())
|> resultm.get
|> sm'.format_debug
|> _assert_eq $$("magic", "\n\na", new_parser_state 0 1 8 10)

#!spiral

//// test

" #!magic\n\na"
|> run_parser (magic_command ())
|> sm'.format_debug
|> _assert_eq (
    "US0_1\n  \"parsing.p_string / unexpected string / { "
    ++# $'"expected = ##!!; got =  ##; rest =  ##!!magic\n\na; s = !(new_parser_state 0 1 1 11) }\\\""'
)

#!markdown

## content

#!fsharp

let content =
    newline >>. magicMarker <|> (eof >>. preturn "")
    |> attempt
    |> lookAhead
    |> manyTill anyChar
    |>> (System.String.Concat >> SpiralSm.trim)

#!fsharp

//// test

"#!magic


a


"
|> run content
|> _assertEqual (
    Success ("#!magic


a", (), Position ("", 14, 7, 1))
)

#!spiral

inl content () =
    new_line () >>. magic_marker () <|> eof () >>. p_return ""
    |> look_ahead
    |> many_chars_till (any_char ())
    |>> sm'.trim

#!spiral

//// test

"#!magic\n\n\na\n\n\n"
|> run_parser (content ())
|> resultm.get
|> sm'.format_debug
|> _assert_eq $$("#!magic\n\n\na", "", new_parser_state 14 7 1 14)

#!markdown

## Output

#!fsharp

type Output =
    | Fs
    | Md
    | Spi
    | Spir

#!markdown

## output

#!spiral

union output =
    | Fs
    | Md
    | Spi
    | Spir

#!markdown

## Magic

#!fsharp

type Magic =
    | Fsharp
    | Markdown
    | Spiral of Output
    | Magic of string

#!markdown

## magic

#!spiral

union magic =
    | Fsharp
    | Markdown
    | Spiral : output
    | Magic : string

#!markdown

## kernelOutputs

#!fsharp

let inline kernelOutputs magic =
    match magic with
    | Fsharp -> [ Fs ]
    | Markdown -> [ Md ]
    | Spiral output -> [ output ]
    | _ -> []

#!markdown

## kernel_outputs

#!spiral

inl kernel_outputs = function
    | Fsharp => [ Fs ]
    | Markdown => [ Md ]
    | Spiral output => [ output ]
    | _ => []

#!markdown

## Block

#!fsharp

type Block =
    {
        magic : Magic
        content : string
    }

#!markdown

## block

#!fsharp

let block =
    pipe2
        magicCommand
        content
        (fun magic content ->
            let magic, content =
                match magic with
                | "fsharp" -> Fsharp, content
                | "markdown" -> Markdown, content
                | "spiral" ->
                    let output = if content |> SpiralSm.contains "//// real\n" then Spir else Spi
                    let content =
                        if output = Spi
                        then content
                        else
                            content
                            |> SpiralSm.replace "//// real\n\n" ""
                            |> SpiralSm.replace "//// real\n" ""
                    Spiral output, content
                | magic -> magic |> Magic, content
            {
                magic = magic
                content = content
            })

#!spiral

type block =
    {
        magic : magic
        content : string
    }

inl block () =
    pipe2
        (magic_command ())
        (content ())
        fun magic content =>
            inl magic, content =
                match magic with
                | "fsharp" => Fsharp, content
                | "markdown" => Markdown, content
                | "spiral" =>
                    inl output =
                        if content |> sm'.contains "//// real\n"
                        then Spir
                        else Spi
                    inl content =
                        if output = Spi
                        then content
                        else
                            content
                            |> sm'.replace "//// real\n\n" ""
                            |> sm'.replace "//// real\n" ""
                    output |> Spiral, content
                | magic => magic |> Magic, content
            {
                magic = magic
                content = content
            }

#!spiral

//// test

"#!magic\n\n\na\n\n\n"
|> run_parser (block ())
|> resultm.get
|> sm'.format_debug
|> _assert_eq $$(Magic "magic", "a", "", new_parser_state 14 7 1 14)

#!markdown

## blocks

#!fsharp

let blocks =
    skipMany newline
    >>. sepEndBy block (skipMany1 newline)

#!fsharp

//// test


"#!magic1

a

\#!magic2

b

"
|> escapeCell
|> run blocks
|> _assertEqual (
    Success (
        [
            { magic = Magic "magic1"; content = "a" }
            { magic = Magic "magic2"; content = "b" }
        ],
        (),
        Position ("", 26, 9, 1)
    )
)

#!spiral

inl blocks () =
    skip_many (new_line ())
    >>. sep_end_by (block ()) (skip_many1 (new_line ()))

#!spiral

//// test

"#!magic1\n\na\n\n\#!magic2\n\nb\n\n"
|> escape_cell
|> run_parser (blocks ())
|> resultm.get
|> sm'.format_debug
|> _assert_eq $$(
    [
        { magic = Magic "magic1"; content = "a" }
        { magic = Magic "magic2"; content = "b" }
    ],
    "",
    new_parser_state 26 9 1 26
)

#!markdown

## formatBlock

#!fsharp

let inline formatBlock output (block : Block) =
    match output, block with
    | output, { magic = Markdown; content = content } ->
        let markdownComment =
            match output with
            | Spi | Spir -> "/// "
            | Fs -> "/// "
            | _ -> ""
        content
        |> SpiralSm.split "\n"
        |> Array.map (SpiralSm.trim_end [||])
        |> Array.filter (SpiralSm.ends_with " (test)" >> not)
        |> Array.map (function
            | "" -> markdownComment
            | line -> System.Text.RegularExpressions.Regex.Replace (line, "^\\s*", $"$&{markdownComment}")
        )
        |> SpiralSm.concat "\n"
    | Fs, { magic = Fsharp; content = content } ->
        let trimmedContent = content |> SpiralSm.trim
        if trimmedContent |> SpiralSm.contains "//// test\n"
            || trimmedContent |> SpiralSm.contains "//// ignore\n"
        then ""
        else
            content
            |> SpiralSm.split "\n"
            |> Array.filter (SpiralSm.trim_start [||] >> SpiralSm.starts_with "#r" >> not)
            |> SpiralSm.concat "\n"
    | (Spi | Spir), { magic = Spiral output'; content = content } when output' = output ->
        let trimmedContent = content |> SpiralSm.trim
        if trimmedContent |> SpiralSm.contains "//// test\n"
            || trimmedContent |> SpiralSm.contains "//// ignore\n"
        then ""
        else content
    | _ -> ""

#!fsharp

//// test

"#!markdown


a

    b

c


\#!markdown


c


\#!fsharp


let a = 1"
|> escapeCell
|> run block
|> function
    | Success (block, _, _) -> formatBlock Fs block
    | Failure (msg, _, _) -> failwith msg
|> _assertEqual "/// a
/// 
    /// b
/// 
/// c"

#!markdown

## format_block

#!spiral

inl format_block output (block : block) =
    match output, block with
    | output, { magic = (Markdown) content = content } =>
        inl markdown_comment =
            match output with
            | Spi | Spir => "/// "
            | Fs => "/// "
            | _ => ""
        content
        |> sm'.split "\n"
        |> am'.to_list_base'
        |> listm'.unbox
        |> listm.map (sm'.trim_end [])
        |> listm'.filter (sm'.ends_with " (test)" >> not)
        |> listm.map function
            | "" => markdown_comment
            | line => line |> sm'.replace_regex "^\\s*" ("$&" ++# markdown_comment)
        |> sm'.concat_list "\n"
    | Fs, { magic = (Fsharp) content = content } =>
        inl trimmed_content = content |> sm'.trim
        if (trimmed_content |> sm'.contains "//// test\n")
            || (trimmed_content |> sm'.contains "//// ignore\n")
        then ""
        else
            content
            |> sm'.split "\n"
            |> am'.to_list_base'
            |> listm'.unbox
            |> listm'.filter (sm'.trim_start [] >> sm'.starts_with "#r" >> not)
            |> sm'.concat_list "\n"
    | (Spi | Spir), { magic = (Spiral output') content = content } when output' = output =>
        inl trimmed_content = content |> sm'.trim
        if (trimmed_content |> sm'.contains "//// test\n")
            || (trimmed_content |> sm'.contains "//// ignore\n")
        then ""
        else content
    | _ => ""

#!spiral

//// test

"#!markdown\n\n\na\n\n    b\n\nc\n\n\n\#!markdown\n\n\nc\n\n\n\#!fsharp\n\n\nlet a = 1"
|> escape_cell
|> run_parser (block ())
|> function
    | Ok (block, _, _) => format_block Fs block
    | Error msg => failwith msg
|> _assert_eq "/// a\n/// \n    /// b\n/// \n/// c"

#!markdown

## formatBlocks

#!fsharp

let inline formatBlocks output blocks =
    blocks
    |> List.map (fun block ->
        block, formatBlock output block
    )
    |> List.filter (snd >> (<>) "")
    |> fun list ->
        (list, (None, []))
        ||> List.foldBack (fun (block, content) (lastMagic, acc) ->
            let lineBreak =
                if block.magic = Markdown && lastMagic <> Some Markdown && lastMagic <> None
                then ""
                else "\n"
            Some block.magic, $"{content}{lineBreak}" :: acc
        )
    |> snd
    |> SpiralSm.concat "\n"

#!fsharp

//// test

"#!markdown


a

b


\#!markdown


c


\#!fsharp


let a = 1

\#!markdown

d (test)

\#!fsharp

//// test

let a = 2

\#!markdown

e

\#!fsharp

let a = 3"
|> escapeCell
|> run blocks
|> function
    | Success (blocks, _, _) -> formatBlocks Fs blocks
    | Failure (msg, _, _) -> failwith msg
|> _assertEqual "/// a
/// 
/// b

/// c
let a = 1

/// e
let a = 3
"

#!markdown

## format_blocks

#!spiral

inl format_blocks output blocks =
    blocks
    |> listm.map fun block =>
        block, format_block output block
    |> listm'.filter (snd >> (<>) "")
    |> fun list =>
        (list, (None, []))
        ||> listm.foldBack (fun (block, content) (last_magic, acc) =>
            inl line_break =
                if block.magic = Markdown && last_magic <> Some Markdown && last_magic <> None
                then ""
                else "\n"
            Some block.magic, content ++# line_break :: acc
        )
    |> snd
    |> sm'.concat_list "\n"

#!spiral

//// test

"#!markdown\n\n\na\n\nb\n\n\n\#!markdown\n\n\nc\n\n\n\#!fsharp\n\n\nlet a = 1\n\n\#!markdown\n\nd (test)\n\n\#!fsharp\n\n//// test\n\nlet a = 2\n\n\#!markdown\n\ne\n\n\#!fsharp\n\nlet a = 3"
|> escape_cell
|> run_parser (blocks ())
|> function
    | Ok (blocks, _, _) => format_blocks Fs blocks
    | Error msg => failwith msg
|> _assert_eq "/// a\n/// \n/// b\n\n/// c\nlet a = 1\n\n/// e\nlet a = 3\n"

#!markdown

## indentBlock

#!fsharp

let inline indentBlock (block : Block) =
    { block with
        content =
            block.content
            |> SpiralSm.split "\n"
            |> Array.fold
                (fun (lines, isMultiline) line ->
                    let trimmedLine = line |> SpiralSm.trim
                    if trimmedLine = ""
                    then "" :: lines, isMultiline
                    else
                        let inline singleQuoteLine () =
                            trimmedLine |> Seq.sumBy ((=) '"' >> System.Convert.ToInt32) = 1
                            && trimmedLine |> SpiralSm.contains @"'""'" |> not
                            && trimmedLine |> SpiralSm.ends_with "{" |> not
                            && trimmedLine |> SpiralSm.ends_with "{|" |> not
                            && trimmedLine |> SpiralSm.starts_with "}" |> not
                            && trimmedLine |> SpiralSm.starts_with "|}" |> not

                        match isMultiline, trimmedLine |> SpiralSm.split_string [| $"{q}{q}{q}" |] with
                        | false, [| _; _ |] ->
                            $"    {line}" :: lines, true

                        | true, [| _; _ |] ->
                            line :: lines, false

                        | false, _ when singleQuoteLine () ->
                            $"    {line}" :: lines, true

                        | false, _ when line |> SpiralSm.starts_with "#" && block.magic = Fsharp ->
                            line :: lines, false

                        | false, _ ->
                            $"    {line}" :: lines, false

                        | true, _ when singleQuoteLine () && line |> SpiralSm.starts_with "    " ->
                            $"    {line}" :: lines, false

                        | true, _ when singleQuoteLine () ->
                            line :: lines, false

                        | true, _ ->
                            line :: lines, true
                )
                ([], false)
            |> fst
            |> List.rev
            |> SpiralSm.concat "\n"
    }

#!markdown

## indent_block

#!spiral

inl indent_block (block : block) =
    { block with
        content =
            (([], false), block.content |> sm'.split "\n" |> am'.to_list_base' |> listm'.unbox)
            ||> listm.fold fun (lines, is_multiline) line =>
                inl trimmed_line = line |> sm'.trim
                if trimmed_line = ""
                then "" :: lines, is_multiline
                else
                    inl single_quote_line () =
                        (trimmed_line
                            |> sm'.to_char_list
                            |> listm.map ((=) '"' >> convert_i32)
                            |> listm'.sum) = 1
                        && trimmed_line |> sm'.contains "'\"'" |> not
                        && trimmed_line |> sm'.ends_with "{" |> not
                        && trimmed_line |> sm'.ends_with "{|" |> not
                        && trimmed_line |> sm'.starts_with "}" |> not
                        && trimmed_line |> sm'.starts_with "|}" |> not

                    match is_multiline, trimmed_line |> sm'.split_string ;[ "\"\"\"" ] with
                    | false, ;[ _; _ ] =>
                        "    " ++# line :: lines, true

                    | true, ;[ _; _ ] =>
                        line :: lines, false

                    | false, _ when single_quote_line () =>
                        "    " ++# line :: lines, true

                    | false, _ when line |> sm'.starts_with "#" && block.magic = Fsharp =>
                        line :: lines, false

                    | false, _ =>
                        "    " ++# line :: lines, false

                    | true, _ when single_quote_line () && (line |> sm'.starts_with "    ") =>
                        "    " ++# line :: lines, false

                    | true, _ when single_quote_line () =>
                        line :: lines, false

                    | true, _ =>
                        line :: lines, true
            |> fst
            |> listm.rev
            |> sm'.concat_list "\n"
    }

#!markdown

## parse

#!fsharp

let inline parse output input =
    match run blocks input with
    | Success (blocks, _, _) ->
        blocks
        |> List.filter (fun block ->
            block.magic |> kernelOutputs |> List.contains output || block.magic = Markdown
        )
        |> List.map Some
        |> fun x -> x @ [ None ]
        |> List.pairwise
        |> List.choose (function
            | Some { magic = Markdown } as block, Some { magic = Markdown } -> block
            | Some { magic = Markdown } as block, Some { magic = magic }
                when magic |> kernelOutputs |> List.contains output -> block
            | Some { magic = Markdown } as block, _ when output = Md -> block
            | Some { magic = Markdown }, _ -> None
            | Some block, _ -> Some block
            | _ -> None
        )
        |> List.fold
            (fun (acc, indent) -> function
                | { magic = Markdown; content = content }
                    when output = Fs
                    && content |> SpiralSm.starts_with "# "
                    && content |> SpiralSm.ends_with ")"
                    ->
                    let moduleName, namespaceName =
                        System.Text.RegularExpressions.Regex.Match (content, @"# (.*) \((.*)\)$")
                        |> fun m -> m.Groups.[1].Value, m.Groups.[2].Value

                    let moduleBlock =
                        {
                            magic = Fsharp
                            content =
                                $"#if !INTERACTIVE
namespace {namespaceName}
#endif

module {moduleName} ="
                        }

                    moduleBlock :: acc, (indent + 1)
                | { magic = magic ; content = content } as block
                    when indent > 0
                    ->
                    indentBlock block :: acc, indent
                | block -> block :: acc, indent
            )
            ([], 0)
        |> fst
        |> List.rev
        |> Result.Ok
    | Failure (errorMsg, _, _) -> Result.Error errorMsg

#!fsharp

//// test
//// test_force

let example1 =
    $"""#!meta

{{"kernelInfo":{{"defaultKernelName":"fsharp","items":[{{"aliases":[],"name":"fsharp"}},{{"aliases":[],"name":"fsharp"}}]}}}}

\#!markdown

# TestModule (TestNamespace)

\#!fsharp

\#!import file.dib

\#!fsharp

\#r "nuget:Expecto"

\#!markdown

## ParserLibrary

\#!fsharp

open System

\#!markdown

## x (test)

\#!fsharp

//// ignore

let x = 1

\#!spiral

//// test

inl x = 1i32

\#!spiral

//// real

inl x = 2i32

\#!spiral

inl x = 3i32

\#!markdown

### TextInput

\#!fsharp

let str1 = "abc
def"

let str2 =
    "abc\
def"

let str3 =
    $"1{{
        1
    }}1"

let str4 =
    $"1{{({{|
        a = 1
    |}}).a}}1"

let str5 =
    "abc \
        def"

let x =
    match '"' with
    | '"' -> true
    | _ -> false

let long1 = {q}{q}{q}a{q}{q}{q}

let long2 =
    {q}{q}{q}
a
{q}{q}{q}

\#!fsharp

type Position =
    {{
#if INTERACTIVE
        line : string
#else
        line : int
#endif
        column : int
    }}"""
    |> escapeCell

#!fsharp

//// test

example1
|> parse Fs
|> Result.toOption
|> Option.get
|> (formatBlocks Fs)
|> _assertEqual $"""#if !INTERACTIVE
namespace TestNamespace
#endif

module TestModule =

    /// ## ParserLibrary
    open System

    /// ### TextInput
    let str1 = "abc
def"

    let str2 =
        "abc\
def"

    let str3 =
        $"1{{
            1
        }}1"

    let str4 =
        $"1{{({{|
            a = 1
        |}}).a}}1"

    let str5 =
        "abc \
            def"

    let x =
        match '"' with
        | '"' -> true
        | _ -> false

    let long1 = {q}{q}{q}a{q}{q}{q}

    let long2 =
        {q}{q}{q}
a
{q}{q}{q}

    type Position =
        {{
#if INTERACTIVE
            line : string
#else
            line : int
#endif
            column : int
        }}
"""

#!fsharp

//// test

example1
|> parse Md
|> Result.toOption
|> Option.get
|> (formatBlocks Md)
|> _assertEqual "# TestModule (TestNamespace)

## ParserLibrary

### TextInput
"

#!fsharp

//// test

example1
|> parse Spi
|> Result.toOption
|> Option.get
|> (formatBlocks Spi)
|> _assertEqual "/// # TestModule (TestNamespace)

/// ## ParserLibrary
inl x = 3i32
"

#!fsharp

//// test

example1
|> parse Spir
|> Result.toOption
|> Option.get
|> (formatBlocks Spir)
|> _assertEqual "/// # TestModule (TestNamespace)

/// ## ParserLibrary
inl x = 2i32
"

#!markdown

## parse

#!spiral

inl parse output input =
    match input |> run_parser (blocks ()) with
    | Ok (blocks, _, _) =>
        blocks
        |> listm'.filter fun block =>
            block.magic |> kernel_outputs |> listm'.contains output || block.magic = Markdown
        |> listm.map Some
        |> fun x => x ++ [ None ]
        |> listm'.pairwise
        |> listm'.choose function
            | Some { magic = (Markdown) } as block, Some { magic = (Markdown) } => block
            | Some { magic = (Markdown) } as block, Some { magic = magic }
                when magic |> kernel_outputs |> listm'.contains output => block
            | Some { magic = (Markdown) } as block, _ when output = Md => block
            | Some { magic = (Markdown) }, _ => None
            | Some block, _ => Some block
            | _ => None
        |> listm.fold
            fun acc, indent => function
                | { magic = (Markdown) content = content }
                    when output = Fs
                            && content |> sm'.starts_with "# "
                            && content |> sm'.ends_with ")"
                    =>
                    match sm'.index_of " (" content, sm'.last_index_of ")" content with
                    | i_open, i_close when i_open > 1 && i_close > i_open + 1 =>
                        inl module_name =
                            content |> sm'.substring 2 (i_open - 2) |> sm'.trim
                        inl namespace_name =
                            content |> sm'.substring (i_open + 2) (i_close - (i_open + 2)) |> sm'.trim

                        inl module_block =
                            {
                                magic = Fsharp
                                content =
                                    "#if !INTERACTIVE\nnamespace " ++# namespace_name
                                    ++\# "#endif\n\nmodule " ++# module_name ++# " ="
                            }

                        module_block :: acc, (indent + 1)
                    | _ => { magic = Markdown; content = content } :: acc, indent
                | { magic = magic content = content } as block when indent > 0 =>
                    indent_block block :: acc, indent
                | block => block :: acc, indent
            ([], 0i32)
        |> fst
        |> listm.rev
        |> Ok
    | Error error_msg => error_msg |> Error

#!spiral

//// test
//// test_force

inl example1 () =
    "#!meta"
    ++\# ""
    ++\# "{\"kernelInfo\":{\"defaultKernelName\":\"fsharp\",\"items\":[{\"aliases\":[],\"name\":\"fsharp\"},{\"aliases\":[],\"name\":\"fsharp\"}]}}"
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "# TestModule (TestNamespace)"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "\#!import file.dib"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "\#r \"nuget:Expecto\""
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "## ParserLibrary"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "open System"
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "## x (test)"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "//// ignore"
    ++\# ""
    ++\# "let x = 1"
    ++\# ""
    ++\# "\#!spiral"
    ++\# ""
    ++\# "//// test"
    ++\# ""
    ++\# "inl x = 1i32"
    ++\# ""
    ++\# "\#!spiral"
    ++\# ""
    ++\# "//// real"
    ++\# ""
    ++\# "inl x = 2i32"
    ++\# ""
    ++\# "\#!spiral"
    ++\# ""
    ++\# "inl x = 3i32"
    ++\# ""
    ++\# "\#!markdown"
    ++\# ""
    ++\# "### TextInput"
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "let str1 = \"abc"
    ++\# "def\""
    ++\# ""
    ++\# "let str2 ="
    ++\# "    \"abc\\"
    ++\# "def\""
    ++\# ""
    ++\# "let str3 ="
    ++\# "    $\"1{"
    ++\# "        1"
    ++\# "    }1\""
    ++\# ""
    ++\# "let str4 ="
    ++\# "    $\"1{({|"
    ++\# "        a = 1"
    ++\# "    |}).a}1\""
    ++\# ""
    ++\# "let str5 ="
    ++\# "    \"abc \\"
    ++\# "        def\""
    ++\# ""
    ++\# "let x ="
    ++\# "    match '\"' with"
    ++\# "    | '\"' -> true"
    ++\# "    | _ -> false"
    ++\# ""
    ++\# "let long1 = \"\"\"a\"\"\""
    ++\# ""
    ++\# "let long2 ="
    ++\# "    \"\"\""
    ++\# "a"
    ++\# "\"\"\""
    ++\# ""
    ++\# "\#!fsharp"
    ++\# ""
    ++\# "type Position ="
    ++\# "    {"
    ++\# "#if INTERACTIVE"
    ++\# "        line : string"
    ++\# "#else"
    ++\# "        line : int"
    ++\# "#endif"
    ++\# "        column : int"
    ++\# "    }"
    |> escape_cell

#!spiral

//// test

example1 ()
|> parse Fs
|> resultm.get
|> (format_blocks Fs)
|> _assert_eq (
    "#if !INTERACTIVE"
    ++\# "namespace TestNamespace"
    ++\# "#endif"
    ++\# ""
    ++\# "module TestModule ="
    ++\# ""
    ++\# "    /// ## ParserLibrary"
    ++\# "    open System"
    ++\# ""
    ++\# "    /// ### TextInput"
    ++\# "    let str1 = \"abc"
    ++\# "def\""
    ++\# ""
    ++\# "    let str2 ="
    ++\# "        \"abc\\"
    ++\# "def\""
    ++\# ""
    ++\# "    let str3 ="
    ++\# "        $\"1{"
    ++\# "            1"
    ++\# "        }1\""
    ++\# ""
    ++\# "    let str4 ="
    ++\# "        $\"1{({|"
    ++\# "            a = 1"
    ++\# "        |}).a}1\""
    ++\# ""
    ++\# "    let str5 ="
    ++\# "        \"abc \\"
    ++\# "            def\""
    ++\# ""
    ++\# "    let x ="
    ++\# "        match '\"' with"
    ++\# "        | '\"' -> true"
    ++\# "        | _ -> false"
    ++\# ""
    ++\# "    let long1 = \"\"\"a\"\"\""
    ++\# ""
    ++\# "    let long2 ="
    ++\# "        \"\"\""
    ++\# "a"
    ++\# "\"\"\""
    ++\# ""
    ++\# "    type Position ="
    ++\# "        {"
    ++\# "#if INTERACTIVE"
    ++\# "            line : string"
    ++\# "#else"
    ++\# "            line : int"
    ++\# "#endif"
    ++\# "            column : int"
    ++\# "        }"
    ++\# ""
)

#!spiral

//// test

example1 ()
|> parse Md
|> resultm.get
|> (format_blocks Md)
|> _assert_eq (
    "# TestModule (TestNamespace)"
    ++\# ""
    ++\# "## ParserLibrary"
    ++\# ""
    ++\# "### TextInput"
    ++\# ""
)

#!spiral

//// test

example1 ()
|> parse Spi
|> resultm.get
|> (format_blocks Spi)
|> _assert_eq (
    "/// # TestModule (TestNamespace)"
    ++\# ""
    ++\# "/// ## ParserLibrary"
    ++\# "inl x = 3i32"
    ++\# ""
)

#!spiral

//// test
////! gleam

example1 ()
|> parse Spir
|> resultm.get
|> (format_blocks Spir)
|> _assert_eq (
    "/// # TestModule (TestNamespace)"
    ++\# ""
    ++\# "/// ## ParserLibrary"
    ++\# "inl x = 2i32"
    ++\# ""
)

#!markdown

## parseDibCode

#!fsharp

let inline parseDibCode output file = async {
    trace Debug
        (fun () -> "parseDibCode")
        (fun () -> $"output: {output} / file: {file} / {_locals ()}")
    let! input = file |> SpiralFileSystem.read_all_text_async
    match parse output input with
    | Result.Ok blocks -> return blocks |> formatBlocks output
    | Result.Error msg -> return failwith msg
}

#!markdown

## parse_dib_code

#!spiral

inl parse_dib_code output file =
    trace Debug
        (fun () => "parse_dib_code")
        fun () => { output file }
    inl input = file |> file_system.read_all_text
    match parse output input with
    | Ok blocks => blocks |> format_blocks output
    | Error msg => failwith msg

#!markdown

## writeDibCode

#!fsharp

let inline writeDibCode output path = async {
    trace Debug
        (fun () -> "writeDibCode")
        (fun () -> $"output: {output} / path: {path} / {_locals ()}")
    let! result = parseDibCode output path
    let pathDir = path |> System.IO.Path.GetDirectoryName
    let fileNameWithoutExt =
        match output, path |> System.IO.Path.GetFileNameWithoutExtension with
        | Spir, fileNameWithoutExt -> $"{fileNameWithoutExt}_real"
        | _, fileNameWithoutExt -> fileNameWithoutExt
    let outputPath = pathDir </> $"{fileNameWithoutExt}.{output |> string |> SpiralSm.to_lower}"
    do! result |> SpiralFileSystem.write_all_text_async outputPath
}

#!markdown

## write_dib_code

#!spiral

inl write_dib_code output path =
    trace Debug
        (fun () => "write_dib_code")
        (fun () => { output path })
    inl result = parse_dib_code output path
    inl path_dir = path |> file_system.get_directory_name
    inl file_name_without_ext =
        match output, path |> file_system.get_file_name_without_extension with
        | Spir, file_name_without_ext => $"{fileNameWithoutExt}_real"
        | _, file_name_without_ext => file_name_without_ext
    inl output_path = path_dir </> file_name_without_ext ++# "." ++# ($output |> sm'.to_lower)
    result |> file_system.write_all_text output_path

#!markdown

## Arguments

#!fsharp

[<RequireQualifiedAccess>]
type Arguments =
    | [<Argu.ArguAttributes.MainCommand; Argu.ArguAttributes.Mandatory>]
        File of file : string * Output

    interface Argu.IArgParserTemplate with
        member s.Usage =
            match s with
            | File _ -> nameof File

#!fsharp

//// test

Argu.ArgumentParser.Create<Arguments>().PrintUsage ()

#!markdown

## main

#!fsharp

let main args =
    let argsMap = args |> Runtime.parseArgsMap<Arguments>

    let files =
        argsMap.[nameof Arguments.File]
        |> List.map (function
            | Arguments.File (path, output) -> path, output
        )

    files
    |> List.map (fun (path, output) -> path |> writeDibCode output)
    |> Async.Parallel
    |> Async.Ignore
    |> Async.runWithTimeout 30000
    |> function
        | Some () -> 0
        | None -> 1

#!fsharp

//// test

let args =
    System.Environment.GetEnvironmentVariable "ARGS"
    |> SpiralRuntime.split_args
    |> Result.toArray
    |> Array.collect id

match args with
| [||] -> 0
| args -> if main args = 0 then 0 else failwith "main failed"
