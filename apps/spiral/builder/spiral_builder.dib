#!meta

{"kernelInfo":{"defaultKernelName":"spiral","items":[{"aliases":[],"name":"spiral"}]}}

#!markdown

# spiral_builder

#!spiral

open file_system_operators
open rust_operators
open sm'_operators

#!spiral

//// test

open testing

#!markdown

## types

#!spiral

inl types () =
    env.types ()
    file_system.types ()
    runtime.types ()
    rust.types ()
    sm'.types ()
    crypto.types ()

#!markdown

## get_args

#!spiral

inl get_args () =
    {
        fsharp = "fsharp", {
            spi_path = "spi-path", 's'
        }
        cuda = "cuda", {
            py_path = "py-path", 'p'
            env = "env", 'e'
            deps = "deps", 'd'
        }
        fable = "fable", {
            fs_path = "fs-path", 'f'
            command = "command", 'c'
        }
        rust = "rust", {
            fs_path = "fs-path", 'f'
            deps = "deps", 'd'
        }
        typescript = "typescript", {
            fs_path = "fs-path", 'f'
            deps = "deps", 'd'
        }
        python = "python", {
            fs_path = "fs-path", 'f'
            deps = "deps", 'd'
        }
        dib = "dib", {
            path = "path", 'p'
            retries = "retries", 'r'
            working_directory = "working-directory", 'w'
        }
    }

#!markdown

## cuda_env

#!spiral

union cuda_env =
    | Pip
    | Poetry

#!markdown

## get_command

#!spiral

let get_command () =
    ##"command"
    |> runtime.new_command
    |> runtime.command_subcommand_required true
    |> runtime.command_subcommand (
        ##(get_args () .fsharp |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .fsharp |> snd).spi_path) (
            runtime.arg_required true
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .cuda |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .cuda |> snd).py_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .cuda |> snd).env) (
            real runtime.arg_union `cuda_env ignore
        )
        |> runtime.command_init_arg ((get_args () .cuda |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    (am'.Start (1i32 |> convert : unativeint))
                    (am'.End id)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .fable |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .fable |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .fable |> snd).command) (
            id
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .rust |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .rust |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .rust |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    (am'.Start (1i32 |> convert : unativeint))
                    (am'.End id)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .typescript |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .typescript |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .typescript |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    (am'.Start (1i32 |> convert : unativeint))
                    (am'.End id)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .python |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .python |> snd).fs_path) (
            runtime.arg_required true
        )
        |> runtime.command_init_arg ((get_args () .python |> snd).deps) (
            runtime.arg_value_names ;[ ##"NAME"; ##"VERSION" ]
            >> runtime.arg_num_args_range (
                runtime.new_value_range
                    (am'.Start (1i32 |> convert : unativeint))
                    (am'.End id)
            )
            >> runtime.arg_action runtime.Append
        )
    )
    |> runtime.command_subcommand (
        ##(get_args () .dib |> fst)
        |> runtime.new_command
        |> runtime.command_init_arg ((get_args () .dib |> snd).path) (
            runtime.arg_required true
            // >> runtime.arg_value_parser (runtime.value_parser_path_buf ())
        )
        |> runtime.command_init_arg ((get_args () .dib |> snd).retries) (
            runtime.arg_value_parser (runtime.value_parser_expr "u8")
        )
        |> runtime.command_init_arg ((get_args () .dib |> snd).working_directory) (
            id
        )
    )

#!markdown

## fable

#!markdown

### fable_target

#!spiral

union fable_target =
    | Rust
    | TypeScript
    | Python

#!markdown

### execute_dotnet_fable

#!spiral

let execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir } =
    runtime.execution_options fun x => { x with
        command =
            inl platform =
                if platform.is_windows ()
                then "_WINDOWS"
                else "_LINUX"
            $'$"dotnet fable \\\"{!fsproj_path}\\\" --optimize --lang {!extension} --extension .{!extension} --outDir \\\"{!package_dir}\\\" --define {!platform}"'
        working_directory = workspace_root_external |> resultm.box |> resultm.ok'
    }
    |> runtime.execute_retry 3u8

#!markdown

### get_package_dir

#!spiral

inl get_package_dir { workspace_root target name hash } =
    inl dir = workspace_root </> "target/spiral_builder" </> name
    match hash, (target : option fable_target) with
    | Some hash, Some target => dir </> "packages" </> (target |> reflection.union_to_string) </> hash
    | _ => dir

#!markdown

### persist_code_project

#!spiral

inl persist_code_project { workspace_root package_dir packages modules name code } =
    package_dir |> file_system.create_dir |> ignore

    inl fs_path = package_dir </> $'$"{!name}.fs"' |> file_system.normalize_path
    code |> file_system.write_all_text_exists fs_path

    inl modules_code =
        modules
        |> listm.map fun path =>
            inl path = workspace_root </> path
            $'$"<Compile Include=\\\"{!path}\\\" />"' : string
        |> listm'.box
        |> seq.of_list'
        |> sm'.concat "\\n        "

    inl packages_code =
        packages
        |> listm.map fun (package : string) =>
            $'$"<PackageReference Include=\\\"{!package}\\\" Version=\\\"*\\\" />"' : string
        |> listm'.box
        |> seq.of_list'
        |> sm'.concat "\\n        "

    inl fsproj_path = package_dir </> $'$"{!name}.fsproj"' |> file_system.normalize_path
    inl fsproj_code : string =
        $'$"<Project Sdk=\\\"Microsoft.NET.Sdk\\\">"'
        +#. $'$"<PropertyGroup>"'
        +#. $'$"    <TargetFramework>net9.0</TargetFramework>"'
        +#. $'$"    <LangVersion>preview</LangVersion>"'
        +#. $'$"    <RollForward>Major</RollForward>"'
        +#. $'$"    <TargetLatestRuntimePatch>true</TargetLatestRuntimePatch>"'
        +#. $'$"    <PublishAot>false</PublishAot>"'
        +#. $'$"    <PublishTrimmed>false</PublishTrimmed>"'
        +#. $'$"    <PublishSingleFile>true</PublishSingleFile>"'
        +#. $'$"    <SelfContained>true</SelfContained>"'
        +#. $'$"    <Version>0.0.1-alpha.1</Version>"'
        +#. $'$"    <OutputType>Exe</OutputType>"'
        +#. $'$"</PropertyGroup>"'

        +#. $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'FreeBSD\'))\\\">"'
        +#. $'$"    <DefineConstants>_FREEBSD</DefineConstants>"'
        +#. $'$"</PropertyGroup>"'

        +#. $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'Linux\'))\\\">"'
        +#. $'$"    <DefineConstants>_LINUX</DefineConstants>"'
        +#. $'$"</PropertyGroup>"'

        +#. $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'OSX\'))\\\">"'
        +#. $'$"    <DefineConstants>_OSX</DefineConstants>"'
        +#. $'$"</PropertyGroup>"'

        +#. $'$"<PropertyGroup Condition=\\\"$([MSBuild]::IsOSPlatform(\'Windows\'))\\\">"'
        +#. $'$"    <DefineConstants>_WINDOWS</DefineConstants>"'
        +#. $'$"</PropertyGroup>"'

        +#. $'$"<ItemGroup>"'
        +#. $'$"    {!modules_code}"'
        +#. $'$"    <Compile Include=\\\"{!fs_path}\\\" />"'
        +#. $'$"</ItemGroup>"'

        +#. $'$"<ItemGroup>"'
        +#. $'$"    {!packages_code}"'
        +#. $'$"</ItemGroup>"'

        +#. $'$"</Project>"'

    fsproj_code |> file_system.write_all_text_exists fsproj_path

    fsproj_path

#!markdown

### build_project

#!spiral

inl build_project runtime' output_dir path =
    inl full_path = path |> file_system.get_full_path
    inl file_dir = full_path |> file_system.get_directory_name
    inl extension = full_path |> file_system.get_extension

    trace Debug
        fun () => "build_project"
        fun () => { full_path }

    match extension with
    | "fsproj" => ()
    | _ => failwith $'$"spiral_builder.build_project / Invalid project file / extension: {!extension}"'

    inl runtimes =
        runtime'
        |> optionm.map listm.singleton
        |> optionm'.default_value [ "linux-x64"; "win-x64" ]

    inl output_dir = output_dir |> optionm'.default_value "dist"

    runtimes
    |> listm.map fun runtime' =>
        runtime.execution_options fun x => { x with
            command = $'$@@"dotnet publish \"\"{!path}\"\" --configuration Release --output \"\"{!output_dir}\"\" --runtime {!runtime'}"'
            working_directory = file_dir |> Some |> optionm'.box
        }
        |> runtime.execute_with_options
        |> fst
    |> listm'.sum

#!markdown

### build_code

#!spiral

inl build_code { workspace_root runtime packages modules output_dir name code } =
    inl package_dir = get_package_dir { workspace_root name target = None; hash = None }
    inl fsproj_path = persist_code_project { workspace_root package_dir packages modules name code }
    inl exit_code = fsproj_path |> build_project runtime output_dir
    if exit_code <>. 0 then
        inl fsproj_text = fsproj_path |> file_system.read_all_text
        trace Critical
            fun () => "build_code"
            fun () => { code = code |> sm'.ellipsis_end 400; fsproj_text }
    exit_code

#!spiral

//// test
///! rust -d encoding_rs encoding_rs_io regex

types ()

build_code
    {
        workspace_root = file_system.get_workspace_root ()
        runtime = None
        packages = []
        modules = []
        output_dir = None
        name = "test1"
        code = "1 + 1 |> ignore"
    }
|> _assert_eq 0

#!spiral

//// test
///! rust -d encoding_rs encoding_rs_io regex

types ()

build_code
    {
        workspace_root = file_system.get_workspace_root ()
        runtime = None
        packages = []
        modules = []
        output_dir = None
        name = "test2"
        code = "1 + a |> ignore"
    }
|> _assert_eq 2

#!markdown

### read_file

#!spiral

inl read_file path =
    inl code =
        path
        |> file_system.read_all_text
        |> sm'.replace_regex $'@@"(?P<a> *)(?P<b>let\\s+main\\s+.*?\\s*=)"' "$a[<EntryPoint>]\n$a$b"

    inl code_trim = code |> sm'.trim_end []
    if code_trim |> sm'.ends_with "\\n()"
    then code_trim |> sm'.slice 0i64 ((code_trim |> sm'.length) - 3)
    else code

#!markdown

### persist_file

#!spiral

inl persist_file { workspace_root package_dir packages modules path } =
    inl full_path = path |> file_system.get_full_path
    inl name = full_path |> file_system.get_file_name_without_extension
    inl code = full_path |> read_file
    persist_code_project { workspace_root package_dir packages modules name code }

#!markdown

### build_file

#!spiral

inl build_file { workspace_root runtime packages modules path } =
    inl full_path = path |> file_system.get_full_path
    inl dir = full_path |> file_system.get_directory_name
    build_code
        {
            workspace_root
            runtime
            packages
            modules
            output_dir = dir </> "dist" |> Some
            name = full_path |> file_system.get_file_name_without_extension
            code = full_path |> read_file
        }

#!markdown

## rust

#!markdown

### get_workspace_cargo_toml_content

#!spiral

inl get_workspace_cargo_toml_content { workspace_root } : string =
    inl workspace_root = workspace_root |> file_system.normalize_path
    $'$"[workspace]"'
    +#. $'$"resolver = \\\"2\\\""'
    +#. $'$"members = [\\\"packages/Rust/*\\\"]"'
    +#. $'$""'
    +#. $'$"[workspace.dependencies.fable_library_rust]"'
    +#. $'$"path = \\\"{!workspace_root}/lib/rust/fable/fable_modules/fable-library-rust\\\""'
    +#. $'$"default-features = false"'
    +#. $'$"features = [\\\"static_do_bindings\\\", \\\"datetime\\\", \\\"guid\\\", \\\"threaded\\\"]"'
    +#. $'$""'
    +#. $'$"[workspace.dependencies]"'
    +#. $'$"inline_colorization = \\\"~0.1\\\""'

#!markdown

### get_cargo_toml_content

#!spiral

inl get_cargo_toml_content { hash_hex deps } : string =
    $'$"[package]"'
    +#. $'$"name = \\\"spiral_builder_{!hash_hex}\\\""'
    +#. $'$"version = \\\"0.0.1\\\""'
    +#. $'$"edition = \\\"2021\\\""'
    +#. $'$""'
    +#. $'$"[dependencies]"'
    +#. $'$"fable_library_rust = {{ workspace = true }}"'
    +#. $'$"inline_colorization = {{ workspace = true }}"'
    +#. $'$"{!deps}"'
    +#. $'$""'
    +#. $'$"[[bin]]"'
    +#. $'$"name = \\\"spiral_builder_{!hash_hex}\\\""'
    +#. $'$"path = \\\"spiral_builder.rs\\\" "'

#!markdown

### get_empty_cargo_toml_content

#!spiral

inl get_empty_cargo_toml_content () =
    inl guid = date_time.now () |> date_time.new_guid_from_date_time |> sm'.obj_to_string
    $'$"[package]"'
    +#. $'$"name = \\\"spiral_builder_{!guid}\\\""'
    +#. $'$"version = \\\"0.0.1\\\""'
    +#. $'$"edition = \\\"2021\\\""'
    +#. $'$""'
    +#. $'$"[[bin]]"'
    +#. $'$"name = \\\"spiral_builder_{!guid}\\\""'
    +#. $'$"path = \\\"spiral_builder.rs\\\""'

#!markdown

### process_rust

#!spiral

inl process_rust { fs_path deps trace_level } =
    inl is_trace = trace_level = Verbose
    inl _trace (fn : () -> string) =
        if is_trace
        then trace Info (fun () => $'$"spiral_builder.process_rust / {!fn ()}"') id
        else fn () |> console.write_line

    inl extension = "rs"
    inl code = fs_path |> file_system.read_all_text

    inl hash_hex = (extension, code) |> sm'.format_debug |> crypto.hash_text

    inl workspace_name = "spiral_builder"

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir =
        get_package_dir { workspace_root name = workspace_name; target = Some Rust; hash = Some hash_hex }

    inl fsproj_path =
        persist_code_project
            {
                workspace_root
                package_dir
                packages = [ "Fable.Core" ]
                modules = []
                name = workspace_name
                code
            }

    inl workspace_dir = package_dir </> "../../.."
    inl workspace_cargo_toml_path = workspace_dir </> "Cargo.toml"

    if workspace_cargo_toml_path |> file_system.file_exists |> not
    then get_empty_cargo_toml_content () |> file_system.write_all_text workspace_cargo_toml_path

    inl cargo_toml_path = package_dir </> "Cargo.toml"

    if cargo_toml_path |> file_system.file_exists |> not
    then get_empty_cargo_toml_content () |> file_system.write_all_text cargo_toml_path

    inl lib_link_target_path = workspace_root </> "lib/rust/fable/fable_modules/fable-library-rust"
    inl lib_link_path = package_dir </> "fable_modules/fable-library-rust"

    lib_link_path |> file_system.link_directory lib_link_target_path

    inl exit_code, dotnet_fable_result =
        execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir }

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral_builder.process_rust / dotnet fable error"
            fun () => { exit_code dotnet_fable_result }
        { extension = Some extension; code = None; output = Some dotnet_fable_result }
    else
        inl deps =
            deps
            |> am'.vec_map fun dep =>
                inl dep = dep |> sm'.from_std_string
                if dep |> sm'.contains "="
                then dep
                elif dep |> sm'.ends_with "]"
                then dep |> sm'.replace "[" $'$"={{version=\'*\',features=["' |> fun x => $'$"{!x}}}"'
                else $'$"{!dep}=\'*\'"'
            |> am'.from_vec
            |> fun x => x : _ i32 _
            |> seq.of_array'
            |> sm'.concat "\n"

        inl cargo_toml_content = get_cargo_toml_content { hash_hex deps }
        inl workspace_cargo_toml_content = get_workspace_cargo_toml_content { workspace_root }

        cargo_toml_content |> file_system.write_all_text_exists cargo_toml_path

        workspace_cargo_toml_content |> file_system.write_all_text_exists workspace_cargo_toml_path

        inl range_rs_path = lib_link_path </> "src/Range.rs"
        if range_rs_path |> file_system.file_exists then
            inl text = range_rs_path |> file_system.read_all_text
            text
            |> sm'.replace "use crate::String_::fromCharCode;" "use crate::String_::fromChar;"
            |> sm'.replace "fromCharCode(c)" "std::char::from_u32(c).unwrap()"
            |> file_system.write_all_text_exists range_rs_path

        inl exit_code, cargo_fmt_result =
            fun () =>
                inl exit_code, result =
                    runtime.execution_options fun x => { x with
                        command = $'$"cargo fmt --manifest-path \\\"{!cargo_toml_path}\\\" --"'
                        working_directory = workspace_root_external |> resultm.box |> resultm.ok'
                    }
                    |> runtime.execute_with_options

                inl return () =
                    if exit_code = 0
                    then Ok (exit_code, result)
                    else Error (exit_code, result)

                if result |> sm'.contains "failed to load manifest for workspace member" |> not
                then return ()
                else
                    inl missing_toml_path =
                        "failed to read `(?<a>.*?Cargo.toml)`"
                        |> sm'.new_regex
                        |> resultm.unwrap'
                        |> sm'.regex_captures result
                        |> am'.from_vec
                        |> fun x => x : _ i32 _
                        |> am'.try_item 0
                        |> optionm.map (mapm.get "a" >> optionm'.unbox)
                        |> optionm'.flatten

                    match missing_toml_path with
                    | None => Error (exit_code, result)
                    | Some missing_toml_path =>
                        if missing_toml_path |> file_system.file_exists |> not then
                            missing_toml_path
                            |> file_system.get_directory_name
                            |> file_system.create_dir
                            |> ignore

                            get_empty_cargo_toml_content ()
                            |> file_system.write_all_text missing_toml_path
                        return ()
            |> retry_fn' 3u8

        if exit_code <>. 0 then
            trace Critical
                fun () => "spiral_builder.process_rust / cargo fmt error"
                fun () => { exit_code cargo_fmt_result }

        inl new_code_path = package_dir </> $'$"{!workspace_name}.{!extension}"'
        inl new_code = new_code_path |> file_system.read_all_text

        inl main_code_header =
            "pub fn main() -> Result<(), String> " +. !\($'"\\\"{\\\".into()"')
        inl main_code = $'$"{!main_code_header} Ok(()) }}"' : string

        inl cached = new_code |> sm'.contains main_code_header

        inl new_code =
            if cached
            then new_code
            else
                new_code
                |> sm'.replace
                    ("),)" +. !\($'"\\\";\\\".into()"'))
                    "));"
                |> sm'.replace
                    ("},)" +. !\($'"\\\";\\\".into()"'))
                    "});"
                |> sm'.replace_regex
                    "\\s\\sdefaultOf\\(\\);"
                    " defaultOf::<()>();"
                |> sm'.replace
                    ("defaultOf()" +. !\($'"\\\",\\\".into()"'))
                    "defaultOf::<std::sync::Arc<dyn IDisposable>>(),"
                |> sm'.replace
                    ("_self" +. !\($'"\\\"_.\\\".into()"'))
                    "self."
                |> sm'.replace
                    ("get_or_insert_wit" +. !\($'"\\\"h\\\".into()"'))
                    "get_or_init"
                |> sm'.replace
                    ("use fable_library_rust::System::Collections::Concurrent::ConcurrentStack_1" +. !\($'"\\\";\\\".into()"'))
                    "type ConcurrentStack_1<T> = T;"
                |> sm'.replace
                    ("use fable_library_rust::System::Threading::CancellationToken" +. !\($'"\\\";\\\".into()"'))
                    "type CancellationToken = ();"
                |> sm'.replace
                    ("use fable_library_rust::System::TimeZoneInfo" +. !\($'"\\\";\\\".into()"'))
                    "type TimeZoneInfo = i64;"
                |> sm'.replace
                    ("use fable_library_rust::System::Threading::Tasks::TaskCanceledException" +. !\($'"\\\";\\\".into()"'))
                    "type TaskCanceledException = ();"

        if not cached
        then
            $'$"{!new_code}\\n\\n{!main_code}\\n"'
            |> file_system.write_all_text_exists new_code_path

        inl command = $'$"cargo +nightly run --manifest-path \\\"{!cargo_toml_path}\\\""'
        inl environment_variables =
            inl fast = false
            ;[
                "TRACE_LEVEL", "Verbose"
                "RUSTC_WRAPPER", "sccache"
                "RUSTFLAGS",
                if fast
                then "-C prefer-dynamic -C strip=symbols -C link-arg=-s -C debuginfo=0"
                else "-C prefer-dynamic"
            ]
        inl exit_code, cargo_run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = workspace_root_external |> resultm.box |> resultm.ok'
            }
            |> runtime.execute_with_options

        inl cleanup =
            [ ".d"; ".exe"; ".pdb"; "" ]
            |> listm.map fun ext => workspace_dir </> $'$"target/debug/spiral_builder_{!hash_hex}{!ext}"'
            |> listm.map fun path => path, path |> file_system.file_exists

        trace Verbose
            fun () => "spiral_builder.process_rust"
            fun () => { new_code_path cleanup }

        cleanup
        |> listm'.filter snd
        |> listm.iter (fst >> file_system.file_delete)

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0 then
            inl output =
                try
                    fun () =>
                        cargo_run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> am'.skip_while fun line =>
                            (line |> sm'.contains "profile [optimized] target" |> not)
                                && (line |> sm'.contains "profile [unoptimized] target" |> not)
                                && (line |> sm'.contains "profile [unoptimized + debuginfo] target" |> not)
                        |> am'.skip 2
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral_builder.process_rust / Exception"
                            fun () => { ex cargo_run_result new_code_path external_command }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            { extension = Some extension; code = Some new_code; output = Some output }
        else
            trace Critical
                fun () => "spiral_builder.process_rust / error"
                fun () => { exit_code cargo_run_result new_code_path external_command }
            { extension = Some extension; code = None; output = None }

#!markdown

## dib

#!markdown

### process_dib

#!spiral

inl process_dib { path retries working_directory } =
    inl exit_code, repl_result =
        let rec loop retry =
            inl exit_code, repl_result =
                runtime.execution_options fun x => { x with
                    command = $'$"dotnet repl --exit-after-run --run \\\"{!path}\\\" --output-path \\\"{!path}.ipynb\\\""'
                    environment_variables = ;[
                        "TRACE_LEVEL", "Verbose"
                        "AUTOMATION", "True"
                    ]
                    trace = false
                    working_directory
                }
                |> runtime.execute_with_options

            if exit_code = 0 || retry >= retries
            then exit_code, repl_result
            else
                trace Debug
                    fun () => $'"spiral_builder.run / repl error"'
                    fun () => { exit_code repl_result retry = $'$"{!retry}/{!retries}"' : string }
                loop (retry + 1)
        loop 1

    inl exit_code, result =
        if exit_code <>. 0
        then exit_code, repl_result
        else
            inl exit_code, jupyter_result =
                runtime.execution_options fun x => { x with
                    command = $'$"jupyter nbconvert \\\"{!path}.ipynb\\\" --to html --HTMLExporter.theme=dark"'
                }
                |> runtime.execute_with_options

            trace Debug
                fun () => $'"spiral_builder.run / dib / jupyter nbconvert"'
                fun () => { exit_code jupyter_result_length = jupyter_result |> sm'.length : i32 }

            if exit_code <>. 0
            then exit_code, $'$"repl_result: {!repl_result}\n\njupyter_result: {!jupyter_result}"'
            else
                inl exit_code, pwsh_replace_html_result =
                    inl path = path |> sm'.replace "'" "''"
                    runtime.execution_options fun x => { x with
                        command = $'$"pwsh -c \\\"$counter = 1; $path = \'{!path}.html\'; (Get-Content $path -Raw) -replace \'(id=\\\\\\"cell-id=)[a-fA-F0-9]{{8}}\', {{ $_.Groups[1].Value + $counter++ }} | Set-Content $path\\\""'
                    }
                    |> runtime.execute_with_options

                trace Debug
                    fun () => $'"spiral_builder.run / dib / html cell ids"'
                    fun () => { exit_code pwsh_replace_html_result_length = pwsh_replace_html_result |> sm'.length : i32 }

                $'$"{!path}.html"'
                |> file_system.read_all_text
                |> sm'.replace "\r\n" "\n"
                |> file_system.write_all_text $'$"{!path}.html"'

                $'$"{!path}.ipynb"'
                |> file_system.read_all_text
                |> sm'.replace "\r\n" "\n"
                |> sm'.replace "\\r\\n" "\\n"
                |> file_system.write_all_text $'$"{!path}.ipynb"'

                exit_code, $'$"repl_result: {!repl_result}\n\njupyter_result: {!jupyter_result}\n\npwsh_replace_html_result: {!pwsh_replace_html_result}"'

    trace Debug
        fun () => $'"spiral_builder.run / dib"'
        fun () => { exit_code result_length = result |> sm'.length : i32 }

    if exit_code <>. 0
    then failwith $'$"spiral_builder.run / dib / exit_code: {!exit_code} / result: {!result}"'
    ;[
        "stdio",
        result
    ]

#!markdown

## typescript

#!markdown

### process_typescript

#!spiral

inl process_typescript { fs_path deps trace_level } =
    inl extension = "ts"
    inl is_trace = trace_level = Verbose
    inl _trace (fn : () -> string) =
        if is_trace
        then trace Info (fun () => $'$"spiral_builder.process_typescript / {!fn ()}"') id
        else fn () |> console.write_line

    inl code = fs_path |> file_system.read_all_text

    inl hash_hex = (extension, code) |> sm'.format_debug |> crypto.hash_text

    inl workspace_name = "spiral_builder"

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir =
        get_package_dir
            { workspace_root name = workspace_name; target = Some TypeScript; hash = Some hash_hex }

    inl fsproj_path =
        persist_code_project
            {
                workspace_root
                package_dir
                packages = [ "Fable.Core" ]
                modules = []
                name = workspace_name
                code
            }

    inl lib_path = workspace_root </> "lib/typescript/fable/fable_modules"

    inl versions =
        lib_path
        |> file_system.new_walk_dir
        |> file_system.walk_dir_filter fun entry => async.future_init_send (2, 1) 1 fun () =>
            entry
            |> file_system.dir_entry_file_type
            |> async.await_send
            |> resultm.map_error' sm'.format'
            |> resultm.unbox
            |> function
                | Ok file_type when file_type |> file_system.file_type_is_dir |> not => file_system.Ignore
                | _ => file_system.Continue
        |> file_system.stream_filter_map fun entry =>
            inl entry = entry |> resultm.map_error' sm'.format' |> resultm.unbox
            match entry with
            | Ok entry =>
                inl path =
                    entry
                    |> file_system.dir_entry_path
                    |> file_system.path_buf_display
                    |> sm'.format'
                    |> sm'.from_std_string
                inl version =
                    $'$"fable-library-{!extension}\\.(?<a>[\\d.]+)$"'
                    |> sm'.new_regex
                    |> resultm.unwrap'
                    |> sm'.regex_captures path
                    |> am'.from_vec
                    |> fun x => x : _ i32 _
                    |> am'.try_item 0
                    |> optionm.map (mapm.get "a" >> optionm'.unbox)
                    |> optionm'.flatten
                match version with
                | None => None
                | Some version => Some (path, version)
            | Error error =>
                trace Critical
                    fun () => $'"spiral_builder.process_typescript / stream_filter_map"'
                    fun () => { error }
                None
            |> optionm'.box
        |> async.into_par_iter
        |> async.par_map fun file =>
            file
        |> async.par_collect

    inl version =
        versions
        |> am'.from_vec
        |> fun x => x : _ i32 _
        |> am'.try_item 0

    trace Debug
        fun () => $'"spiral_builder.process_typescript"'
        fun () => { version = version |> sm'.format_pretty' }

    match version with
    | None => ()
    | Some (_path, version) =>
        inl lib_link_target_path = lib_path </> $'$"fable-library-{!extension}.{!version}"'
        inl lib_link_path = package_dir </> $'$"fable_modules/fable-library-{!extension}.{!version}"'

        lib_link_path |> file_system.link_directory lib_link_target_path

    inl exit_code, dotnet_fable_result =
        execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir }

    if exit_code <>. 0 then
        trace Critical
            fun () => $'$"spiral_builder.process_typescript"'
            fun () => { exit_code dotnet_fable_result }
        { extension = Some extension; code = None; output = Some dotnet_fable_result }
    else
        inl deps =
            deps
            |> am'.vec_map fun dep =>
                inl dep = dep |> sm'.from_std_string
                if dep |> sm'.contains "="
                then dep
                else $'$"\\"{!dep}\\":\\"*\\""'
            |> am'.from_vec
            |> fun x => x : _ i32 _
            |> seq.of_array'
            |> sm'.concat ",\n"

        inl package_json_content =
            $'$"{{"'
            +. $'$"  \\\"name\\\": \\\"spiral_builder_{!hash_hex}\\\","'
            +. $'$"  \\\"dependencies\\\": {{"'
            +. deps
            +. $'$"  }},"'
            +. $'$"    \\\"devDependencies\\\": {{"'
            +. $'$"  }},"'
            +. $'$"}}"'

        inl workspace_package_json_content =
            ""

        inl package_json_path = package_dir </> "package.json"

        inl workspace_dir = package_dir </> "../.."
        inl workspace_package_json_path = workspace_dir </> "package.json"

        package_json_content |> file_system.write_all_text_exists package_json_path

        workspace_package_json_content |> file_system.write_all_text_exists workspace_package_json_path

        inl new_code_path = package_dir </> $'$"{!workspace_name}.{!extension}"'
        trace Debug
            fun () => $'"spiral_builder.process_typescript"'
            fun () => { new_code_path }
        inl new_code = new_code_path |> file_system.read_all_text

        inl main_code_header =
            "// spiral_builder.process_typescript"
        inl main_code = "// spiral_builder.process_typescript"

        inl cached = new_code |> sm'.contains main_code_header

        inl new_code =
            if cached
            then new_code
            else
                new_code
                |> sm'.replace
                    $'$"\\\"./fable_modules/fable-library-ts.{!version}/"'
                    $'$"\\\"{!workspace_root}/lib/typescript/fable/fable_modules/fable-library-ts.{!version}/"'
                |> sm'.replace_regex
                    "\\s\\sdefaultOf\\(\\);"
                    " defaultOf::<()>();"

        if not cached then
            $'$"{!new_code}\\n\\n{!main_code}\\n"'
            |> file_system.write_all_text_exists new_code_path

        inl command = $'$"bun run \\\"{!new_code_path}\\\""'
        inl environment_variables =
            match "~/.bun/bin" |> env.append_path with
            | Some path => [ "PATH", path ]
            | None => []
            ++ [
                "TRACE_LEVEL", "Verbose"
            ]
            |> listm'.box
            |> listm'.to_array'
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = workspace_root_external |> resultm.box |> resultm.ok'
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0 then
            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral_builder.process_typescript / Exception"
                            fun () => { ex new_code_path external_command run_result }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            { extension = Some extension; code = Some new_code; output = Some output }
        else
            trace Critical
                fun () => "spiral_builder.process_typescript / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; output = None }

#!markdown

## python

#!markdown

### process_python

#!spiral

inl process_python { fs_path deps trace_level } =
    inl extension = "py"
    inl is_trace = trace_level = Verbose
    inl _trace (fn : () -> string) =
        if is_trace
        then trace Info (fun () => $'$"spiral_builder.process_python / {!fn ()}"') id
        else fn () |> console.write_line

    inl code = fs_path |> file_system.read_all_text

    inl hash_hex = (extension, code) |> sm'.format_debug |> crypto.hash_text

    inl workspace_name = "spiral_builder"

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir =
        get_package_dir { workspace_root name = workspace_name; target = Some Python; hash = Some hash_hex }

    inl fsproj_path =
        persist_code_project
            {
                workspace_root
                package_dir
                packages = [ "Fable.Core" ]
                modules = []
                name = workspace_name
                code
            }

    inl lib_path = workspace_root </> "lib/python/fable/fable_modules"

    inl lib_link_target_path = lib_path </> $'$"fable_library"'
    inl lib_link_path = package_dir </> $'$"fable_modules/fable_library"'

    lib_link_path |> file_system.link_directory lib_link_target_path

    inl exit_code, dotnet_fable_result =
        execute_dotnet_fable { workspace_root_external fsproj_path extension package_dir }

    if exit_code <>. 0 then
        trace Critical
            fun () => $'$"spiral_builder.process_python"'
            fun () => { exit_code dotnet_fable_result }
        { extension = Some extension; code = None; output = Some dotnet_fable_result }
    else
        inl deps =
            deps
            |> am'.vec_map fun dep =>
                inl dep = dep |> sm'.from_std_string
                if dep |> sm'.contains "="
                then dep
                else $'$"\\"{!dep}\\":\\"*\\""'
            |> am'.from_vec
            |> fun x => x : _ i32 _
            |> seq.of_array'
            |> sm'.concat ",\n"

        inl package_json_content =
            $'$"{{"'
            +. $'$"  \\\"name\\\": \\\"spiral_builder_{!hash_hex}\\\","'
            +. $'$"  \\\"dependencies\\\": {{"'
            +. deps
            +. $'$"  }},"'
            +. $'$"    \\\"devDependencies\\\": {{"'
            +. $'$"  }},"'
            +. $'$"}}"'

        inl workspace_package_json_content =
            ""

        inl package_json_path = package_dir </> "package.json"

        inl workspace_dir = package_dir </> "../.."
        inl workspace_package_json_path = workspace_dir </> "package.json"

        package_json_content |> file_system.write_all_text_exists package_json_path

        workspace_package_json_content |> file_system.write_all_text_exists workspace_package_json_path

        inl new_code_path = package_dir </> $'$"{!workspace_name}.{!extension}"'
        trace Debug
            fun () => $'"spiral_builder.process_python"'
            fun () => { new_code_path }
        inl new_code = new_code_path |> file_system.read_all_text

        inl main_code_header =
            "# spiral_builder.process_python"
        inl main_code = "# spiral_builder.process_python"

        inl cached = new_code |> sm'.contains main_code_header

        inl new_code =
            if cached
            then new_code
            else
                new_code
                |> sm'.replace
                    ("),)" +. !\($'"\\\";\\\".into()"'))
                    "));"
                |> sm'.replace_regex
                    "\\s\\sdefaultOf\\(\\);"
                    " defaultOf::<()>();"

        if not cached
        then
            $'$"{!new_code}\\n\\n{!main_code}\\n"'
            |> file_system.write_all_text_exists new_code_path

        inl command = $'$"python \\\"{!new_code_path}\\\""'
        inl environment_variables =
            ;[
                "TRACE_LEVEL", "Verbose"
            ]
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = workspace_root_external |> resultm.box |> resultm.ok'
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0 then
            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral_builder.process_python / Exception"
                            fun () => { ex run_result new_code_path external_command }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            { extension = Some extension; code = Some new_code; output = Some output }
        else
            trace Critical
                fun () => "spiral_builder.process_python / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; output = None }

#!markdown

## cuda

#!markdown

### process_cuda

#!spiral

inl process_cuda { py_path env deps } =
    inl extension = "py"

    inl new_code_path = py_path
    inl new_code = new_code_path |> file_system.read_all_text

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl package_dir = new_code_path |> file_system.get_directory_name

    inl manifest_path =
        match env with
        | Pip => package_dir </> "requirements.txt"
        | Poetry => package_dir </> "pyproject.toml"

    inl deps =
        deps
        |> am'.vec_map fun dep =>
            inl dep = dep |> sm'.from_std_string
            if dep |> sm'.contains "="
            then dep
            elif dep |> sm'.ends_with "]"
            then dep |> sm'.replace "[" $'$"={{version=\'*\',features=["' |> fun x => $'$"{!x}}}"'
            else $'$"{!dep}=\'*\'"'
        |> am'.from_vec
        |> fun x => x : _ i32 _
        |> seq.of_array'
        |> sm'.concat "\n"

    inl exit_code, run_result =
        if deps = ""
        then 0, ""
        else
            inl manifest =
                match env with
                | Pip =>
                    deps
                | Poetry =>
                    $'$"[tool.poetry]"'
                    +#. $'$"name = \\\"test\\\""'
                    +#. $'$"version = \\\"0.0.1\\\""'
                    +#. $'$"description = \\\"\\\""'
                    +#. $'$"authors = []"'
                    +#. $'$""'
                    +#. $'$"[tool.poetry.dependencies]"'
                    +#. $'$"python=\\\"~3.12\\\""'
                    +#. $'$"{!deps}"'
                    +#. $'$""'
                    +#. $'$"[build-system]"'
                    +#. $'$"requires = [\\\"poetry-core\\\"]"'
                    +#. $'$"build-backend = \\\"poetry.core.masonry.api\\\""'

            manifest |> file_system.write_all_text_exists manifest_path

            runtime.execution_options fun x => { x with
                command =
                    match env with
                    | Pip => $'$"pip install -r requirements.txt"'
                    | Poetry => $'$"poetry install"'
                working_directory = package_dir |> optionm'.some'
            }
            |> runtime.execute_with_options

    if exit_code <>. 0 then
        trace Critical
            fun () => "spiral_builder.process_cuda / env install error"
            fun () => { env exit_code run_result new_code_path }
        { extension = Some extension; code = None; output = None }
    else
        inl command =
            match env with
            | Pip => $'$"python \\\"{!new_code_path}\\\""'
            | Poetry => $'$"poetry run python \\\"{!new_code_path}\\\""'
        inl environment_variables =
            ;[
                "TRACE_LEVEL", "Verbose"
            ]
        inl exit_code, run_result =
            runtime.execution_options fun x => { x with
                command
                environment_variables
                working_directory = package_dir |> optionm'.some'
            }
            |> runtime.execute_with_options

        inl external_command =
            inl vars =
                a environment_variables
                |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
                |> fun x => x : _ i32 _
                |> seq.of_array
                |> sm'.concat ";"
            $'$"pwsh -c \'{!vars}; {!command}\'"' : string
        if exit_code = 0
            || (run_result |> sm'.contains "cupy_backends.cuda.api.runtime.CUDARuntimeError: cudaErrorInsufficientDriver") then
            inl output =
                try
                    fun () =>
                        run_result
                        |> sm'.split "\n"
                        |> fun x => a x : _ i32 _
                        |> seq.of_array
                        |> sm'.concat "\n"
                    fun ex =>
                        trace Critical
                            fun () => "spiral_builder.process_cuda / Exception"
                            fun () => { ex run_result new_code_path external_command }
                        None
                |> optionm'.box
                |> optionm'.unwrap

            { extension = Some extension; code = Some new_code; output = Some output }
        else
            trace Critical
                fun () => "spiral_builder.process_cuda / error"
                fun () => { exit_code run_result new_code_path external_command }
            { extension = Some extension; code = None; output = None }

#!markdown

## fsharp

#!markdown

### process_fsharp

#!spiral

inl process_fsharp { spi_path } =
    inl extension = "fsx"

    inl new_code_path = spi_path
    inl new_code = new_code_path |> file_system.read_all_text

    inl workspace_root_external = file_system.get_workspace_root_external ()
    inl workspace_root = workspace_root_external |> resultm.box |> resultm.unwrap_or_else id

    inl supervisor_path = workspace_root </> $"apps/spiral/dist/Supervisor!(platform.get_executable_suffix ())"
    inl code_dir = new_code_path |> file_system.get_directory_name
    inl file_name = new_code_path |> file_system.get_file_name_without_extension
    inl output_path = code_dir </> $'$"{!file_name}.{!extension}"'
    inl command = $'$"{!supervisor_path} --build-file \\\"{!new_code_path}\\\" \\\"{!output_path}\\\""'
    inl environment_variables =
        ;[
            "TRACE_LEVEL", "Verbose"
        ]
    inl exit_code, run_result =
        runtime.execution_options fun x => { x with
            command
            environment_variables
            working_directory = workspace_root_external |> resultm.box |> resultm.ok'
        }
        |> runtime.execute_with_options

    inl external_command =
        inl vars =
            a environment_variables
            |> am.map fun k, v => $'$"$env:{!k}=\'\'{!v}\'\'"' : string
            |> fun x => x : _ i32 _
            |> seq.of_array
            |> sm'.concat ";"
        $'$"pwsh -c \'{!vars}; {!command}\'"' : string
    if exit_code = 0 then
        inl output =
            try
                fun () =>
                    run_result
                    |> sm'.split "\n"
                    |> fun x => a x : _ i32 _
                    |> seq.of_array
                    |> sm'.concat "\n"
                fun ex =>
                    trace Critical
                        fun () => "spiral_builder.process_fsharp / Exception"
                        fun () => { ex run_result new_code_path external_command }
                    None
            |> optionm'.box
            |> optionm'.unwrap

        { extension = Some extension; code = Some new_code; output = Some output }
    else
        trace Critical
            fun () => "spiral_builder.process_fsharp / error"
            fun () => { exit_code run_result new_code_path external_command }
        { extension = Some extension; code = None; output = None }

#!markdown

## run

#!spiral

let rec run trace_level (matches : runtime.arg_matches) : async.future_pin (resultm.result' string string) =
    fun () =>
        match matches |> runtime.matches_subcommand |> optionm'.unbox with
        | Some (subcommand, arg_matches)
                when (subcommand |> sm'.from_std_string) = (get_args () .cuda |> fst) =>

            inl py_path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .cuda |> snd).py_path |> fst)
                |> optionm'.unbox
                |> optionm.value
                |> sm'.from_std_string

            inl env =
                arg_matches
                |> runtime.matches_get_one ((get_args () .cuda |> snd).env |> fst)
                |> optionm'.unbox
                |> optionm.map (
                    sm'.from_std_string
                    >> reflection.union_try_pick
                )
                |> optionm'.flatten
                |> optionm'.default_value Pip

            inl deps : am'.vec sm'.std_string =
                arg_matches
                |> runtime.matches_get_many ((get_args () .cuda |> snd).deps |> fst)
                |> optionm'.unbox
                |> optionm'.default_value (;[] |> am'.to_vec)

            inl command_result =
                process_cuda { py_path env deps }
                |> fun { extension code output } =>
                    ;[
                        "extension", extension |> optionm'.default_value ""
                        "code", code |> optionm'.default_value ""
                        "output", output |> optionm'.default_value ""
                    ]

            ;[
                "command_result",
                command_result
                |> am'.to_vec
                |> am'.vec_map' fun k, v =>
                    new_pair (sm'.to_std_string k) (sm'.to_std_string v)
                |> mapm.b_tree_map_from_vec_pairs
                |> sm'.serialize
                |> resultm.unwrap'
                |> sm'.from_std_string
            ]

        | Some (subcommand, arg_matches)
                when (subcommand |> sm'.from_std_string) = (get_args () .fable |> fst) =>

            inl fs_path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .fable |> snd).fs_path |> fst)
                |> optionm'.unbox
                |> optionm.value
                |> sm'.from_std_string

            inl command =
                arg_matches
                |> runtime.matches_get_one ((get_args () .fable |> snd).command |> fst)
                |> optionm'.unbox
                |> optionm.map sm'.from_std_string

            inl command_result =
                match command with
                | Some command =>
                    get_command ()
                    |> runtime.command_get_matches_from (
                        $'$"_ {!command} --fs-path \\\"{!fs_path}\\\""' |> runtime.split_args |> resultm.get
                    )
                    |> run trace_level
                    |> async.await
                    |> resultm.unwrap'
                | None => "{}"

            ;[
                "command_result",
                command_result
            ]

        | Some (subcommand, arg_matches)
            when (subcommand |> sm'.from_std_string) = (get_args () .dib |> fst) =>

            inl path =
                arg_matches
                |> runtime.matches_get_one ((get_args () .dib |> snd).path |> fst)
                |> optionm'.map'' (
                    sm'.from_std_string
                    >> file_system.absolute_path
                )
                |> optionm'.unwrap

            inl retries =
                arg_matches
                |> runtime.matches_get_one ((get_args () .dib |> snd).retries |> fst)
                |> optionm'.default_value' 1u8

            inl working_directory : optionm'.option' string =
                arg_matches
                |> runtime.matches_get_one ((get_args () .dib |> snd).working_directory |> fst)

            process_dib { path retries working_directory }

        | matches =>
            match matches with
            | Some (subcommand, arg_matches)
                    when (subcommand |> sm'.from_std_string) = (get_args () .rust |> fst) =>

                inl fs_path =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .rust |> snd).fs_path |> fst)
                    |> optionm'.unbox
                    |> optionm.value
                    |> sm'.from_std_string

                inl deps : am'.vec sm'.std_string =
                    arg_matches
                    |> runtime.matches_get_many ((get_args () .rust |> snd).deps |> fst)
                    |> optionm'.unbox
                    |> optionm'.default_value (;[] |> am'.to_vec)

                process_rust { fs_path deps trace_level }

            | Some (subcommand, arg_matches)
                    when (subcommand |> sm'.from_std_string) = (get_args () .typescript |> fst) =>

                inl fs_path =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .typescript |> snd).fs_path |> fst)
                    |> optionm'.unbox
                    |> optionm.value
                    |> sm'.from_std_string

                inl deps : am'.vec sm'.std_string =
                    arg_matches
                    |> runtime.matches_get_many ((get_args () .typescript |> snd).deps |> fst)
                    |> optionm'.unbox
                    |> optionm'.default_value (;[] |> am'.to_vec)

                process_typescript { fs_path deps trace_level }

            | Some (subcommand, arg_matches)
                    when (subcommand |> sm'.from_std_string) = (get_args () .python |> fst) =>
                inl fs_path =
                    arg_matches
                    |> runtime.matches_get_one ((get_args () .python |> snd).fs_path |> fst)
                    |> optionm'.unbox
                    |> optionm.value
                    |> sm'.from_std_string

                inl deps : am'.vec sm'.std_string =
                    arg_matches
                    |> runtime.matches_get_many ((get_args () .python |> snd).deps |> fst)
                    |> optionm'.unbox
                    |> optionm'.default_value (;[] |> am'.to_vec)

                process_python { fs_path deps trace_level }

            | Some (subcommand, arg_matches) =>
                trace Debug
                    fun () => $'"spiral_builder.run / invalid subcommand"'
                    fun () => { subcommand arg_matches }

                { extension = None; code = None; output = None }
            | _ =>
                { extension = None; code = None; output = None }
            |> fun { extension code output } =>
                ;[
                    "extension", extension |> optionm'.default_value ""
                    "code", code |> optionm'.default_value ""
                    "output", output |> optionm'.default_value ""
                ]
        |> am'.to_vec
        |> am'.vec_map' fun k, v =>
            new_pair (sm'.to_std_string k) (sm'.to_std_string v)
        |> mapm.b_tree_map_from_vec_pairs
        |> sm'.serialize
        |> resultm.map_error' (sm'.format' >> sm'.from_std_string)
        |> resultm.map' sm'.from_std_string
    |> async.future_init (3, 2) 1

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2 tokio['rt-multi-thread'] tokio-stream

types ()

inl file_name = "main.fs"
inl code = "3 - 6 |> System.Console.WriteLine\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
inl fs_path = temp_dir </> file_name

code |> file_system.write_all_text fs_path

get_command ()
|> runtime.command_get_matches_from ($'$"_ fable -f \\\"{!fs_path}\\\" -c \\\"rust -d regex=\'*\'\\\""' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on
|> resultm.unwrap'
|> sm'.deserialize
|> resultm.unwrap'
|> mapm.get ("command_result" |> sm'.to_std_string)
|> optionm'.unwrap
|> sm'.from_std_string
|> sm'.deserialize
|> resultm.unwrap'
|> fun result =>
    result
    |> mapm.get ("extension" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "rs"
    result
    |> mapm.get ("output" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "-3"

disposable |> use |> ignore

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2 tokio['rt-multi-thread'] tokio-stream

types ()

inl code = "3 - 6 |> System.Console.WriteLine\n"
inl file_name = "main.fs"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
inl fs_path = temp_dir </> file_name

code |> file_system.write_all_text fs_path

get_command ()
|> runtime.command_get_matches_from ($'$"_ fable -f \\\"{!fs_path}\\\" -c \\\"typescript\\\""' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on
|> resultm.unwrap'
|> sm'.deserialize
|> resultm.unwrap'
|> mapm.get ("command_result" |> sm'.to_std_string)
|> optionm'.unwrap
|> sm'.from_std_string
|> sm'.deserialize
|> resultm.unwrap'
|> fun result =>
    result
    |> mapm.get ("extension" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "ts"
    result
    |> mapm.get ("output" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "-3"

disposable |> use |> ignore

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io futures rand rayon regex serde_json sha2 tokio['rt-multi-thread'] tokio-stream

types ()

inl file_name = "main.fs"
inl code = "3 - 6 |> System.Console.WriteLine\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
inl fs_path = temp_dir </> file_name

code |> file_system.write_all_text fs_path

get_command ()
|> runtime.command_get_matches_from ($'$"_ fable -f \\\"{!fs_path}\\\" -c \\\"python\\\""' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on
|> resultm.unwrap'
|> sm'.deserialize
|> resultm.unwrap'
|> mapm.get ("command_result" |> sm'.to_std_string)
|> optionm'.unwrap
|> sm'.from_std_string
|> sm'.deserialize
|> resultm.unwrap'
|> fun result =>
    result
    |> mapm.get ("extension" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "py"
    result
    |> mapm.get ("output" |> sm'.to_std_string)
    |> optionm'.unwrap
    |> sm'.from_std_string
    |> _assert_eq "-3"

disposable |> use |> ignore

#!spiral

//// test
///! rust -d async-walkdir chrono clap encoding_rs encoding_rs_io rand rayon regex serde_json sha2 tokio['rt-multi-thread'] tokio-stream

types ()

inl file_name = "test.dib"
inl code =
    "#!meta\n\n{\"kernelInfo\":{\"defaultKernelName\":\"fsharp\",\"items\":[]}}\n\n#!fsharp\n\n3 - 6\n"

inl temp_dir, disposable =
    (file_name, code)
    |> sm'.format_debug
    |> crypto.hash_text
    |> file_system.create_temp_dir'
inl path = temp_dir </> file_name |> file_system.normalize_path

code
|> file_system.write_all_text path

get_command ()
|> runtime.command_get_matches_from ($'$"_ dib -p {!path}"' |> runtime.split_args |> resultm.get)
|> run Verbose
|> async.block_on
|> resultm.unwrap'
|> __assert_string_contains false "<pre>-3 "

$'$"{!path}.html"'
|> file_system.read_all_text
|> __assert_string_contains false "\"cell-id=1\""

disposable |> use |> ignore

#!markdown

## tests

#!spiral

inl tests () =
    rust.run_tests [
        "verify_app", fun _ =>
            get_command () |> runtime.command_debug_assert
    ]

#!markdown

## main

#!spiral

///! 

inl main (args : array_base string) =
    inl trace_state = get_trace_state_or_init None

    trace Debug
        fun () => $'$"spiral_builder.main"'
        fun () => { args }

    inl command = get_command ()
    inl arg_matches = command |> runtime.command_get_matches

    inl trace_state_level = trace_state.level

    inl result =
        arg_matches
        |> run *trace_state_level
        |> async.block_on
        |> resultm.unwrap'

    if *trace_state_level = Info
    then result |> console.write_line

    0i32

inl main () =
    types ()
    $'let tests () = !tests ()' : ()
    $'let main args = !main args' : ()
