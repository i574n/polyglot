/// # spiral_wasm
open rust.rust_operators
open rust
open sm'_operators

/// ## spiral_wasm

/// ### get_args
inl get_args () =
    {
        trace_level = "trace_level", 't'
        wasm = "wasm", 'w'
    }

/// ### get_command
let get_command () =
    ##"command"
    |> runtime.new_command
    |> runtime.command_args_override_self true
    |> runtime.command_init_arg (get_args () .trace_level) (
        real runtime.arg_union `trace_level ignore
    )
    |> runtime.command_init_arg (get_args () .wasm) (
        runtime.arg_required true
    )

/// ### anyhow_result
nominal anyhow_result t =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"anyhow::Result<$0>\")>]\n#endif\ntype anyhow_Result<'T> = class end"
        $'' : $'anyhow_Result<`t>'
    )

/// ### anyhow_error
nominal anyhow_error =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"anyhow::Error\")>]\n#endif\ntype anyhow_Error = class end"
        $'' : $'anyhow_Error'
    )

inl anyhow_error error =
    !\\(error, $'"anyhow::anyhow\!($0)"')

/// ### gas
nominal gas =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::types::Gas\")>]\n#endif\ntype near_workspaces_types_Gas = class end"
        $'' : $'near_workspaces_types_Gas'
    )

/// ### near_token
nominal near_token =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::types::NearToken\")>]\n#endif\ntype near_token_NearToken = class end"
        $'' : $'near_token_NearToken'
    )

/// ### near_workspaces_error
nominal near_workspaces_error =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::error::Error\")>]\n#endif\ntype near_workspaces_error_Error = class end"
        $'' : $'near_workspaces_error_Error'
    )

/// ### sandbox
nominal sandbox =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::network::Sandbox\")>]\n#endif\ntype near_workspaces_network_Sandbox = class end"
        $'' : $'near_workspaces_network_Sandbox'
    )

/// ### worker
nominal worker t =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::Worker<$0>\")>]\n#endif\ntype near_workspaces_Worker<'T> = class end"
        $'' : $'near_workspaces_Worker<`t>'
    )

/// ### contract
nominal contract =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::Contract\")>]\n#endif\ntype near_workspaces_Contract = class end"
        $'' : $'near_workspaces_Contract'
    )

/// ### call_transaction
nominal call_transaction =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::operations::CallTransaction\")>]\n#endif\ntype near_workspaces_operations_CallTransaction = class end"
        $'' : $'near_workspaces_operations_CallTransaction'
    )

/// ### execution_final_result
nominal execution_final_result =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::result::ExecutionFinalResult\")>]\n#endif\ntype near_workspaces_result_ExecutionFinalResult = class end"
        $'' : $'near_workspaces_result_ExecutionFinalResult'
    )

/// ### execution_result
nominal execution_result t =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::result::ExecutionResult<$0>\")>]\n#endif\ntype near_workspaces_result_ExecutionResult<'T> = class end"
        $'' : $'near_workspaces_result_ExecutionResult<`t>'
    )

/// ### execution_success
nominal execution_success =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::result::ExecutionSuccess\")>]\n#endif\ntype near_workspaces_result_ExecutionSuccess = class end"
        $'' : $'near_workspaces_result_ExecutionSuccess'
    )

/// ### execution_failure
nominal execution_failure =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::result::ExecutionFailure\")>]\n#endif\ntype near_workspaces_result_ExecutionFailure = class end"
        $'' : $'near_workspaces_result_ExecutionFailure'
    )

/// ### execution_outcome
nominal execution_outcome =
    `(
        global "#if FABLE_COMPILER\n[<Fable.Core.Erase; Fable.Core.Emit(\"near_workspaces::result::ExecutionOutcome\")>]\n#endif\ntype near_workspaces_result_ExecutionOutcome = class end"
        $'' : $'near_workspaces_result_ExecutionOutcome'
    )

/// ### sandbox_worker
inl sandbox_worker () : resultm.result' (worker sandbox) near_workspaces_error =
    !\($'"near_workspaces::sandbox().await"')

/// ### dev_deploy
inl dev_deploy
    (wasm : am'.vec u8)
    (worker : worker sandbox)
    : async.future_pin (resultm.result' contract near_workspaces_error)
    =
    !\\(worker, $'"Box::pin($0.dev_deploy(&!wasm))"')

/// ### call
inl call (fn_name : string) (contract : contract) : call_transaction =
    !\\((contract, fn_name), $'"$0.call(&*$1)"')

/// ### transact
inl transact
    (call : call_transaction)
    : async.future_pin (resultm.result' execution_final_result near_workspaces_error)
    =
    !\($'"Box::pin(!call.transact())"')

/// ### logs
inl logs (result : execution_final_result) : am'.vec (rust.ref sm'.str) =
    !\($'"!result.logs()"')

/// ### into_result
inl into_result
    (result : execution_final_result)
    : resultm.result' execution_success execution_failure
    =
    !\\(result, $'"$0.into_result()"')

/// ### receipt_failures
inl receipt_failures (result : execution_final_result) : am'.vec (rust.ref execution_outcome) =
    inl result = join result
    !\($'"!result.receipt_failures()"')

/// ### receipt_outcomes
inl receipt_outcomes (result : execution_final_result) : rust.ref (am'.slice execution_outcome) =
    inl result = join result
    !\($'"!result.receipt_outcomes()"')

/// ### json
inl json (result : execution_final_result) : resultm.result' sm'.std_string near_workspaces_error =
    !\\(result, $'"$0.json()"')

/// ### borsh
inl borsh (result : execution_final_result) : resultm.result' sm'.std_string near_workspaces_error =
    !\\(result, $'"$0.borsh()"')

/// ### near_price_in_usd
inl near_price_in_usd () =
    6.68f64

/// ### gas_to_usd
inl gas_to_usd (gas : u64) =
    (gas |> f64) / 10_000_000_000_000_000 * near_price_in_usd ()

/// ### tokens_to_usd
inl tokens_to_usd (tokens : rust.u128) =
    (tokens |> rust.f64) / 1_000_000_000_000_000_000_000_000 * near_price_in_usd ()

/// ### total_gas_burnt
inl total_gas_burnt (result : execution_final_result) : gas =
    !\\(result, $'"$0.total_gas_burnt"')

/// ### as_gas
inl as_gas (gas : gas) : u64 =
    !\\(gas, $'"$0.as_gas()"')

/// ### as_yoctonear
inl as_yoctonear (gas : near_token) : rust.u128 =
    !\\(gas, $'"$0.as_yoctonear()"')

/// ### outcomes
inl outcomes (result : execution_final_result) : am'.vec (rust.ref execution_outcome) =
    inl result = result |> rust.emit
    !\($'"!result.outcomes()"')

/// ### is_success
inl is_success (outcome : execution_outcome) : bool =
    !\\(outcome, $'"$0.is_success()"')

/// ### gas_burnt
inl gas_burnt (outcome : execution_outcome) : gas =
    !\\(outcome, $'"$0.gas_burnt"')

/// ### tokens_burnt
inl tokens_burnt (outcome : execution_outcome) : near_token =
    !\\(outcome, $'"$0.tokens_burnt"')

/// ### print_usd
inl print_usd (result : execution_final_result) =
    inl total_gas_burnt = result |> total_gas_burnt |> as_gas
    inl total_gas_burnt_usd = total_gas_burnt |> gas_to_usd

    trace Debug
        fun () => "spiral_wasm.print_usd"
        fun () => { total_gas_burnt_usd total_gas_burnt }

    result
    |> outcomes
    |> iter.into_iter
    |> iter.cloned
    |> iter.for_each fun outcome =>
        inl is_success = outcome |> is_success

        inl gas_burnt = outcome |> gas_burnt |> as_gas
        inl gas_burnt_usd = gas_burnt |> gas_to_usd

        inl tokens_burnt = outcome |> tokens_burnt |> as_yoctonear
        inl tokens_burnt_usd = tokens_burnt |> tokens_to_usd

        trace Debug
            fun () => "spiral_wasm.print_usd / outcome"
            fun () => { is_success gas_burnt_usd tokens_burnt_usd gas_burnt tokens_burnt }

/// ### run
let rec run (matches : runtime.arg_matches) : async.future_pin (resultm.result' () anyhow_error) =
    fun () =>
        inl wasm_path =
            matches
            |> runtime.matches_get_one (get_args () .wasm |> fst)
            |> optionm'.unbox
            |> optionm.value
            |> sm'.from_std_string

        trace Verbose (fun () => "spiral_wasm.run") fun () => { wasm_path }

        inl wasm = wasm_path |> file_system.read |> resultm.try'

        inl worker = sandbox_worker () |> resultm.try'

        trace Verbose (fun () => "spiral_wasm.run") fun () => { worker }

        inl contract = worker |> dev_deploy wasm |> async.await |> resultm.try'

        trace Verbose (fun () => "spiral_wasm.run") fun () => { contract }

        inl result = contract |> call "state_main" |> transact |> async.await |> resultm.try'

        trace Verbose (fun () => "spiral_wasm.run") fun () => { result }

        result |> logs |> am'.vec_map sm'.ref_to_std_string |> am'.vec_for_each console.write_line

        result |> print_usd

        inl result2 = result |> into_result

        trace Verbose (fun () => "spiral_wasm.run") fun () => { result2 }

        inl receipt_failures = result |> receipt_failures

        trace Verbose (fun () => "spiral_wasm.run") fun () => { receipt_failures }

        inl receipt_outcomes = result |> receipt_outcomes

        trace Verbose (fun () => "spiral_wasm.run") fun () => { receipt_outcomes }

        inl json = result |> json

        trace Verbose (fun () => "spiral_wasm.run") fun () => { json }

        inl borsh = result |> borsh

        trace Verbose (fun () => "spiral_wasm.run") fun () => { borsh }

        if (receipt_failures |> am'.vec_len |> i32) = 0
        then Ok () |> resultm.box
        else "<error>" |> anyhow_error |> resultm.err
    |> async.new_future_move

/// ### main
///! _

inl main (args : array_base string) =
    inl command = get_command ()
    inl arg_matches = command |> runtime.command_get_matches

    inl trace_level =
        arg_matches
        |> runtime.matches_get_one (get_args () .trace_level |> fst)
        |> optionm'.unbox
        |> optionm.map (
            sm'.from_std_string
            >> reflection.union_try_pick
        )
        |> optionm'.flatten
        |> optionm'.default_value Verbose

    inl trace_state = get_trace_state_or_init (Some trace_level)

    trace Verbose
        fun () => $'$"spiral_wasm.main"'
        fun () => { args }

    arg_matches
    |> run
    |> async.block_on
    |> resultm.unwrap'

    0i32

inl main () =
    $'let main args = !main args' : ()
